#+TITLE: Emacs Literate Configuration
#+AUTHOR: Colin McLear
#+PROPERTY: header-args :tangle yes
#+COLUMNS: %35ITEM %15NAME %35DEPENDS %15TAGS %TODO
#+TODO: BROKEN DISABLED FIXME TESTING | DONE

This is my emacs configuration file. I use [[http://orgmode.org][org-mode]] to organize it and
then "tangle" the file using [[http://orgmode.org/worg/org-contrib/babel/][org-babel]]. You can find a helpful
discussion of this method [[http://stackoverflow.com/questions/17416738/emacs-initialization-as-org-file-how-can-i-get-the-right-version-of-org-mode][here]].

I use emacs for all my academic work. The configuration tends in that
direction. It also uses [[http://www.vim.org][vim]] keybindings. I used vim (or [[https://neovim.io][neovim]]) previously. I
think vim's modal editing is the best way to use a text-editor. If you like
vim bindings but don't tend to want to think about configuring emacs, I
strongly recommend [[http://spacemacs.org][spacemacs]] or [[https://github.com/hlissner/doom-emacs][doom-emacs]] as a way of managing your
configuration. For a more traditional emacs feel there are also the
configurations of [[https://github.com/purcell/emacs.d][purcell]] and [[https://github.com/bbatsov/prelude][batsov (prelude)]] and [[https://github.com/caisah/emacs.dz][many others]]. For a
minimally sane setup you might also look at some [[https://github.com/hrs/sensible-defaults.el][sensible defaults]]. This file
is also heavily influenced by the [[https://github.com/gilbertw1/bmacs][bmacs]] configuration of Bryan Gilbert, as
well as his [[https://github.com/gilbertw1/emacs-literate-starter][literate starter kit]]. 

* Configuration
:PROPERTIES:
:VISIBILITY: children
:END:

** Table of Contents :TOC_2_gh:
- [[#configuration][Configuration]]
  - [[#about-this-file][About This File]]
  - [[#personal-information][Personal Information]]
  - [[#variables][Variables]]
  - [[#security-settings][Security Settings]]
  - [[#emacs-initialization][Emacs Initialization]]
  - [[#general-settings][General Settings]]
  - [[#functions--macros][Functions & Macros]]
  - [[#useful-libraries][Useful Libraries]]
  - [[#modal-editing][Modal Editing]]
  - [[#appearance--ui][Appearance & UI]]
  - [[#navigation][Navigation]]
  - [[#org][Org]]
  - [[#search][Search]]
  - [[#shell][Shell]]
  - [[#completion][Completion]]
  - [[#session--project-management][Session & Project Management]]
  - [[#version-control][Version Control]]
  - [[#programming][Programming]]
  - [[#research--writing][Research & Writing]]
  - [[#private][Private]]
  - [[#miscellaneous-packages][Miscellaneous Packages]]
  - [[#post-initialization][Post Initialization]]

** About This File
This is an Emacs literate configuration template. It contains the basic structure
of a literate config along with some optimizations to ensure a fast load time.
*** Org File Tweaks
There are a few tweaks included in this org file that make it a little easier to
work with.
**** Automatically Tangle
First there is a property defined on the file:

=header-args :tangle yes= 

This tells emacs to automatically tangle (include) all code blocks in this file when
generating the code for the config, unless the code block explicitly includes
=:tangle no= as the above code block does.
**** Visibility Settings
Next we have a property defined on the [[Configuration][Configuration]] heading that defines the visibility
that tells org to show it's direct children on startup. This way a clean outline of all
sub headings under Configuration is shown each time this file is opened in org-mode.
**** Table of Contents
Finally, there is a [[Table of Contents][Table of Contents]] heading that includes the tag: =:TOC_3_gh:=. This
tells an org-mode package =toc-org= to generate a table of contents under this heading
that has a max depth of 3 and is created using Github-style hrefs. This table of contents
is updated everytime the file is saved and makes for a functional table of contents that
works property directly on github.
** Personal Information
Let's set some variables with basic user information.

#+BEGIN_SRC emacs-lisp
(setq user-full-name "Colin McLear"
      user-mail-address "mclear@fastmail.com")
#+END_SRC
** Variables
*** Font
 [[http://levien.com/type/myfonts/inconsolata.html][Inconsolata]] is a nice monospaced font. I use a version, Inconsolata-LGC,
 that also has bold and italic fonts.

 To install it on OS X, you can use Homebrew with [[http://caskroom.io/][Homebrew Cask]].

 #+begin_src sh :tangle no
 # You may need to run these two lines if you haven't set up Homebrew
 # Cask and its fonts formula.
 brew install caskroom/cask/brew-cask
 brew tap caskroom/fonts
 brew cask install font-inconsolata-lgc 
 #+END_SRC

 Here I set the variable values, including a variable font face for themes
 that use that for headings, such as [[*Solarized][solarized]]. 

 #+BEGIN_SRC emacs-lisp
 (defvar cmacs-font (font-spec :family "Inconsolata LGC" :size 13))
 (defvar cmacs-vari-font (font-spec :family "Avenir"))
 #+END_SRC
*** Leader Keys

 Define the leader and local leader keys. These are the basis of most custom global and mode specific
 keybindings.

 #+BEGIN_SRC emacs-lisp
 (eval-and-compile
   (defvar cmacs-leader-key "SPC"
     "The leader prefix key, for global commands.")

   (defvar cmacs-localleader-key "SPC m"
     "The localleader prefix key, for major-mode specific commands."))
 #+END_SRC
*** Directories

 We're going to define a number of directories that are used throughout this configuration to store
 different types of files.

 #+BEGIN_SRC emacs-lisp
   (eval-and-compile
     (defvar cmacs-emacs-dir (expand-file-name user-emacs-directory)
       "The path to the emacs.d directory.")

     (defvar cmacs-local-dir (concat cmacs-emacs-dir ".local/")
       "Root directory for local Emacs files. Use this as permanent storage for files
     that are safe to share across systems (if this config is symlinked across
     several computers).")

     (defvar cmacs-host-dir (concat cmacs-local-dir "@" (system-name))
       "Directory for hostname-specific file storage. Used by `cmacs-etc-dir' and
     `cmacs-cache-dir'.")

     (defvar cmacs-etc-dir (concat cmacs-host-dir "/etc/")
       "Host-namespaced directory for non-volatile storage. These are not deleted or
     tampored with by CMACS functions. Use this for dependencies like servers or
     config files that are stable (i.e. it should be unlikely that you need to delete
     them if something goes wrong).")

     (defvar cmacs-cache-dir (concat cmacs-host-dir "/cache/")
       "Host-namespaced directory for volatile storage. Deleted when `cmacs/reset' is
     called. Use this for transient files that are generated on the fly like caches
     and temporary files. Anything that may need to be cleared if there are
     problems.")
     
     (defvar cmacs-elisp-dir (concat cmacs-local-dir "elisp/")
       "Where personal elisp packages and scripts are stored.")


     (dolist (dir (list cmacs-local-dir cmacs-etc-dir
     cmacs-cache-dir (expand-file-name "elisp" cmacs-elisp-dir)))
       (unless (file-directory-p dir)
	 (make-directory dir t))))
 #+END_SRC
*** Hooks

 #+BEGIN_SRC emacs-lisp
 (defvar cmacs-post-init-hook nil
   "A list of hooks run after CMACS initialization is complete, and after
 `cmacs-init-hook'.")
 #+END_SRC
*** Misc

 #+BEGIN_SRC emacs-lisp
 (defvar cmacs-popups '()
   "A list of popup matchers that determine if a popup can be escaped")
 #+END_SRC
** Security Settings
Properly verify outgoing ssl connections.

#+BEGIN_SRC emacs-lisp
(setq gnutls-verify-error t
      tls-checktrust gnutls-verify-error
      tls-program (list "gnutls-cli --x509cafile %t -p %p %h"
                        ;; compatibility fallbacks
                        "gnutls-cli -p %p %h"
                        "openssl s_client -connect %h:%p -no_ssl2 -no_ssl3 -ign_eof")
      nsm-settings-file (expand-file-name "network-security.data" cmacs-cache-dir))
#+END_SRC
** Emacs Initialization
*** Initialization Settings
We're going to increase the gc-cons-threshold to a very high number to decrease the load and compile time.
We'll lower this value significantly after initialization has completed. We don't want to keep this value
too high or it will result in long GC pauses during normal usage.

#+BEGIN_SRC emacs-lisp 
(eval-and-compile
  (setq gc-cons-threshold 402653184
        gc-cons-percentage 0.6))

;; Let's lower our GC thresholds back down to a sane level.
(add-hook 'cmacs-post-init-hook #'(lambda () (setq gc-cons-threshold 100000
                                                   gc-cons-percentage 0.1)))
#+END_SRC

Now, we're going to disable double-buffering to prevent stuttering.

#+BEGIN_SRC emacs-lisp
(add-to-list 'default-frame-alist '(inhibit-double-buffering . t))
#+END_SRC

Disable certain byte compiler warnings to cut down on the noise. This is a personal choice and can be removed
if you would like to see any and all byte compiler warnings.

#+BEGIN_SRC emacs-lisp
(setq byte-compile-warnings '(not free-vars unresolved noruntime lexical make-local))
#+END_SRC
*** FIXME Use-Package Settings
# talk about setting in init.el
Tell =use-package= to always defer loading packages unless explicitly told otherwise. This speeds up
initialization significantly as many packages are only loaded later when they are explicitly used.

#+BEGIN_SRC emacs-lisp
#+END_SRC
** General Settings
*** System Defaults
Let's use sane defaults. Sources for this section include [[https://github.com/magnars/.emacs.d/blob/master/settings/sane-defaults.el][Magnars Sveen]] and [[http://pages.sachachua.com/.emacs.d/Sacha.html][Sacha Chua]].
**** Environment settings
Make sure emacs correctly sets up your PATH.
#+BEGIN_SRC emacs-lisp
  (defvar cpm-local-bin (concat (getenv "HOME") "/bin") "Local execs.")
  (defvar usr-local-bin "/usr/local/bin")
  (setenv "PATH" (concat usr-local-bin ":" (getenv "PATH") ":" cpm-local-bin))
  (setq exec-path (append exec-path (list cpm-local-bin usr-local-bin)))
#+END_SRC 
**** Deal with warnings
No bells and no visible "bell" either!
#+BEGIN_SRC emacs-lisp
  (setq visible-bell nil) ;; The default
  (setq ring-bell-function 'ignore)
  ;; Silence warnings generated by a function's being redefine by =defadvice=.
  (setq ad-redefinition-action 'accept)
#+END_SRC
**** No startup message
#+BEGIN_SRC emacs-lisp
  ;; Change the echo message
(defun display-startup-echo-area-message ()
  (message ""))
#+END_SRC
**** These functions are useful. Activate them.
#+BEGIN_SRC emacs-lisp
  (put 'downcase-region 'disabled nil)
  (put 'upcase-region 'disabled nil)
  (put 'narrow-to-region 'disabled nil)
  (put 'dired-find-alternate-file 'disabled nil)
#+END_SRC
**** Answering just 'y' or 'n' will do
#+BEGIN_SRC emacs-lisp
  (defalias 'yes-or-no-p 'y-or-n-p)
#+END_SRC
**** UTF-8 please
#+BEGIN_SRC emacs-lisp
  (setq locale-coding-system 'utf-8) 
  (set-terminal-coding-system 'utf-8) 
  (set-keyboard-coding-system 'utf-8) 
  (set-selection-coding-system 'utf-8)
  (prefer-coding-system 'utf-8) 
#+END_SRC
**** Give buffers unique names
#+BEGIN_SRC emacs-lisp
  (setq uniquify-buffer-name-style 'forward)
#+END_SRC
**** Dired settings
#+BEGIN_SRC emacs-lisp
(setq insert-directory-program "gls" dired-use-ls-dired t)
;; list directories first
(setq dired-listing-switches "-al --group-directories-first")
;; stop asking about recurisve actions
(setq dired-recursive-copies 'always)
(setq dired-recursive-deletes 'always)
#+END_SRC
**** Dired Copy Large Files & Directories
Lets you copy huge files and directories without Emacs freezing up and
with convenient progress bar updates. Courtesy of [[https://oremacs.com/2016/02/24/dired-rsync/][Or Emacs]]. 
#+BEGIN_SRC emacs-lisp
;;;###autoload
(defun ora-dired-rsync (dest)
  (interactive
   (list
    (expand-file-name
     (read-file-name
      "Rsync to:"
      (dired-dwim-target-directory)))))
  ;; store all selected files into "files" list
  (let ((files (dired-get-marked-files
                nil current-prefix-arg))
        ;; the rsync command
        (tmtxt/rsync-command
         "rsync -arvz --progress "))
    ;; add all selected file names as arguments
    ;; to the rsync command
    (dolist (file files)
      (setq tmtxt/rsync-command
            (concat tmtxt/rsync-command
                    (shell-quote-argument file)
                    " ")))
    ;; append the destination
    (setq tmtxt/rsync-command
          (concat tmtxt/rsync-command
                  (shell-quote-argument dest)))
    ;; run the async shell command
    (async-shell-command tmtxt/rsync-command "*rsync*")
    ;; finally, switch to that window
    (other-window 1)))


#+END_SRC
**** Help Buffers
#+BEGIN_SRC emacs-lisp
;; Keep focus while navigating help buffers
(setq help-window-select 't)
#+END_SRC
**** Clipboard
#+BEGIN_SRC emacs-lisp
; Merge system's and Emacs' clipboard
(setq select-enable-clipboard t)
;; Save whatever’s in the current (system) clipboard before
;; replacing it with the Emacs’ text.
;; https://github.com/dakrone/eos/blob/master/eos.org
(setq save-interprogram-paste-before-kill t)
(defun clipboard-on ()
    (interactive)
    (setq interprogram-cut-function 'paste-to-osx)
    (setq interprogram-paste-function 'copy-from-osx))
  (defun clipboard-off ()
    (interactive)
    (setq interprogram-cut-function 'gui-select-text)
    (setq interprogram-paste-function 'gui-selection-value))
  (global-set-key (kbd "S-p") 'clipboard-on)
  (global-set-key (kbd "S-y") 'clipboard-off)
#+END_SRC
**** File Endings
Make all files [[http://stackoverflow.com/questions/729692/why-should-text-files-end-with-a-newline][POSIX compliant for newlines]]
#+BEGIN_SRC emacs-lisp
;; Make sure your text files end in a newline
(setq require-final-newline t)
#+END_SRC
**** Paragraphs
From the [[https://www.emacswiki.org/emacs/FillParagraph][Emacs Wiki]] on fill paragraph.
#+BEGIN_SRC emacs-lisp
;; The original value is "\f\\|[      ]*$", so we add the bullets (-), (+), and (*).
    ;; There is no need for "^" as the regexp is matched at the beginning of line.
    (setq paragraph-start "\f\\|[ \t]*$\\|[ \t]*[-+*] ")
#+END_SRC
**** Disable Welcome Screen

#+BEGIN_SRC emacs-lisp
; Disable start-up screen
(setq-default inhibit-startup-screen t)                         
(setq inhibit-splash-screen t)
(setq inhibit-startup-message t)
(setq initial-scratch-message "")
;; And bury the scratch buffer, don't kill it
(defadvice kill-buffer (around kill-buffer-around-advice activate)
  (let ((buffer-to-kill (ad-get-arg 0)))
    (if (equal buffer-to-kill "*scratch*")
        (bury-buffer)
      ad-do-it)))
#+END_SRC
**** Start scratch in fundamental mode 
Useful to get a faster Emacs load time because it avoids autoloads of
elisp modes or other minor modes
#+BEGIN_SRC emacs-lisp
  (setq initial-major-mode 'fundamental-mode)
#+END_SRC
**** Turn off the blinking cursor
#+BEGIN_SRC emacs-lisp
(blink-cursor-mode 0)
#+END_SRC
**** Large Files
Warn only for files over 100MB
#+BEGIN_SRC emacs-lisp
(setq large-file-warning-threshold 100000000)
#+END_SRC
**** Apropos Everything
apropos commands perform more extensive searches than default
#+BEGIN_SRC emacs-lisp
(setq apropos-do-all t)
#+END_SRC
*** Backups
#+BEGIN_SRC emacs-lisp
  (let ((backup-dir (concat cmacs-cache-dir "backup")))
    ;; Move backup file to `~/.emacs.d/.cache/backup'
    (setq backup-directory-alist `(("." . ,backup-dir)))
    ;; Makesure backup directory exist
    (when (not (file-exists-p backup-dir))
      (make-directory backup-dir t)))

  (setq make-backup-files t               ; backup of a file the first time it is saved.
        backup-by-copying t               ; don't clobber symlinks
        version-control t                 ; version numbers for backup files
        delete-old-versions t             ; delete excess backup files silently
        delete-by-moving-to-trash t
        kept-old-versions 6               ; oldest versions to keep when a new numbered backup is made
        kept-new-versions 6               ; newest versions to keep when a new numbered backup is made
        )
  (setq vc-make-backup-files t) ;;  backup versioned files, which Emacs does not do by default


#+END_SRC
**** Backup Walker
Traverse backups with [[https://github.com/lewang/backup-walker][backup-walker]]
#+BEGIN_SRC emacs-lisp
(use-package backup-walker
  :commands backup-walker-start)
#+END_SRC
**** Auto Save
I make sure Emacs auto-saves often but the result is that it messes up my file tree. So, let's ask Emacs to store its backups in the cache directory.

#+BEGIN_SRC emacs-lisp
(setq auto-save-list-file-prefix
      (concat cmacs-cache-dir "auto-save-list/.saves-"))

(setq auto-save-default t               ; auto-save every buffer that visits a file
      auto-save-timeout 20              ; number of seconds idle time before auto-save (default: 30)
      auto-save-interval 200            ; number of keystrokes between auto-saves (default: 300)
      auto-save-visited-file-name nil
      delete-auto-save-files t
      create-lockfiles nil)
#+END_SRC
**** Full Auto Save
I also make emacs just outright save all buffers. 
#+BEGIN_SRC emacs-lisp
  (defun full-auto-save ()
    (interactive)
    (save-excursion
      (dolist (buf (buffer-list))
        (set-buffer buf)
        (if (and (buffer-file-name) (buffer-modified-p))
            (basic-save-buffer)))))
  (add-hook 'auto-save-hook 'full-auto-save)
#+END_SRC
*** Custom file 
Set up the customize file to its own [[file:$HOME/.emacs.d/custom.el][separate file]], instead of saving
customize settings in [[file:init.el][init.el]].

#+begin_src emacs-lisp
(setq custom-file (expand-file-name "custom.el" user-emacs-directory))
(when (file-exists-p custom-file)
  (load custom-file))
#+end_src
*** Mac OS 
There is some configuration to do when running Emacs on OS X (hence the
"darwin" system-type check).

First we can define some general system checks
#+BEGIN_SRC emacs-lisp
(setq IS-LINUX (eq system-type 'gnu/linux)
      IS-MAC (eq system-type 'darwin))
#+END_SRC


#+begin_src emacs-lisp
    (when IS-MAC
      ;; make fonts look better with anti-aliasing
      (setq mac-allow-anti-aliasing t)
      ;; delete files by moving them to the trash
      (setq delete-by-moving-to-trash t)
      (setq trash-directory "~/.Trash")

      ;; Don't make new frames when opening a new file with Emacs
      (setq ns-pop-up-frames nil)

      ;; fullscreen (disable for non-space full screen)
      (setq ns-use-native-fullscreen t)

      ;; disable emacs-mac smooth scrolling because it is seriously janky
      (setq mac-mouse-wheel-smooth-scroll nil)

      ;; Set modifier keys
      (setq mac-option-modifier 'meta) ;; Bind meta to ALT
      (setq mac-command-modifier 'super) ;; Bind apple/command to super if you want
      (setq mac-function-modifier 'hyper) ;; Bind function key to hyper if you want 
      (setq mac-right-option-modifier 'none) ;; unbind right key for accented input

      ;; Make forward delete work 
      (global-set-key (kbd "<H-backspace>") 'delete-forward-char)

      ;; Keybindings
      (global-set-key (kbd "s-=") 'scale-up-font)
      (global-set-key (kbd "s--") 'scale-down-font)
      (global-set-key (kbd "s-0") 'reset-font-size)
      (global-set-key (kbd "s-q") 'save-buffers-kill-terminal)
      (global-set-key (kbd "s-v") 'yank)
      (global-set-key (kbd "s-c") 'evil-yank)
      (global-set-key (kbd "s-a") 'mark-whole-buffer)
      (global-set-key (kbd "s-x") 'kill-region)
      (global-set-key (kbd "s-w") 'delete-window)
      (global-set-key (kbd "s-W") 'delete-frame)
      (global-set-key (kbd "s-n") 'make-frame)
      (global-set-key (kbd "s-z") 'undo-tree-undo)
      (global-set-key (kbd "s-s")
                      (lambda ()
                        (interactive)
                        (call-interactively (key-binding "\C-x\C-s"))))
      (global-set-key (kbd "s-Z") 'undo-tree-redo)
      (global-set-key (kbd "C-s-f") 'toggle-frame-fullscreen)
      ;; Emacs sometimes registers C-s-f as this weird keycode
      (global-set-key (kbd "<C-s-268632070>") 'toggle-frame-fullscreen)
  )

      (defun open-dir-in-iterm ()
        "Open the current directory of the buffer in iTerm."
        (interactive)
        (let* ((iterm-app-path "/Applications/iTerm.app")
               (iterm-brew-path "/opt/homebrew-cask/Caskroom/iterm2/2.1.4/iTerm.app")
               (iterm-path (if (file-directory-p iterm-app-path)
                               iterm-app-path
                             iterm-brew-path)))
          (shell-command (concat "open -a " iterm-path " ."))))
          (global-set-key (kbd "C-x t") 'open-dir-in-iterm)

      ;; Not going to use these commands
      (put 'ns-print-buffer 'disabled t)
      (put 'suspend-frame 'disabled t)

      ;; -- This is for TextExpander
      ;; (setq ns-alternate-modifier 'alt)
      ;; (define-key global-map [(alt ?v)] 'scroll-down)
      ;; (define-key global-map [(meta ?v)] 'yank)
#+end_src
*** Time and Date Stamps
**** Emacs buffer timestamp settings
#+BEGIN_SRC emacs-lisp
  (setq 
    time-stamp-active t          ; do enable time-stamps
    time-stamp-line-limit 10     ; check first 10 buffer lines for Time-stamp: 
    time-stamp-format "Last modified on %02m-%02d-%04y %02H:%02M:%02S (%U)") ; date format
  (add-hook 'write-file-hooks 'time-stamp) ; update when saving
#+END_SRC
**** Insert time or date
The code below sets the correct value for system-time-locale, and binds
keys for insert-date/long and insert-date/short. Courtesy of [[https://ebzzry.github.io/emacs-hacks-2.html#desktop][emacs-hacks]].
#+BEGIN_SRC emacs-lisp
  (defun format-date (format)
  (let ((system-time-locale "en_US.UTF-8"))
    (insert (format-time-string format))))

(defun insert-date ()
  (interactive)
  (format-date "%A, %B %d %Y"))

(defun insert-date-and-time ()
  (interactive)
  (format-date "%m-%d-%Y %H:%M:%S"))
#+END_SRC
*** Location
Make Emacs watch and respond to changes in [[https://github.com/purcell/osx-location][geographical location]] on OS X
#+BEGIN_SRC emacs-lisp
(use-package osx-location
  :if (eq system-type 'darwin)
  :demand t
  :config
  (osx-location-watch)
  (add-hook 'osx-location-changed-hook
               (lambda ()
                 (setq calendar-latitude osx-location-latitude
                       calendar-longitude osx-location-longitude
                       calendar-location-name (format "%s, %s" osx-location-latitude osx-location-longitude)))))
#+END_SRC
*** Text Settings
General Text settings and hooks
**** Sentence endings
#+BEGIN_SRC emacs-lisp
;; Single space between sentences is more widespread than double
(setq-default sentence-end-double-space nil)
#+END_SRC
**** Subwords and CamelCase
#+BEGIN_SRC emacs-lisp
; Iterate through CamelCase words
(global-subword-mode 1)                           
#+END_SRC
**** Spelling
Use flyspell and aspell
#+BEGIN_SRC emacs-lisp
(use-package ispell
  :defer 10
  :config
  ;; Save a new word to personal dictionary without asking
  (setq ispell-silently-savep t)
  (setq-default ispell-program-name "aspell")
  (setq-default ispell-list-command "list")
  (setq ispell-extra-args
      (list "--sug-mode=fast" ;; ultra|fast|normal|bad-spellers
            "--lang=en_US"
            "--ignore=3")))

(use-package flyspell
  :diminish flyspell-mode
  :defer 11
  ;; :commands (flyspell-mode flyspell-prog-mode)
  :init
  (progn
  ;; Below variables need to be set before `flyspell' is loaded.
    (setq flyspell-use-meta-tab nil))
  :config
  ;; Save a new word to personal dictionary without asking
  (setq flyspell-issue-welcome-flag nil))
#+END_SRC 
**** Flyspell hooks
Flyspell is in elisp mode. And this in turn loads flyspell directly
after launching emacs, which is a bit unfortunate.

#+BEGIN_SRC emacs-lisp :tangle no
(defun my-flyspell-prog-mode ()
  (interactive)
  (unless (string= (buffer-name) "*scratch*")
	(flyspell-prog-mode)))
    (add-hook 'prog-mode-hook  #'my-flyspell-prog-mode)
    (add-hook 'text-mode-hook  #'flyspell-mode)
    (add-hook 'org-mode-hook   #'flyspell-mode)
    (add-hook 'latex-mode-hook #'flyspell-mode)
    (add-hook 'LaTeX-mode-hook #'flyspell-mode)
#+END_SRC
**** Spelling Autocorrect
Use abbrev-mode as my autocorrect. Via [[http://endlessparentheses.com/ispell-and-abbrev-the-perfect-auto-correct.html][Endless Parentheses]]. 
#+BEGIN_SRC emacs-lisp
(define-key ctl-x-map "\C-i"
  #'endless/ispell-word-then-abbrev)

(defun endless/simple-get-word ()
  (car-safe (save-excursion (ispell-get-word nil))))

(defun endless/ispell-word-then-abbrev (p)
  "Call `ispell-word', then create an abbrev for it.
With prefix P, create local abbrev. Otherwise it will
be global.
If there's nothing wrong with the word at point, keep
looking for a typo until the beginning of buffer. You can
skip typos you don't want to fix with `SPC', and you can
abort completely with `C-g'."
  (interactive "P")
  (let (bef aft)
    (save-excursion
      (while (if (setq bef (endless/simple-get-word))
                 ;; Word was corrected or used quit.
                 (if (ispell-word nil 'quiet)
                     nil ; End the loop.
                   ;; Also end if we reach `bob'.
                   (not (bobp)))
               ;; If there's no word at point, keep looking
               ;; until `bob'.
               (not (bobp)))
        (backward-word)
        (backward-char))
      (setq aft (endless/simple-get-word)))
    (if (and aft bef (not (equal aft bef)))
        (let ((aft (downcase aft))
              (bef (downcase bef)))
          (define-abbrev
            (if p local-abbrev-table global-abbrev-table)
            bef aft)
          (message "\"%s\" now expands to \"%s\" %sally"
                   bef aft (if p "loc" "glob")))
      (user-error "No typo at or before point"))))

(setq save-abbrevs 'silently)

(use-package abbrev
  :ensure nil
  :commands (abbrev-mode))

#+END_SRC
**** Only use spaces
#+BEGIN_SRC emacs-lisp
(setq-default indent-tabs-mode nil)
(setq-default tab-width 4)
(setq-default indicate-empty-lines nil)
#+END_SRC
**** Line wrap
#+BEGIN_SRC emacs-lisp
(global-visual-line-mode)
(setq line-move-visual t) ;; move via visual lines
#+END_SRC
**** Fill column
#+BEGIN_SRC emacs-lisp
(setq-default fill-column 78)
#+END_SRC
**** Visual replace
This is the [[https://github.com/benma/visual-regexp.el][good old search and replace]] as opposed to the fancy alternatives such as [[*Interactive edit][iedit]] and [[*Multiple cursors][multiple cursors]]. You search for a word in the buffer/region, type in the replacement and confirm each one by pressing =y= or =n= or just press =!= to apply this to everything.

#+BEGIN_SRC emacs-lisp
(use-package visual-regexp
  :commands (vr/query-replace)
  :config
  (use-package visual-regexp-steroids
    :commands (vr/select-query-replace)))
#+END_SRC
**** Show Matching Brackets
Show matching brackets, parenthesis, etc.
#+BEGIN_SRC emacs-lisp
(show-paren-mode t)
(setq show-paren-delay 0) 
#+END_SRC
** Functions & Macros
*** Useful Functions 
  Various useful functions and macros I've written or pilfered from others. 
**** Crux
A collection of ridiculously useful extensions. Indeed.
#+BEGIN_SRC emacs-lisp
(use-package crux :defer 10)
#+END_SRC
**** Toggle Fold
#+BEGIN_SRC emacs-lisp
  (defun cmacs/toggle-fold ()
    (interactive)
    (save-excursion
      (end-of-line)
      (hs-toggle-hiding)))
#+END_SRC
**** Config functions
#+BEGIN_SRC emacs-lisp
  (defun goto-init.el ()
      "Open init.el file"
      (interactive)
      (find-file "~/.emacs.d/init.el"))
  (defun goto-custom.el ()
      "Open custom.el file"
      (interactive)
      (find-file "~/.emacs.d/custom.el"))
  (defun goto-config.org ()
      "Open config.org file"
      (interactive)
      (find-file "~/.emacs.d/config.org"))
  (defun load-config ()
      "Load config "
      (interactive)
      (load-file "~/.emacs.d/config.el"))
  (defun goto-dotfiles.org ()
      "Open dotfiles.org file"
      (interactive)
      (find-file "~/dotfiles/dotfiles.org"))
  (defun goto-emacs-dir ()
      "Open dotfiles.org file"
      (interactive)
      (require 'ranger)
      (find-file "~/.emacs.d"))
  (defun goto-org-files ()
      "Open directory with org files"
      (interactive)
      (require 'ranger)
      (find-file org-directory))


#+END_SRC
**** Duplicate file
Duplicate a file in dired or deer
#+BEGIN_SRC emacs-lisp
(defun cpm/duplicate-file ()
  (interactive)
  (dired-do-copy-regexp "\\(.*\\)\\.\\(.*\\)" "\\1 (copy).\\2"))
#+END_SRC
**** Switch to previous buffer
#+BEGIN_SRC emacs-lisp
  (defun switch-to-previous-buffer ()
    (interactive)
    (switch-to-buffer (other-buffer (current-buffer) 1)))
#+END_SRC
**** Make parent directory
 Create a directory – or a hierarchy of them – while finding a file in a
 nonexistent directory. From [[http://mbork.pl/2016-07-25_Making_directories_on_the_fly][mbork]]. 
#+BEGIN_SRC emacs-lisp
  (defun make-parent-directory ()
    "Make sure the directory of `buffer-file-name' exists."
    (make-directory (file-name-directory buffer-file-name) t))

  (add-hook 'find-file-not-found-functions #'make-parent-directory)
#+END_SRC
**** New Git Project
Courtesy of a helpful [[https://www.reddit.com/r/emacs/comments/70ke5w/help_fix_my_workflow_to_create_a_new_gitmanaged/][reddit post]]
#+BEGIN_SRC emacs-lisp
(defun cpm/git-new-project ()
  "Initializes a new git repo and adds it to projectile's known projects."
  (interactive)
  (let ((project-dir (expand-file-name
                      (read-directory-name "New project root:"))))
    (magit-init project-dir)
    (projectile-add-known-project project-dir)
    (setq default-directory project-dir)))
#+END_SRC
**** Org wrap in block template
A helpful function I found [[http://pragmaticemacs.com/emacs/wrap-text-in-an-org-mode-block/][here]] for wrapping text in a block template. 
#+begin_src emacs-lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; function to wrap blocks of text in org templates                       ;;
;; e.g. latex or src etc                                                  ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun org-block-wrap ()
  "Make a template at point."
  (interactive)
  (if (org-at-table-p)
      (call-interactively 'org-table-rotate-recalc-marks)
    (let* ((choices '(
                      ("a" . "ASCII")
                      ("c" . "COMMENT")
                      ("C" . "CENTER")
                      ("e" . "EXAMPLE")
                      ("E" . "SRC emacs-lisp")
                      ("h" . "HTML")
                      ("l" . "LaTeX")
                      ("n" . "NOTES")
                      ("q" . "QUOTE")
                      ("s" . "SRC")
                      ("v" . "VERSE")
                      ))
           (key
            (key-description
             (vector
              (read-key
               (concat (propertize "Template type: " 'face 'minibuffer-prompt)
                       (mapconcat (lambda (choice)
                                    (concat (propertize (car choice) 'face 'font-lock-type-face)
                                            ": "
                                            (cdr choice)))
                                  choices
                                  ", ")))))))
      (let ((result (assoc key choices)))
        (when result
          (let ((choice (cdr result)))
            (cond
             ((region-active-p)
              (let ((start (region-beginning))
                    (end (region-end)))
                (goto-char end)
                (insert "#+END_" choice "\n")
                (goto-char start)
                (insert "#+BEGIN_" choice "\n")))
             (t
              (insert "#+BEGIN_" choice "\n")
              (save-excursion (insert "#+END_" choice))))))))))

#+end_src
**** Copy formatted org-mode text to rtf
Via the always resourceful [[http://kitchingroup.cheme.cmu.edu/blog/2016/06/16/Copy-formatted-org-mode-text-from-Emacs-to-other-applications/][John Kitchin]].
#+BEGIN_SRC emacs-lisp
  (defun formatted-copy ()
  "Export region to HTML, and copy it to the clipboard."
  (interactive)
  (save-window-excursion
    (let* ((buf (org-export-to-buffer 'html "*Formatted Copy*" nil nil t t))
           (html (with-current-buffer buf (buffer-string))))
      (with-current-buffer buf
        (shell-command-on-region
         (point-min)
         (point-max)
         "textutil -stdin -format html -convert rtf -stdout | pbcopy")) 
      (kill-buffer buf))))

(global-set-key (kbd "H-w") 'formatted-copy)

#+END_SRC
**** Don't export Org-mode headlines
#+BEGIN_SRC emacs-lisp
  (defun org-remove-headlines (backend)
  "Remove headlines with :no_title: tag."
  (org-map-entries (lambda () (let ((beg (point)))
                                (outline-next-visible-heading 1)
                                (backward-char)
                                (delete-region beg (point))))
                   "no_export" tree)
  (org-map-entries (lambda () (delete-region (point-at-bol) (point-at-eol)))
                   "no_title"))

  ;; the following isn't currently working with org-mode 9
  ;; (add-hook 'org-export-before-processing-hook #'org-remove-headlines)
#+END_SRC
**** Move File
#+BEGIN_SRC emacs-lisp
(defun move-file ()
  "Write this file to a new location, and delete the old one."
  (interactive)
  (let ((old-location (buffer-file-name)))
    (call-interactively #'write-file)
    (when old-location
      (delete-file old-location))))
#+END_SRC
**** Pandoc conversion from clipboard
#+BEGIN_SRC emacs-lisp
  (defun cpm/org-to-markdown ()
    "convert clipboard contents from org to markdown and paste"
    (interactive)
    (kill-new (shell-command-to-string "osascript -e 'the clipboard as unicode text' | pandoc -f org -t markdown --atx-headers"))
    (yank))

  (defun cpm/markdown-to-org ()
    "convert clipboard contents from markdown to org and paste"
    (interactive)
    (kill-new (shell-command-to-string "osascript -e 'the clipboard as unicode text' | pandoc -f markdown -t org"))
    (yank))

  (defun cpm/tex-to-org ()
    "convert clipboard contents from markdown to org and paste"
    (interactive)
    (kill-new (shell-command-to-string "osascript -e 'the clipboard as unicode text' | pandoc -f latex -t org --atx-headers"))
    (yank))

  (defun cpm/tex-to-markdown ()
    "convert clipboard contents from markdown to org and paste"
    (interactive)
    (kill-new (shell-command-to-string "osascript -e 'the clipboard as unicode text' | pandoc -f latex -t markdown --atx-headers"))
    (yank))
    
  (defun cpm/markdown-to-tex ()
    "convert clipboard contents from markdown to org and paste"
    (interactive)
    (kill-new (shell-command-to-string "osascript -e 'the clipboard as unicode text' | pandoc -f markdown -t latex"))
    (yank))

  (defun cpm/cite-to-org ()
    "convert clipboard contents from markdown to org with citations and paste"
    (interactive)
    (kill-new (shell-command-to-string "osascript -e 'the clipboard as unicode text' | pandoc --bibliography=/Users/Roambot/Dropbox/Work/Master.bib -s -t markdown-native_divs-raw_html-citations | pandoc -f markdown -t org"))
    (yank))

  (defun cpm/cite-to-markdown ()
    "convert clipboard contents to markdown with citations and paste"
    (interactive)
    (kill-new (shell-command-to-string "osascript -e 'the clipboard as unicode text' | pandoc --bibliography=/Users/Roambot/Dropbox/Work/Master.bib -s -t markdown-native_divs-raw_html-citations --atx-headers"))
    (yank))


#+END_SRC
**** Resume last search
#+BEGIN_SRC emacs-lisp
  (defun last-search-buffer ()
        "open last helm-ag or hgrep buffer."
        (interactive)
        (cond ((get-buffer "*helm ag results*")
               (switch-to-buffer-other-window "*helm ag results*"))
              ((get-buffer "*helm-ag*")
               (helm-resume "*helm-ag*"))
              ((get-buffer "*hgrep*")
               (switch-to-buffer-other-window "*hgrep*"))
              (t
               (message "No previous search buffer found"))))
#+END_SRC
**** Toggle Window Split
Move from a horizontal to a vertical split and vice versa
#+BEGIN_SRC emacs-lisp
(defun toggle-window-split ()
  (interactive)
  (if (= (count-windows) 2)
      (let* ((this-win-buffer (window-buffer))
         (next-win-buffer (window-buffer (next-window)))
         (this-win-edges (window-edges (selected-window)))
         (next-win-edges (window-edges (next-window)))
         (this-win-2nd (not (and (<= (car this-win-edges)
                     (car next-win-edges))
                     (<= (cadr this-win-edges)
                     (cadr next-win-edges)))))
         (splitter
          (if (= (car this-win-edges)
             (car (window-edges (next-window))))
          'split-window-horizontally
        'split-window-vertically)))
    (delete-other-windows)
    (let ((first-win (selected-window)))
      (funcall splitter)
      (if this-win-2nd (other-window 1))
      (set-window-buffer (selected-window) this-win-buffer)
      (set-window-buffer (next-window) next-win-buffer)
      (select-window first-win)
      (if this-win-2nd (other-window 1))))))

#+END_SRC
**** Rotate windows
#+BEGIN_SRC emacs-lisp
;; from magnars modified by ffevotte for dedicated windows support
(defun rotate-windows (count)
  "Rotate your windows.
Dedicated windows are left untouched. Giving a negative prefix
argument takes the kindows rotate backwards."
  (interactive "p")
  (let* ((non-dedicated-windows (remove-if 'window-dedicated-p (window-list)))
         (num-windows (length non-dedicated-windows))
         (i 0)
         (step (+ num-windows count)))
    (cond ((not (> num-windows 1))
           (message "You can't rotate a single window!"))
          (t
           (dotimes (counter (- num-windows 1))
             (let* ((next-i (% (+ step i) num-windows))

                    (w1 (elt non-dedicated-windows i))
                    (w2 (elt non-dedicated-windows next-i))

                    (b1 (window-buffer w1))
                    (b2 (window-buffer w2))

                    (s1 (window-start w1))
                    (s2 (window-start w2)))
               (set-window-buffer w1 b2)
               (set-window-buffer w2 b1)
               (set-window-start w1 s2)
               (set-window-start w2 s1)
               (setq i next-i)))))))

(defun rotate-windows-backward (count)
  "Rotate your windows backward."
  (interactive "p")
  (rotate-windows (* -1 count)))
#+END_SRC
**** Swap windows
Swap buffers in windows and leave the cursor in the original window.
Courtesy of Mike Zamansky's [[http://cestlaz.github.io/posts/using-emacs-36-touch-of-elisp/#.WX5Wg0czpcx][video]].
#+BEGIN_SRC emacs-lisp
(defun cpm/window-exchange ()
"Swap buffer windows and leave focus in original window"
(interactive)
(ace-swap-window)
(aw-flip-window)
)
#+END_SRC 
**** Open projects directory
#+BEGIN_SRC emacs-lisp
  (defun goto-projects ()
      "Open projects dir"
      (interactive)
      (require 'ranger)
      (find-file "~/Dropbox/Work/projects"))

#+END_SRC
**** Reveal in Finder
#+BEGIN_SRC emacs-lisp
(defun browse-file-directory ()
  "Open the current file's directory however the OS would."
  (interactive)
  (if default-directory
      (browse-url-of-file (expand-file-name default-directory))
    (error "No `default-directory' to open")))
#+END_SRC
**** Search directories with ag
#+BEGIN_SRC emacs-lisp
(defun cpm/helm-files-do-ag (&optional dir)
  "Search in files with `ag' using a default input."
    (interactive)
    (helm-do-ag dir))
        
(defun cpm/helm-files-search-current-directory ()
  "search in files with `ag' in current buffer's directory"
    (interactive)
    (helm-do-ag (file-name-directory buffer-file-name)))
#+END_SRC
**** Sticky Buffer/Window
Stick/Lock buffer to window, courtesy of [[https://gist.github.com/ShingoFukuyama/8797743][ShingoFukuyama]].
#+BEGIN_SRC emacs-lisp
;; http://lists.gnu.org/archive/html/help-gnu-emacs/2007-05/msg00975.html

(defvar sticky-buffer-previous-header-line-format)
(define-minor-mode sticky-buffer-mode
  "Make the current window always display this buffer."
  nil " sticky" nil
  (if sticky-buffer-mode
      (progn
        (set (make-local-variable 'sticky-buffer-previous-header-line-format)
             header-line-format)
        (set-window-dedicated-p (selected-window) sticky-buffer-mode))
    (set-window-dedicated-p (selected-window) sticky-buffer-mode)
    (setq header-line-format sticky-buffer-previous-header-line-format)))
#+END_SRC
**** Jump in buffer
I got this from the [[https://github.com/syl20bnr/spacemacs/blob/5f26b82e1abdde81cdf7cd17ba06f64db2343667/layers/%2Bdistribution/spacemacs-base/funcs.el][spacemacs config]]. Useful for navigating in tagged buffers. 
#+BEGIN_SRC emacs-lisp
(defun jump-in-buffer ()
  (interactive)
  (cond
   ((eq major-mode 'org-mode)
    (call-interactively 'counsel-org-goto))
   (t
    (call-interactively 'helm-semantic-or-imenu))))
#+END_SRC
**** Jump to sexp
#+BEGIN_SRC emacs-lisp
(defun forward-or-backward-sexp (&optional arg)
  "Go to the matching parenthesis character if one is adjacent to point."
  (interactive "^p")
  (cond ((looking-at "\\s(") (forward-sexp arg))
        ((looking-back "\\s)" 1) (backward-sexp arg))
        ;; Now, try to succeed from inside of a bracket
        ((looking-at "\\s)") (forward-char) (backward-sexp arg))
        ((looking-back "\\s(" 1) (backward-char) (forward-sexp arg))))
#+END_SRC
**** Goto journal 
#+BEGIN_SRC emacs-lisp
  (defun goto-journal ()
    (interactive)
    (find-file "/Users/Roambot/Dropbox/org-files/journal.org"))
#+END_SRC
**** Eval emacs buffer until error
#+BEGIN_SRC emacs-lisp
  (defun eval-buffer-until-error ()
  "Evaluate emacs buffer until error occured."
  (interactive)
  (goto-char (point-min))
  (while t (eval (read (current-buffer)))))
#+END_SRC
**** Reveal to PDF
#+BEGIN_SRC emacs-lisp
  (defun reveal-to-pdf ()
  "print reveal.js slides to pdf"
  (interactive)
  (async-shell-command "phantomjs /Users/Roambot/bin/print-pdf.js 'file:///Users/Roambot/projects/phil101/content/slides/lecture_outline.html?print-pdf'")) 
#+END_SRC
**** Org Tree to File
Send an org tree to its own file. Inspiration from [[https://superuser.com/a/659823][this]] superuser answer.
#+begin_src emacs-lisp
(defun subtree-to-new-file ()
  (interactive)
  "Move an org subtree to a new file"
  (org-copy-subtree nil t)
  (find-file-other-window  
    (read-file-name "Move subtree to file:" "$HOME"))
(org-paste-subtree))
#+end_src
**** Fill/Unfill Paragraphs
Artur Malabarba has a [[http://endlessparentheses.com/fill-and-unfill-paragraphs-with-a-single-key.html][useful discussion]] of how to fill/unfill
paragraphs with the same command.
#+BEGIN_SRC emacs-lisp
(defun endless/fill-or-unfill ()
  "Like `fill-paragraph', but unfill if used twice."
  (interactive)
  (let ((fill-column
         (if (eq last-command 'endless/fill-or-unfill)
             (progn (setq this-command nil)
                    (point-max))
           fill-column)))
    (call-interactively #'fill-paragraph)))

(global-set-key [remap fill-paragraph]
                #'endless/fill-or-unfill)
#+END_SRC
**** Other functions
Most of these are from the [[https://github.com/syl20bnr/spacemacs][spacemacs]] distribution.
#+BEGIN_SRC emacs-lisp
  ;; Regexp for useful and useless buffers for smarter buffer switching, from spacemacs

  (defvar spacemacs-useless-buffers-regexp '("*\.\+")
    "Regexp used to determine if a buffer is not useful.")
  (defvar spacemacs-useful-buffers-regexp '("\\*\\(scratch\\|terminal\.\+\\|ansi-term\\|eshell\\)\\*")
    "Regexp used to define buffers that are useful despite matching
  `spacemacs-useless-buffers-regexp'.")

  (defun spacemacs/useless-buffer-p (buffer)
    "Determines if a buffer is useful."
    (let ((buf-paren-major-mode (get (with-current-buffer buffer
                                       major-mode)
                                     'derived-mode-parent))
          (buf-name (buffer-name buffer)))
      ;; first find if useful buffer exists, if so returns nil and don't check for
      ;; useless buffers. If no useful buffer is found, check for useless buffers.
      (unless (cl-loop for regexp in spacemacs-useful-buffers-regexp do
                       (when (or (eq buf-paren-major-mode 'comint-mode)
                                 (string-match regexp buf-name))
                         (return t)))
        (cl-loop for regexp in spacemacs-useless-buffers-regexp do
                 (when (string-match regexp buf-name)
                   (return t))))))

  (defun spacemacs/next-useful-buffer ()
    "Switch to the next buffer and avoid special buffers."
    (interactive)
    (let ((start-buffer (current-buffer)))
      (next-buffer)
      (while (and (spacemacs/useless-buffer-p (current-buffer))
                  (not (eq (current-buffer) start-buffer)))
        (next-buffer))))

  (defun spacemacs/previous-useful-buffer ()
    "Switch to the previous buffer and avoid special buffers."
    (interactive)
    (let ((start-buffer (current-buffer)))
      (previous-buffer)
      (while (and (spacemacs/useless-buffer-p (current-buffer))
                  (not (eq (current-buffer) start-buffer)))
        (previous-buffer))))

  ;; from magnars
  (defun spacemacs/rename-current-buffer-file ()
    "Renames current buffer and file it is visiting."
    (interactive)
    (let ((name (buffer-name))
          (filename (buffer-file-name)))
      (if (not (and filename (file-exists-p filename)))
          (error "Buffer '%s' is not visiting a file!" name)
        (let ((new-name (read-file-name "New name: " filename)))
          (cond ((get-buffer new-name)
                 (error "A buffer named '%s' already exists!" new-name))
                (t
                 (let ((dir (file-name-directory new-name)))
                   (when (and (not (file-exists-p dir)) (yes-or-no-p (format "Create directory '%s'?" dir)))
                     (make-directory dir t)))
                 (rename-file filename new-name 1)
                 (rename-buffer new-name)
                 (set-visited-file-name new-name)
                 (set-buffer-modified-p nil)
                 (when (fboundp 'recentf-add-file)
                     (recentf-add-file new-name)
                     (recentf-remove-if-non-kept filename))
                 (message "File '%s' successfully renamed to '%s'" name (file-name-nondirectory new-name))))))))

  ;; from magnars
  (defun spacemacs/delete-current-buffer-file ()
    "Removes file connected to current buffer and kills buffer."
    (interactive)
    (let ((filename (buffer-file-name))
          (buffer (current-buffer))
          (name (buffer-name)))
      (if (not (and filename (file-exists-p filename)))
          (ido-kill-buffer)
        (when (yes-or-no-p "Are you sure you want to delete this file? ")
          (delete-file filename t)
          (kill-buffer buffer)
          (message "File '%s' successfully removed" filename)))))
        
  ;; http://camdez.com/blog/2013/11/14/emacs-show-buffer-file-name/
  (defun spacemacs/show-and-copy-buffer-filename ()
    "Show the full path to the current file in the minibuffer."
    (interactive)
    (let ((file-name (buffer-file-name)))
      (if file-name
          (progn
            (message file-name)
            (kill-new file-name))
        (error "Buffer not visiting a file"))))

  (defun spacemacs/new-empty-buffer ()
    "Create a new buffer called untitled(<n>)"
    (interactive)
    (let ((newbuf (generate-new-buffer-name "untitled")))
      (switch-to-buffer newbuf)))

  ;; from https://github.com/gempesaw/dotemacs/blob/emacs/dg-defun.el
  (defun spacemacs/kill-matching-buffers-rudely (regexp &optional internal-too)
    "Kill buffers whose name matches the specified REGEXP. This
  function, unlike the built-in `kill-matching-buffers` does so
  WITHOUT ASKING. The optional second argument indicates whether to
  kill internal buffers too."
    (interactive "sKill buffers matching this regular expression: \nP")
    (dolist (buffer (buffer-list))
      (let ((name (buffer-name buffer)))
        (when (and name (not (string-equal name ""))
                   (or internal-too (/= (aref name 0) ?\s))
                   (string-match regexp name))
          (kill-buffer buffer)))))

  ;; http://stackoverflow.com/a/10216338/4869
  (defun spacemacs/copy-whole-buffer-to-clipboard ()
    "Copy entire buffer to clipboard"
    (interactive)
    (clipboard-kill-ring-save (point-min) (point-max)))

  (defun spacemacs/copy-clipboard-to-whole-buffer ()
    "Copy clipboard and replace buffer"
    (interactive)
    (delete-region (point-min) (point-max))
    (clipboard-yank)
    (deactivate-mark))

  (defun spacemacs/copy-file ()
    "Write the file under new name."
    (interactive)
    (call-interactively 'write-file))
#+END_SRC
*** CMACS Functions
**** File Functions

#+BEGIN_SRC emacs-lisp
  (defun cmacs/copy-file ()
    "Write the file under new name."
    (interactive)
    (call-interactively 'write-file))

  (defun cmacs/rename-file (filename &optional new-filename)
    "Rename FILENAME to NEW-FILENAME.

  When NEW-FILENAME is not specified, asks user for a new name.

  Also renames associated buffer (if any exists), invalidates
  projectile cache when it's possible and update recentf list."
    (interactive "f")
    (when (and filename (file-exists-p filename))
      (let* ((buffer (find-buffer-visiting filename))
             (short-name (file-name-nondirectory filename))
             (new-name (if new-filename new-filename
                         (read-file-name
                          (format "Rename %s to: " short-name)))))
        (cond ((get-buffer new-name)
               (error "A buffer named '%s' already exists!" new-name))
              (t
               (let ((dir (file-name-directory new-name)))
                 (when (and (not (file-exists-p dir)) (yes-or-no-p (format "Create directory '%s'?" dir)))
                   (make-directory dir t)))
               (rename-file filename new-name 1)
               (when buffer
                 (kill-buffer buffer)
                 (find-file new-name))
               (when (fboundp 'recentf-add-file)
                 (recentf-add-file new-name)
                 (recentf-remove-if-non-kept filename))
               (when (projectile-project-p)
                 (call-interactively #'projectile-invalidate-cache))
               (message "File '%s' successfully renamed to '%s'" short-name (file-name-nondirectory new-name)))))))

  (defun cmacs/rename-current-buffer-file ()
    "Renames current buffer and file it is visiting."
    (interactive)
    (let* ((name (buffer-name))
          (filename (buffer-file-name)))
      (if (not (and filename (file-exists-p filename)))
          (error "Buffer '%s' is not visiting a file!" name)
        (let* ((dir (file-name-directory filename))
               (new-name (read-file-name "New name: " dir)))
          (cond ((get-buffer new-name)
                 (error "A buffer named '%s' already exists!" new-name))
                (t
                 (let ((dir (file-name-directory new-name)))
                   (when (and (not (file-exists-p dir)) (yes-or-no-p (format "Create directory '%s'?" dir)))
                     (make-directory dir t)))
                 (rename-file filename new-name 1)
                 (rename-buffer new-name)
                 (set-visited-file-name new-name)
                 (set-buffer-modified-p nil)
                 (when (fboundp 'recentf-add-file)
                     (recentf-add-file new-name)
                     (recentf-remove-if-non-kept filename))
                 (when (projectile-project-p)
                   (call-interactively #'projectile-invalidate-cache))
                 (message "File '%s' successfully renamed to '%s'" name (file-name-nondirectory new-name))))))))

  (defun cmacs/delete-file (filename &optional ask-user)
    "Remove specified file or directory.

  Also kills associated buffer (if any exists) and invalidates
  projectile cache when it's possible.

  When ASK-USER is non-nil, user will be asked to confirm file
  removal."
    (interactive "f")
    (when (and filename (file-exists-p filename))
      (let ((buffer (find-buffer-visiting filename)))
        (when buffer
          (kill-buffer buffer)))
      (when (or (not ask-user)
                (yes-or-no-p "Are you sure you want to delete this file? "))
        (delete-file filename)
        (when (projectile-project-p)
          (call-interactively #'projectile-invalidate-cache)))))

  (defun cmacs/delete-file-confirm (filename)
    "Remove specified file or directory after users approval.

  FILENAME is deleted using `cmacs/delete-file' function.."
    (interactive "f")
    (funcall-interactively #'cmacs/delete-file filename t))

  (defun cmacs/delete-current-buffer-file ()
    "Removes file connected to current buffer and kills buffer."
    (interactive)
    (let ((filename (buffer-file-name))
          (buffer (current-buffer))
          (name (buffer-name)))
      (if (not (and filename (file-exists-p filename)))
          (ido-kill-buffer)
        (when (yes-or-no-p "Are you sure you want to delete this file? ")
          (delete-file filename t)
          (kill-buffer buffer)
          (when (projectile-project-p)
            (call-interactively #'projectile-invalidate-cache))
          (message "File '%s' successfully removed" filename)))))

  ;; TODO: properly handle ssh hostnames formatted user@host
  (defun cmacs/sudo-edit (&optional arg)
    (interactive "P")
    (let ((fname (if (or arg (not buffer-file-name))
                     (read-file-name "File: ")
                   buffer-file-name)))
      (find-file
       (cond ((string-match-p "^/ssh:" fname)
              (with-temp-buffer
                (insert fname)
                (search-backward ":")
                (let ((last-match-end nil)
                      (last-ssh-hostname nil))
                  (while (string-match "ssh:\\\([^:|]+\\\)" fname last-match-end)
                    (setq last-ssh-hostname (or (match-string 1 fname)
                                                last-ssh-hostname))
                    (setq last-match-end (match-end 0)))
                  (insert (format "|sudo:%s" (or last-ssh-hostname "localhost"))))
                (buffer-string)))
             (t (concat "/sudo:root@localhost:" fname))))))

  (defun cmacs/show-and-copy-buffer-filename ()
    "Show and copy the full path to the current file in the minibuffer."
    (interactive)
    ;; list-buffers-directory is the variable set in dired buffers
    (let ((file-name (or (buffer-file-name) list-buffers-directory)))
      (if file-name
          (progn
            (kill-new file-name)
            (message file-name))
        (error "Buffer not visiting a file"))))

  (defun cmacs/alternate-buffer (&optional window)
    "Switch back and forth between current and last buffer in the
  current window."
    (interactive)
    (let ((current-buffer (window-buffer window))
          (buffer-predicate
           (frame-parameter (window-frame window) 'buffer-predicate)))
      ;; switch to first buffer previously shown in this window that matches
      ;; frame-parameter `buffer-predicate'
      (switch-to-buffer
       (or (cl-find-if (lambda (buffer)
                         (and (not (eq buffer current-buffer))
                              (or (null buffer-predicate)
                                  (funcall buffer-predicate buffer))))
                       (mapcar #'car (window-prev-buffers window)))
           ;; `other-buffer' honors `buffer-predicate' so no need to filter
           (other-buffer current-buffer t)))))

  (defun cmacs/toggle-fold ()
    (interactive)
    (save-excursion
      (end-of-line)
      (hs-toggle-hiding)))

  (defun cmacs/toggle-whitespace ()
    (interactive)
    (if (and (boundp 'whitespace-mode) whitespace-mode)
        (whitespace-mode -1)
      (whitespace-mode +1)))

  (defun cmacs/sudo-find-file (file)
    "Open a file as root."
    (interactive
     (list (read-file-name "Open as root: ")))
    (find-file (if (file-writable-p file)
                   file
                 (concat "/sudo:root@localhost:" file))))

  (defun cmacs/sudo-this-file ()
    "Open the current file as root."
    (interactive)
    (cmacs/sudo-find-file (file-truename buffer-file-name)))
#+END_SRC
**** Buffer Functions

#+BEGIN_SRC emacs-lisp
(defun cmacs/kill-buffer-and-windows (buffer)
  "Kill the buffer and delete all the windows it's displayed in."
  (dolist (window (get-buffer-window-list buffer))
    (unless (one-window-p t)
      (delete-window window)))
  (kill-buffer buffer))

(defun cmacs/kill-other-buffers (&optional persp-p)
  "Kill all other buffers (besides the current one).

If PROJECT-P (universal argument), kill only buffers that belong to the current
project."
  (interactive "P")
  (let ((buffers (if persp-p (persp-buffer-list) (buffer-list)))
        (current-buffer (current-buffer)))
    (dolist (buf buffers)
      (unless (eq buf current-buffer)
        (cmacs/kill-buffer-and-windows buf)))
    (when (called-interactively-p 'interactive)
      (message "Killed %s buffers" (length buffers)))))

 (defun cmacs//get-buffer-display-time (buffer)
   (with-current-buffer buffer
     (float-time buffer-display-time)))

 (defun cmacs/show-hide-popup-buffer (&optional select buffer-rx)
   (interactive)
   (let ((open-popup-buffers
           (if buffer-rx
             (seq-filter
               (lambda (buff)
                 (string-match buffer-rx (buffer-name buff)))
               (mapcar #'window-buffer (window-at-side-list)))
             (seq-filter
               (lambda (buff)
                 (seq-some
                   (lambda (buff-rx)
                     (string-match buff-rx (buffer-name buff)))
                   cmacs-popups))
               (mapcar #'window-buffer (window-at-side-list)))))
         (closed-popup-buffers
           (if buffer-rx
             (seq-filter
               (lambda (buff)
                 (string-match buffer-rx (buffer-name buff)))
               (buffer-list))
             (seq-filter
               (lambda (buff)
                 (seq-some
                   (lambda (buff-rx)
                     (string-match buff-rx (buffer-name buff)))
                   cmacs-popups))
               (buffer-list)))))
   (cond ((= 1 (length open-popup-buffers))
          (delete-window (get-buffer-window (car open-popup-buffers))))
         ((and (> 0 (length open-popup-buffers) (not select)))
           (delete-window
             (get-buffer-window
               (car
                 (sort
                   open-popup-buffers
                   #'(lambda (a b)
                     (> (cmacs//get-buffer-display-time a) (cmacs//get-buffer-display-time b))))))))
         ((> 0 (length open-popup-buffers))
           (ivy-read "Close popup: "
                 (mapcar #'buffer-name open-popup-buffers)
                 :action (lambda (x)
                           (delete-window (get-buffer-window x)))
                 :caller 'cmacs/show-hide-popup-buffer))
         ((seq-empty-p closed-popup-buffers)
          (message "No popup buffers found"))
         ((= 1 (length closed-popup-buffers))
          (pop-to-buffer (car closed-popup-buffers)))
         ((not select)
           (pop-to-buffer
             (car
               (sort
                 closed-popup-buffers
                 #'(lambda (a b)
                   (> (cmacs//get-buffer-display-time a) (cmacs//get-buffer-display-time b)))))))
         (t
          (ivy-read "Open popup: "
                 (mapcar #'buffer-name closed-popup-buffers)
                 :action (lambda (x)
                           (pop-to-buffer x))
                 :caller 'cmacs/show-hide-popup-buffer)))))

(defun cmacs/toggle-whitespace ()
  (interactive)
  (if (and (boundp 'whitespace-mode) whitespace-mode)
      (whitespace-mode -1)
    (whitespace-mode +1)))
#+END_SRC
**** Window Functions

#+BEGIN_SRC emacs-lisp
(defun cmacs/window-zoom ()
  "Maximize and isolate the current buffer. Activate again to undo this. If the
window changes before then, the undo expires."
  (interactive)
  (if (and (one-window-p)
           (assoc ?_ register-alist))
      (jump-to-register ?_)
    (window-configuration-to-register ?_)
    (delete-other-windows)))
#+END_SRC
**** Random Functions

#+BEGIN_SRC emacs-lisp
(defun cmacs/delete-git-index-lock ()
  "Deletes index.lock file for git project if it exists"
  (interactive)
  (let ((git-index-lock-file (concat (magit-git-dir) "index.lock")))
    (when (file-exists-p git-index-lock-file)
      (delete-file git-index-lock-file))))

(defun cmacs/ace-delete-window-dispatch ()
  "Invokes ace-delete window with aw-dispatch-always temporarily set to true"
  (interactive)
  (let ((aw-dispatch-always t))
    (call-interactively #'ace-delete-window)))

(defun cmacs/file-as-string (filePath)
  "Return filePath's file content."
  (with-temp-buffer
    (insert-file-contents filePath)
    (buffer-string)))

(defun cmacs/set-limit-fill-column ()
  (interactive)
  (let ((column (string-to-number
                 (read-string "Fill Column: "))))
    (when (> column 0)
      (setq-local fill-column 120)
      (visual-line-mode +1)
      (auto-fill-mode -1)
      (visual-fill-column-mode +1))))

(defun cmacs/set-limit-auto-fill-column ()
  (interactive)
  (let ((column (string-to-number
                 (read-string "Fill Column: "))))
    (when (> column 0)
      (setq-local fill-column column)
      (visual-line-mode +1)
      (auto-fill-mode +1)
      (visual-fill-column-mode +1))))

(defun cmacs/disable-all-fill-column ()
  (interactive)
  (visual-line-mode -1)
  (auto-fill-mode -1)
  (visual-fill-column-mode -1))
#+END_SRC
*** DOOM! Macros

A set of fantastic macros written by [[https://github.com/hlissner][hlissner]]. There won't be much
documentation around these because the comments for each macro does a great
job explaining their function. For more information you can also look at the
[[https://github.com/hlissner/doom-emacs/wiki][wiki]] and the [[https://github.com/hlissner/doom-emacs/wiki/Modules#macros][entry on macros]] in particular.
**** after!

#+BEGIN_SRC emacs-lisp
(defmacro after! (feature &rest forms)
  "A smart wrapper around `with-eval-after-load'. Supresses warnings during
compilation."
  (declare (indent defun) (debug t))
  `(,(if (or (not (bound-and-true-p byte-compile-current-file))
             (if (symbolp feature)
                 (require feature nil :no-error)
               (load feature :no-message :no-error)))
         #'progn
       #'with-no-warnings)
    (with-eval-after-load ',feature ,@forms)))
#+END_SRC
**** map!

 #+BEGIN_SRC emacs-lisp
 (eval-and-compile
   (defun cmacs-enlist (exp)
     "Return EXP wrapped in a list, or as-is if already a list."
     (if (listp exp) exp (list exp)))

   (defun doom-unquote (exp)
     "Return EXP unquoted."
     (while (memq (car-safe exp) '(quote function))
       (setq exp (cadr exp)))
     exp)

   (defvar cmacs-evil-state-alist
     '((?n . normal)
       (?v . visual)
       (?i . insert)
       (?e . emacs)
       (?o . operator)
       (?m . motion)
       (?r . replace))
     "A list of cons cells that map a letter to a evil state symbol.")

   ;; Register keywords for proper indentation (see `map!')
   (put ':after        'lisp-indent-function 'defun)
   (put ':desc         'lisp-indent-function 'defun)
   (put ':leader       'lisp-indent-function 'defun)
   (put ':local        'lisp-indent-function 'defun)
   (put ':localleader  'lisp-indent-function 'defun)
   (put ':map          'lisp-indent-function 'defun)
   (put ':map*         'lisp-indent-function 'defun)
   (put ':mode         'lisp-indent-function 'defun)
   (put ':prefix       'lisp-indent-function 'defun)
   (put ':textobj      'lisp-indent-function 'defun)
   (put ':unless       'lisp-indent-function 'defun)
   (put ':when         'lisp-indent-function 'defun)

 ;; specials
   (defvar cmacs--keymaps nil)
   (defvar cmacs--prefix  nil)
   (defvar cmacs--defer   nil)
   (defvar cmacs--local   nil)

 (defun cmacs--keybind-register (key desc &optional modes)
   "Register a description for KEY with `which-key' in MODES.

   KEYS should be a string in kbd format.
   DESC should be a string describing what KEY does.
   MODES should be a list of major mode symbols."
   (if modes
       (dolist (mode modes)
         (which-key-add-major-mode-key-based-replacements mode key desc))
     (which-key-add-key-based-replacements key desc)))

 (defun cmacs--keyword-to-states (keyword)
   "Convert a KEYWORD into a list of evil state symbols.

 For example, :nvi will map to (list 'normal 'visual 'insert). See
 `cmacs-evil-state-alist' to customize this."
   (cl-loop for l across (substring (symbol-name keyword) 1)
            if (cdr (assq l cmacs-evil-state-alist))
              collect it
            else
              do (error "not a valid state: %s" l)))

 (defmacro map! (&rest rest)
   "A nightmare of a key-binding macro that will use `evil-define-key*',
 `define-key', `local-set-key' and `global-set-key' depending on context and
 plist key flags (and whether evil is loaded or not). It was designed to make
 binding multiple keys more concise, like in vim.

 If evil isn't loaded, it will ignore evil-specific bindings.

 States
     :n  normal
     :v  visual
     :i  insert
     :e  emacs
     :o  operator
     :m  motion
     :r  replace

     These can be combined (order doesn't matter), e.g. :nvi will apply to
     normal, visual and insert mode. The state resets after the following
     key=>def pair.

     If states are omitted the keybind will be global.

     This can be customized with `cmacs-evil-state-alist'.

     :textobj is a special state that takes a key and two commands, one for the
     inner binding, another for the outer.

 Flags
     (:mode [MODE(s)] [...])    inner keybinds are applied to major MODE(s)
     (:map [KEYMAP(s)] [...])   inner keybinds are applied to KEYMAP(S)
     (:map* [KEYMAP(s)] [...])  same as :map, but deferred
     (:prefix [PREFIX] [...])   assign prefix to all inner keybindings
     (:after [FEATURE] [...])   apply keybinds when [FEATURE] loads
     (:local [...])             make bindings buffer local; incompatible with keymaps!

 Conditional keybinds
     (:when [CONDITION] [...])
     (:unless [CONDITION] [...])

 Example
     (map! :map magit-mode-map
           :m \"C-r\" 'do-something           ; assign C-r in motion state
           :nv \"q\" 'magit-mode-quit-window  ; assign to 'q' in normal and visual states
           \"C-x C-r\" 'a-global-keybind

           (:when IS-MAC
            :n \"M-s\" 'some-fn
            :i \"M-o\" (lambda (interactive) (message \"Hi\"))))"
   (let ((cmacs--keymaps cmacs--keymaps)
         (cmacs--prefix  cmacs--prefix)
         (cmacs--defer   cmacs--defer)
         (cmacs--local   cmacs--local)
         key def states forms desc modes)
     (while rest
       (setq key (pop rest))
       (cond
	;; it's a sub expr
	((listp key)
         (push (macroexpand `(map! ,@key)) forms))

	;; it's a flag
	((keywordp key)
         (cond ((eq key :leader)
		(push 'cmacs-leader-key rest)
		(setq key :prefix
                      desc "<leader>"))
               ((eq key :localleader)
		(push 'cmacs-localleader-key rest)
		(setq key :prefix
                      desc "<localleader>")))
         (pcase key
           (:when    (push `(if ,(pop rest)       ,(macroexpand `(map! ,@rest))) forms) (setq rest '()))
           (:unless  (push `(if (not ,(pop rest)) ,(macroexpand `(map! ,@rest))) forms) (setq rest '()))
           (:after   (push `(after! ,(pop rest)   ,(macroexpand `(map! ,@rest))) forms) (setq rest '()))
           (:desc    (setq desc (pop rest)))
           (:map*    (setq cmacs--defer t) (push :map rest))
           (:map
             (setq cmacs--keymaps (cmacs-enlist (pop rest))))
           (:mode
             (setq modes (cmacs-enlist (pop rest)))
             (unless cmacs--keymaps
               (setq cmacs--keymaps
                     (cl-loop for m in modes
                              collect (intern (format "%s-map" (symbol-name m)))))))
           (:textobj
             (let* ((key (pop rest))
                    (inner (pop rest))
                    (outer (pop rest)))
               (push (macroexpand `(map! (:map evil-inner-text-objects-map ,key ,inner)
                                         (:map evil-outer-text-objects-map ,key ,outer)))
                     forms)))
           (:prefix
             (let ((def (pop rest)))
               (setq cmacs--prefix `(vconcat ,cmacs--prefix (kbd ,def)))
               (when desc
                 (push `(cmacs--keybind-register ,(key-description (eval cmacs--prefix))
                                                 ,desc ',modes)
                       forms)
                 (setq desc nil))))
           (:local
            (setq cmacs--local t))
           (_ ; might be a state cmacs--prefix
            (setq states (cmacs--keyword-to-states key)))))

	;; It's a key-def pair
	((or (stringp key)
             (characterp key)
             (vectorp key)
             (symbolp key))
         (unwind-protect
             (catch 'skip
               (when (symbolp key)
                 (setq key `(kbd ,key)))
               (when (stringp key)
                 (setq key (kbd key)))
               (when cmacs--prefix
                 (setq key (append cmacs--prefix (list key))))
               (unless (> (length rest) 0)
                 (user-error "map! has no definition for %s key" key))
               (setq def (pop rest))
               (when desc
                 (push `(cmacs--keybind-register ,(key-description (eval key))
                                               ,desc ',modes)
                       forms))
               (cond ((and cmacs--local cmacs--keymaps)
                      (push `(lwarn 'cmacs-map :warning
                                    "Can't local bind '%s' key to a keymap; skipped"
                                    ,key)
                            forms)
                      (throw 'skip 'local))
                     ((and cmacs--keymaps states)
                      (dolist (keymap cmacs--keymaps)
			(push `(,(if cmacs--defer 'evil-define-key 'evil-define-key*)
				',states ,keymap ,key ,def)
                              forms)))
                     (states
                      (dolist (state states)
			(push `(define-key
                                 ,(intern (format "evil-%s-state-%smap" state (if cmacs--local "local-" "")))
                                 ,key ,def)
                              forms)))
                     (cmacs--keymaps
                      (dolist (keymap cmacs--keymaps)
			(push `(define-key ,keymap ,key ,def) forms)))
                     (t
                      (push `(,(if cmacs--local 'local-set-key 'global-set-key) ,key ,def)
                            forms))))
           (setq states '()
                 cmacs--local nil
                 desc nil)))

	(t (user-error "Invalid key %s" key))))
     `(progn ,@(nreverse forms)))))
 #+END_SRC
**** add-hook!
 A macro that makes adding hooks easy

 #+BEGIN_SRC emacs-lisp
 (eval-and-compile
   (defun cmacs--resolve-hook-forms (hooks)
     (cl-loop with quoted-p = (eq (car-safe hooks) 'quote)
              for hook in (cmacs-enlist (doom-unquote hooks))
              if (eq (car-safe hook) 'quote)
               collect (cadr hook)
              else if quoted-p
               collect hook
              else collect (intern (format "%s-hook" (symbol-name hook)))))

   (defvar cmacs--transient-counter 0)
   (defmacro add-transient-hook! (hook &rest forms)
     "Attaches transient forms to a HOOK.

   HOOK can be a quoted hook or a sharp-quoted function (which will be advised).

   These forms will be evaluated once when that function/hook is first invoked,
   then it detaches itself."
     (declare (indent 1))
     (let ((append (eq (car forms) :after))
           (fn (intern (format "cmacs-transient-hook-%s" (cl-incf cmacs--transient-counter)))))
       `(when ,hook
          (fset ',fn
		(lambda (&rest _)
                  ,@forms
                  (cond ((functionp ,hook) (advice-remove ,hook #',fn))
			((symbolp ,hook)   (remove-hook ,hook #',fn)))
                  (unintern ',fn nil)))
          (cond ((functionp ,hook)
                 (advice-add ,hook ,(if append :after :before) #',fn))
		((symbolp ,hook)
                 (add-hook ,hook #',fn ,append)))))))

 (defmacro add-hook! (&rest args)
   "A convenience macro for `add-hook'. Takes, in order:

   1. Optional properties :local and/or :append, which will make the hook
      buffer-local or append to the list of hooks (respectively),
   2. The hooks: either an unquoted major mode, an unquoted list of major-modes,
      a quoted hook variable or a quoted list of hook variables. If unquoted, the
      hooks will be resolved by appending -hook to each symbol.
   3. A function, list of functions, or body forms to be wrapped in a lambda.

 Examples:
     (add-hook! 'some-mode-hook 'enable-something)
     (add-hook! some-mode '(enable-something and-another))
     (add-hook! '(one-mode-hook second-mode-hook) 'enable-something)
     (add-hook! (one-mode second-mode) 'enable-something)
     (add-hook! :append (one-mode second-mode) 'enable-something)
     (add-hook! :local (one-mode second-mode) 'enable-something)
     (add-hook! (one-mode second-mode) (setq v 5) (setq a 2))
     (add-hook! :append :local (one-mode second-mode) (setq v 5) (setq a 2))

 Body forms can access the hook's arguments through the let-bound variable
 `args'."
   (declare (indent defun) (debug t))
   (let ((hook-fn 'add-hook)
         append-p local-p)
     (while (keywordp (car args))
       (pcase (pop args)
         (:append (setq append-p t))
         (:local  (setq local-p t))
         (:remove (setq hook-fn 'remove-hook))))
     (let ((hooks (cmacs--resolve-hook-forms (pop args)))
           (funcs
            (let ((val (car args)))
              (if (memq (car-safe val) '(quote function))
                  (if (cdr-safe (cadr val))
                      (cadr val)
                    (list (cadr val)))
		(list args))))
           forms)
       (dolist (fn funcs)
         (setq fn (if (symbolp fn)
                      `(function ,fn)
                    `(lambda (&rest _) ,@args)))
         (dolist (hook hooks)
           (push (cond ((eq hook-fn 'remove-hook)
			`(remove-hook ',hook ,fn ,local-p))
                       (t
			`(add-hook ',hook ,fn ,append-p ,local-p)))
                 forms)))
       `(progn ,@(nreverse forms)))))

 (defmacro remove-hook! (&rest args)
   "Convenience macro for `remove-hook'. Takes the same arguments as
 `add-hook!'."
   `(add-hook! :remove ,@args))
 #+END_SRC
**** quiet!
 A simple macro that prevents code from making any noise

 #+BEGIN_SRC emacs-lisp
 (defmacro quiet! (&rest forms)
   "Run FORMS without making any noise."
   `(if nil
	(progn ,@forms)
      (fset 'doom--old-write-region-fn (symbol-function 'write-region))
      (cl-letf ((standard-output (lambda (&rest _)))
		((symbol-function 'load-file) (lambda (file) (load file nil t)))
		((symbol-function 'message) (lambda (&rest _)))
		((symbol-function 'write-region)
                 (lambda (start end filename &optional append visit lockname mustbenew)
                   (unless visit (setq visit 'no-message))
                   (doom--old-write-region-fn
                    start end filename append visit lockname mustbenew)))
		(inhibit-message t)
		(save-silently t))
	,@forms)))
 #+END_SRC
**** def-memoized!
 Creates a memoized function

 #+BEGIN_SRC emacs-lisp
 (defvar doom-memoized-table (make-hash-table :test 'equal :size 10)
   "A lookup table containing memoized functions. The keys are argument lists,
 and the value is the function's return value.")

 (defun doom-memoize (name)
   "Memoizes an existing function. NAME is a symbol."
   (let ((func (symbol-function name)))
     (put name 'function-documentation
          (concat (documentation func) " (memoized)"))
     (fset name
           `(lambda (&rest args)
              (let ((key (cons ',name args)))
		(or (gethash key doom-memoized-table)
                    (puthash key (apply ',func args)
                             doom-memoized-table)))))))

 (defmacro def-memoized! (name arglist &rest body)
   "Create a memoize'd function. NAME, ARGLIST, DOCSTRING and BODY
 have the same meaning as in `defun'."
   (declare (indent defun) (doc-string 3))
   `(,(if (bound-and-true-p byte-compile-current-file)
          'with-no-warnings
	'progn)
      (defun ,name ,arglist ,@body)
      (doom-memoize ',name)))


 #+END_SRC
**** λ!

 #+BEGIN_SRC emacs-lisp
 (defmacro λ! (&rest body)
   "A shortcut for inline interactive lambdas."
   (declare (doc-string 1))
   `(lambda () (interactive) ,@body))

 #+END_SRC
*** Other Macros
#+BEGIN_SRC emacs-lisp

(defmacro find-file-in! (path &optional project-p)
  "Returns a interactive function for searching files"
  `(lambda () (interactive)
     (let ((default-directory ,path))
       (call-interactively
        ',(if project-p
              (command-remapping 'projectile-find-file)
            (command-remapping 'find-file))))))
#+END_SRC
** Useful Libraries

[[https://github.com/jwiegley/emacs-async][async]], [[https://github.com/magnars/s.el][s]], [[https://github.com/magnars/dash.el][dash]], and [[http://elpa.gnu.org/packages/cl-lib.html][cl-lib]] are libraries for asynchronous processing, string manipulation, list manipulation and backward compatibility respectively.

#+BEGIN_SRC emacs-lisp
(use-package async :demand t)
(use-package dash :demand t)
(use-package s :demand t)
(use-package f :demand t)
(use-package subr-x :demand t :ensure nil)
(require 'cl-lib)
#+END_SRC
** Modal Editing
*** General  (Evil)
A [[https://github.com/noctuid/general.el][convenient way]] to bind keys. Compatible with evil. For helpful
discussion of setting up evil with general see [[https://sam217pa.github.io/2016/09/02/how-to-build-your-own-spacemacs/][this post]].
#+BEGIN_SRC emacs-lisp
(use-package general
  :demand t
  :config
  (general-create-definer cpm-leader1 
    :states '(normal insert visual motion emacs) 
    :keymaps 'global 
    :prefix "SPC" 
    :non-normal-prefix "C-SPC"))
#+END_SRC
*** Vim Emulation
I'm coming from vim, and want modal keybidings in emacs. There are other, less
radical ways of getting modal editing in emacs. For example, [[https://github.com/mrkkrp/modalka][modalka]] is a nice
package for modal editing (see also [[https://github.com/Kungsgeten/ryo-modal][ryo-modal]]). But nothing beats full vim
keybindings. And that is what [[https://bitbucket.org/lyro/evil/wiki/Home][evil]] is for.
Install, automatically load, and enable evil. It's like vim, but better!
**** Evil Mode
#+BEGIN_SRC emacs-lisp
  (use-package evil
    :demand t
    :config
    (progn
    ;; Cursor shape and color
      (defcustom dotemacs-evil/emacs-cursor
      "red"
      "The color of the cursor when in Emacs state."
      :type 'color
      :group 'dotemacs-evil)

      (defcustom dotemacs-evil/emacs-insert-mode
      nil
      "If non-nil, insert mode will act as Emacs state."
      :type 'boolean
      :group 'dotemacs-evil)

      ;; move over visual lines like normal lines
      (map! (:map text-mode-map
             :nv "j"   #'evil-next-visual-line
             :nv "k"   #'evil-previous-visual-line))

      (setq evil-search-module 'evil-search)
      (setq evil-magic 'very-magic)
      ;; (setq evil-want-C-i-jump nil)
      (setq evil-emacs-state-cursor `(,dotemacs-evil/emacs-cursor box))
      (setq evil-normal-state-cursor '("DarkGoldenrod2" box))
      (setq evil-visual-state-cursor '("gray" box)) 
      (setq evil-insert-state-cursor '("chartreuse3" (bar . 2)))
      (setq evil-replace-state-cursor '("red" hbar))
      (setq evil-operator-state-cursor '("red" hollow))
      (setq evil-visual-state-tag "VISUAL")
      ;use insert in commits automatically 
      (add-hook 'git-commit-mode-hook 'evil-insert-state)
      (evil-set-initial-state 'messages-buffer-mode 'motion)
      (evil-set-initial-state 'magit-log-edit-mode 'insert)
      ;; evil-normal-state is preferred, so revert when idle
      (run-with-idle-timer 60 t 'evil-normal-state)
      ;; don't echo evil state
      (setq evil-echo-state nil)
      ;; evil everywhere
      (evil-mode 1)))
#+END_SRC
**** Evil Related Packages & Settings
There are some other useful setup packages for evil
***** Evil indent
#+BEGIN_SRC emacs-lisp
(use-package evil-indent-textobject :commands (evil-indent))
#+END_SRC
***** Change Cursor In Terminal
#+begin_src emacs-lisp
(defun my-send-string-to-terminal (string)
  (unless (display-graphic-p) (send-string-to-terminal string)))

(defun my-evil-terminal-cursor-change ()
  (when (string= (getenv "TERM_PROGRAM") "iTerm.app")
    (add-hook 'evil-insert-state-entry-hook (lambda () (my-send-string-to-terminal "\e]50;CursorShape=1\x7")))
    (add-hook 'evil-insert-state-exit-hook  (lambda () (my-send-string-to-terminal "\e]50;CursorShape=0\x7"))))
  (when (and (getenv "TMUX") (string= (getenv "TERM_PROGRAM") "iTerm.app"))
    (add-hook 'evil-insert-state-entry-hook (lambda () (my-send-string-to-terminal "\ePtmux;\e\e]50;CursorShape=1\x7\e\\")))
    (add-hook 'evil-insert-state-exit-hook  (lambda () (my-send-string-to-terminal "\ePtmux;\e\e]50;CursorShape=0\x7\e\\")))))

(add-hook 'after-make-frame-functions (lambda (frame) (my-evil-terminal-cursor-change)))
(my-evil-terminal-cursor-change)

  (use-package evil-terminal-cursor-changer
    :disabled t
    :defer t
    :init
     (unless (display-graphic-p)
             (require 'evil-terminal-cursor-changer)
    (progn 
     (setq evil-visual-state-cursor '("red" box)); █
     (setq evil-insert-state-cursor '("green" bar)); ⎸
     (setq evil-emacs-state-cursor '("blue" hbar)); _
     )))
#+end_src
***** Evil Surround Commands Like Vim-Surround
#+begin_src emacs-lisp
  (use-package evil-surround
    :commands (evil-surround-region evil-surround-change)
    :init 
    (general-define-key
    :states '(visual)
    "s" 'evil-surround-region
    "S" 'evil-substitute)
    :config (global-evil-surround-mode 1))

  (use-package embrace)
  (use-package evil-embrace
   :after evil-surround
   :config
   (evil-embrace-enable-evil-surround-integration)
   (setq evil-embrace-show-help-p nil)
   :init
   (add-hook 'org-mode-hook 'embrace-org-mode-hook)
   (add-hook 'text-mode-hook
      (lambda () 
          (embrace-add-pair ?* "*" "*")
          (embrace-add-pair ?$ "$" "$")))
   (add-hook 'LaTeX-mode-hook
      (lambda ()
          (embrace-add-pair ?a "`" "'")
          (embrace-add-pair ?e "\\emph{" "}"))))

#+end_src 
***** Commenting 
#+begin_src emacs-lisp
  (use-package evil-commentary
    :commands (evil-commentary evil-commentary-line)
    :diminish evil-commentary-mode
    :config
    (evil-commentary-mode))
#+end_src
***** Graphical undo
#+begin_src emacs-lisp
  (use-package undo-tree
    :commands (undo-tree-undo undo-tree-redo undo-tree-visualize)
    :init
    ;; (global-undo-tree-mode)
    (setq undo-tree-visualizer-timestamps t)
    (setq undo-tree-visualizer-diff t)
    (let ((undo-dir (concat cmacs-cache-dir "undo")))
      (setq undo-tree-history-directory-alist `(("." . ,undo-dir)))
      (unless (file-directory-p undo-dir)
        (make-directory undo-dir t)))
    (setq undo-tree-auto-save-history nil))
#+end_src
** Appearance & UI
   Various settings to make Emacs (mostly the GUI version) look better or
   make interaction smoother. 
*** Appearance
**** Frame startup size and position
 I like the frame either centered and approximately 2/3 of a 13inch
 laptop screen or maximized.
 #+BEGIN_SRC emacs-lisp
   ;; Set Frame width/height
   (add-to-list 'initial-frame-alist '(fullscreen . maximized))
   ;; (setq default-frame-alist
   ;;       '((top . 25) (left . 275) (width . 105) (height . 60)))
 #+END_SRC
**** Name frame
 Show the filepath in the frame title.
 #+BEGIN_SRC emacs-lisp
   (setq-default frame-title-format
             '((buffer-file-name "%f" "%b")))
 #+END_SRC
**** Get rid of UI cruft
 Turn off all of the GUI cruft.
 #+BEGIN_SRC emacs-lisp
   ;; Turn off mouse interface early in startup to avoid momentary display
   (when (display-graphic-p)
     (menu-bar-mode -1)
     (tool-bar-mode -1)
     (scroll-bar-mode -1)
     (tooltip-mode -1))
 #+END_SRC
**** No menu bar in terminal
 Ditto for the terminal.
 #+BEGIN_SRC emacs-lisp
   (when (not (display-graphic-p))
     (menu-bar-mode -1))
 #+END_SRC
**** Font Value
 Here we tell emacs to use the fonts set in the variables [[*Font][above]]. 
 #+BEGIN_SRC emacs-lisp
 (set-face-attribute 'default nil :font cmacs-font)
 (set-face-attribute 'variable-pitch nil :font cmacs-vari-font)
 #+END_SRC
**** Font Size
 #+BEGIN_SRC emacs-lisp
 ;; C-x C-0 restores the default font size
 (global-set-key (kbd "C-+") 'text-scale-increase)
 (global-set-key (kbd "C--") 'text-scale-decrease)
 #+END_SRC
**** Theme
***** Solarized
 The best low-contrast theme out there.
 #+BEGIN_SRC emacs-lisp
   (use-package solarized-theme
     :demand t
     :if (display-graphic-p)
     :init
       (progn
       (setq org-todo-keyword-faces
            '(("TODO" . org-warning) ("STARTED" . "yellow")
              ("WAITING" . (:foreground "blue" :weight bold))
              ("SUBMITTED-C" . "green") ("SUBMITTED-J" . "green")
              ("ACCEPTED-C" . "silver") ("ACCEPTED-J" . "silver")
              ("REVISE" . (:foreground "violet" :weight bold))))

           ;; don't make the fringe stand out from the background
           (setq solarized-distinct-fringe-background nil)

           ;; change the font for some headings and titles
           (setq solarized-use-variable-pitch t)

           ;; make the modeline high contrast
           (setq solarized-high-contrast-mode-line t)

           ;; Use bolding
           (setq solarized-use-less-bold nil)

           ;; Use more italics
           (setq solarized-use-more-italic t)

           ;; Use colors for indicators such as git:gutter, flycheck and similar
           (setq solarized-emphasize-indicators t)

           ;; Don't change size of org-mode headlines (but keep other size-changes)
           (setq solarized-scale-org-headlines t)

           ;; don't italicize line numbers
           ;; (add-hook 'after-make-frame-functions
           ;; (lambda (frame)
           ;; (select-frame frame)
           ;; (if (display-graphic-p)
           ;; (set-face-attribute 'linum frame
           ;; :background (face-attribute 'default :background)
           ;; :foreground (face-attribute 'linum :foreground) :slant 'normal))))

           ;; Theme toggle
           (setq active-theme 'solarized-dark)
           (defun toggle-dark-light-theme ()
           (interactive)
           (if (eq active-theme 'solarized-light)
               (setq active-theme 'solarized-dark)
             (setq active-theme 'solarized-light))
           (load-theme active-theme)
           (powerline-reset))
           )
           :config
            (progn
              (defvar after-load-theme-hook nil
		"Hook run after a color theme is loaded using `load-theme'.")
              (defadvice load-theme (after run-after-load-theme-hook activate)
		"Run `after-load-theme-hook'."
		(run-hooks 'after-load-theme-hook))
              (defun customize-solarized-dark ()
		"Customize solarized theme"
		(if (member 'solarized-dark custom-enabled-themes)
                    (custom-theme-set-faces
                    'solarized-dark
                    ;; org faces
                    '(org-block ((t (:foreground "#2E8B57"))))
                    '(org-block-begin-line ((t (:foreground "#74a8a4" :weight bold :slant normal))))
                    '(org-level-1 ((t (:inherit variable-pitch :foreground "#268bd2" :height 1.5))))
                    '(org-level-2 ((t (:inherit variable-pitch :foreground "medium sea green" :height 1.3))))
                    '(org-level-3 ((t (:inherit variable-pitch :foreground "#cb4b16" :height 1.2))))
                    '(org-level-8 ((t (:inherit variable-pitch :foreground "#9e1e86" :height 1.1))))
                    '(org-quote ((t (:inherit org-block :slant normal :weight normal))))
                    ;; markdown faces
                    '(markdown-comment-face ((t (:weight normal :slant italic :strike-through nil))))
                    '(markdown-header-face-1 ((t (:inherit variable-pitch :foreground "#268bd2" :height 1.75))))
                    '(markdown-header-face-2 ((t (:inherit variable-pitch :foreground "medium sea green" :height 1.45))))
                    '(markdown-header-face-3 ((t (:inherit variable-pitch :foreground "#cb4b16" :height 1.2))))
                    ;; helm faces
                    '(helm-selection ((t (:foreground "#f7f438" :background "#64b5ea" :underline nil :weight bold))))
                    ;; line highlighting 
                    '(line-number-current-line ((t (:inherit default :foreground "goldenrod1"))))
                    ;; '(nlinum-current-line ((t (:inherit default :foreground "goldenrod1"))))
                    '(linum-highlight-face ((t (:inherit default :foreground "goldenrod1"))))
                     ;; '(nlinum-hl-face ((t (:inherit default :foreground "goldenrod1"))))
                    ;; battery faces
                    '(fancy-battery-charging ((t (:foreground "dark blue" :weight bold))))
                    '(fancy-battery-critical ((t (:foreground "dark red" :weight bold))))
                    '(fancy-battery-discharging ((t (:foreground "dark magenta" :weight bold)))))))

             (add-hook 'after-load-theme-hook 'customize-solarized-dark)

             (defun customize-solarized-light ()
		"Customize solarized theme"
		(if (member 'solarized-light custom-enabled-themes)
                    (custom-theme-set-faces
                    'solarized-light
                    ;; org faces
                    '(org-block ((t (:foreground "#2E8B57"))))
                    '(org-block-begin-line ((t (:foreground "#74a8a4" :weight bold :slant normal))))
                    '(org-level-1 ((t (:inherit variable-pitch :foreground "#268bd2" :height 1.3))))
                    '(org-level-2 ((t (:inherit variable-pitch :foreground "medium sea green" :height 1.2))))
                    '(org-level-3 ((t (:inherit variable-pitch :foreground "#cb4b16" :height 1.15))))
                    '(org-level-8 ((t (:inherit variable-pitch :foreground "#9e1e86" :height 1.1))))
                    '(org-quote ((t (:inherit org-block :slant normal :weight normal))))
                    ;; markdown faces
                    '(markdown-comment-face ((t (:weight normal :slant italic :strike-through nil))))
                    '(markdown-header-face-1 ((t (:inherit variable-pitch :foreground "#268bd2" :height 1.75))))
                    '(markdown-header-face-2 ((t (:inherit variable-pitch :foreground "medium sea green" :height 1.45))))
                    '(markdown-header-face-3 ((t (:inherit variable-pitch :foreground "#cb4b16" :height 1.2))))

                    ;; helm faces
                    '(helm-selection ((t (:foreground "#f7f438" :background "#64b5ea" :underline nil :weight bold))))
                    ;; line size 
                    '(set-face-attribute 'linum nil :inherit 'fixed-pitch)
                    ;; line highlighting 
                    '(linum-highlight-face ((t (:inherit default :foreground "#002b36"))))
                    ;; '(nlinum-hl-face ((t (:inherit default :foreground "#002b36"))))
                    '(line-number-current-line ((t (:inherit default :foreground "#002b36"))))
                    ;; '(nlinum-current-line ((t (:inherit default :foreground "#002b36"))))
                    ;; battery faces
                    '(fancy-battery-charging ((t (:foreground "dark blue" :weight bold))))
                    '(fancy-battery-critical ((t (:foreground "dark red" :weight bold))))
                    '(fancy-battery-discharging ((t (:foreground "dark magenta" :weight bold)))))))

             (add-hook 'after-load-theme-hook 'customize-solarized-light)
             )
             (load-theme 'solarized-dark t)
             )

           ;; Avoid all font-size changes
           ;; (setq solarized-height-minus-1 1)
           ;; (setq solarized-height-plus-1 1)
           ;; (setq solarized-height-plus-2 1)
           ;; (setq solarized-height-plus-3 1)
           ;; (setq solarized-height-plus-4 1))

 #+END_SRC
***** Gruvbox
 This is a great general-purpose theme. Use it in terminal.

 #+BEGIN_SRC emacs-lisp
 (use-package gruvbox-theme
   :ensure t 
   :if (not (display-graphic-p))
   :config
   (load-theme 'gruvbox t)
   )
 #+END_SRC 
***** Zerodark
 Nice [[https://github.com/NicolasPetton/zerodark-theme][dark theme]] with custom modeline
 #+BEGIN_SRC emacs-lisp
   (use-package zerodark-theme
     :if (display-graphic-p)
     :config
     (custom-set-faces
       '(org-block-begin-line ((t (:background "#282c34" :foreground "#98be65" :height 0.9))))
       '(org-block-end-line ((t (:background "#282c34" :foreground "#98be65" :height 0.9)))))
     (load-theme 'zerodark t)
     (zerodark-setup-modeline-format)
     )
 #+END_SRC
***** Circadian Theme-changer (based on time of day)
[[https://github.com/guidoschmidt/circadian.el][Change your theme]] depending on location and time of day
#+BEGIN_SRC emacs-lisp 
(use-package circadian
  :if (display-graphic-p)
  :defer 1
  :config
  (ignore-errors
  (setq circadian-themes '((:sunrise . gruvbox-light-soft)
                           ("11:00"  . solarized-light)
                           ("14:30"  . adwaita)
                           (:sunset  . solarized-dark)))
  (circadian-setup)))
#+END_SRC

**** Modeline
***** Spaceline All The Icons
[[https://github.com/domtronn/spaceline-all-the-icons.el][Pretty icons]] for [[https://github.com/TheBB/spaceline][spaceline]] using [[https://github.com/domtronn/all-the-icons.el][all-the-icons.el]]. This is a nice
package but still a bit buggy. Also adds a couple seconds to the load
time. 
#+BEGIN_SRC emacs-lisp
  ;; Mode line
  (use-package spaceline
    :demand t
    :init 
    (setq spaceline-highlight-face-func 'spaceline-highlight-face-evil-state)
    :config 
    (require 'spaceline-config)
    (setq powerline-image-apple-rgb t)
    ;; use simple config in terminal
    (if (not (display-graphic-p))
      (spaceline-spacemacs-theme)
      (spaceline-toggle-line-column-off)
      ))

  (use-package spaceline-all-the-icons 
    :after spaceline
    :if (display-graphic-p)  ;; no icons in terminal
    :config (spaceline-all-the-icons-theme)
    ;; Configuration
    (setq spaceline-responsive nil)
    (spaceline-all-the-icons--setup-anzu) ;; Enable anzu search
    (spaceline-all-the-icons--setup-neotree) ;; Enable Neotree mode line
    (setq powerline-text-scale-factor 1)
    (setq spaceline-all-the-icons-separator-scale 1.75)
    (setq spaceline-all-the-icons-separator-type 'arrow
          spaceline-all-the-icons-icon-set-modified 'circle
          spaceline-all-the-icons-icon-set-window-numbering 'solid
          spaceline-all-the-icons-icon-set-eyebrowse-slot 'square
          spaceline-all-the-icons-primary-separator "|"
          spaceline-all-the-icons-secondary-separator " ")
     ;; Toggles
     (spaceline-toggle-all-the-icons-time-on)
     (spaceline-toggle-all-the-icons-battery-status-off)
     (spaceline-toggle-all-the-icons-buffer-size-off)
     (spaceline-toggle-all-the-icons-buffer-position-on)
     (spaceline-toggle-all-the-icons-hud-on)
     (spaceline-toggle-all-the-icons-buffer-path-on)
     (spaceline-toggle-all-the-icons-narrowed-on)
     (spaceline-toggle-all-the-icons-flycheck-status-off)
     (spaceline-toggle-all-the-icons-vc-icon-off)
     (spaceline-toggle-all-the-icons-vc-status-on)
     (spaceline-toggle-all-the-icons-git-status-off)
     (spaceline-toggle-all-the-icons-position-on)
  )
#+END_SRC


***** DISABLED Spaceline 
#+BEGIN_SRC emacs-lisp :tangle no
  (use-package spaceline
    :demand t
    :init 
    (setq spaceline-highlight-face-func 'spaceline-highlight-face-evil-state)
    (setq-default powerline-default-separator 'slant) 
    (setq spaceline-separator-dir-left '(right . right))
    (setq spaceline-separator-dir-right '(right . right))
    ;; fancy git icon for the modeline
    (defadvice vc-mode-line (after strip-backend () activate)
      (when (stringp vc-mode)
        (let ((gitlogo (replace-regexp-in-string "^ Git." ":" vc-mode)))
              (setq vc-mode gitlogo))))
    :config
    (require 'spaceline-config)
    (setq powerline-image-apple-rgb t)
    (spaceline-toggle-buffer-size-off)
    (spaceline-spacemacs-theme)
    (setq spaceline-buffer-encoding-abbrev-p nil
          spaceline-window-numbers-unicode t
          spaceline-line-column-p nil
          spaceline-buffer-id-p nil
          spaceline-minor-modes-separator nil))
#+END_SRC
***** DISABLED Telephone line
#+BEGIN_SRC emacs-lisp :tangle no
(use-package telephone-line
  :demand t
  :config
  (setq telephone-line-primary-left-separator  'telephone-line-flat
      telephone-line-primary-right-separator   'telephone-line-flat
      telephone-line-secondary-left-separator  'telephone-line-flat
      telephone-line-secondary-right-separator 'telephone-line-flat)
  (require 'telephone-line-config)
  (telephone-line-evil-config)) 
#+END_SRC
***** Hide mode line
 Hide mode line. From http://bzg.fr/emacs-hide-mode-line.html

 #+BEGIN_SRC emacs-lisp
 (defvar-local hidden-mode-line-mode nil)
 (defvar-local hide-mode-line nil)
 (define-minor-mode hidden-mode-line-mode
   "Minor mode to hide the mode-line in the current buffer."
   :init-value nil
   :global t
   :variable hidden-mode-line-mode
   :group 'editing-basics
   (if hidden-mode-line-mode
       (setq hide-mode-line mode-line-format
             mode-line-format nil)
     (setq mode-line-format hide-mode-line
           hide-mode-line nil))
   (force-mode-line-update)
   ;; Apparently force-mode-line-update is not always enough to
   ;; redisplay the mode-line
   (redraw-display)
   (when (and (called-interactively-p 'interactive)
              hidden-mode-line-mode)
     (run-with-idle-timer
      0 nil 'message
      (concat "Hidden Mode Line Mode enabled.  "
              "Use M-x hidden-mode-line-mode to make the mode-line appear."))))

 #+END_SRC
**** FIXME  Line Numbers (Nlinum mode for emacs 25)
 #+BEGIN_SRC emacs-lisp
  (use-package nlinum
  :commands nlinum-mode
  :config
   (setq-default nlinum-format "%2d ")
   (setq nlinum-highlight-current-line t)
     (custom-set-faces
      '(nlinum-current-line ((t (:inherit default :foreground "goldenrod1")))))
      '(nlinum-current-line ((t (:inherit default :foreground "goldenrod1" :height 1)))))
      
(defun cmacs|enable-line-numbers (&optional arg)
  "Enables the display of line numbers, using `display-line-numbers' (in Emacs
26+) or `nlinum-mode'."
  (if (boundp 'display-line-numbers)
      (setq display-line-numbers t)
    (nlinum-mode +1)))

(defun cmacs|disable-line-numbers ()
  "Disable the display of line numbers."
  (if (boundp 'display-line-numbers)
      (setq display-line-numbers nil)
    (nlinum-mode -1)))

;; (add-hook 'prog-mode-hook #'cmacs|enable-line-numbers)
;; (add-hook 'text-mode-hook #'cmacs|enable-line-numbers)
;; (add-hook 'conf-mode-hook #'cmacs|enable-line-numbers)

 #+END_SRC
**** Highlight numbers
 Highlight numbers in [[https://github.com/Fanael/highlight-numbers][source code]]
 #+BEGIN_SRC emacs-lisp
 (use-package highlight-numbers
   :init
   (add-hook 'prog-mode-hook #'highlight-numbers-mode))
 #+END_SRC
**** Highlight TODOs
 highlight TODO statements in comments 
 #+BEGIN_SRC emacs-lisp
 (use-package hl-todo
   :init
   (add-hook 'org-mode-hook #'hl-todo-mode)
   (add-hook 'prog-mode-hook #'hl-todo-mode)
   (add-hook 'markdown-mode-hook #'hl-todo-mode))
 #+END_SRC
**** All the icons
 Like the title says...
 #+BEGIN_SRC emacs-lisp
 (use-package all-the-icons :diminish "")
 ;; icons for dired
 (use-package all-the-icons-dired
   :after all-the-icons
   :diminish ""
   :commands (deer deer-jump-other-window all-the-icons-dired-mode dired-mode ranger)
   :init
   (add-hook 'dired-mode-hook 'all-the-icons-dired-mode))
 #+END_SRC
**** Beacon
 Useful for letting you know where the cursor is
 #+BEGIN_SRC emacs-lisp
 (use-package beacon
   :diminish beacon-mode
   :init (beacon-mode 1)
   :config
   (add-to-list 'beacon-dont-blink-major-modes 'eshell-mode))
 #+END_SRC

*** UI
**** Centered Cursor Mode
 Keep the cursor centered in the screen
 #+BEGIN_SRC emacs-lisp
     (use-package centered-cursor-mode
       :diminish centered-cursor-mode
       :commands (centered-cursor-mode
                  global-centered-cursor-mode)
       :config
       (progn
         (setq ccm-recenter-at-end-of-file t
               ccm-ignored-commands '(mouse-drag-region
                                      mouse-set-point
                                      widget-button-click
                                      scroll-bar-toolkit-scroll
                                      evil-mouse-drag-region))))

   (add-hook 'text-mode-hook 'centered-cursor-mode)
 #+END_SRC
**** Smooth Scrolling
 #+BEGIN_SRC emacs-lisp
  ;; Keyboard smooth scrolling: Prevent the awkward "snap to re-center" when
   ;; the text cursor moves off-screen. Instead, only scroll the minimum amount
   ;; necessary to show the new line. (A number of 101+ disables re-centering.)
   (setq scroll-conservatively 101)

   ;; Optimize mouse wheel scrolling for smooth-scrolling trackpad use.
   ;; Trackpads send a lot more scroll events than regular mouse wheels,
   ;; so the scroll amount and acceleration must be tuned to smooth it out.
   (setq
    ;; If the frame contains multiple windows, scroll the one under the cursor
    ;; instead of the one that currently has keyboard focus.
    mouse-wheel-follow-mouse 't
    ;; Completely disable mouse wheel acceleration to avoid speeding away.
    mouse-wheel-progressive-speed nil
    ;; The most important setting of all! Make each scroll-event move 2 lines at
    ;; a time (instead of 5 at default). Simply hold down shift to move twice as
    ;; fast, or hold down control to move 3x as fast. Perfect for trackpads.
    mouse-wheel-scroll-amount '(2 ((shift) . 4) ((control) . 6)))
 #+END_SRC
**** Which-key
 #+BEGIN_SRC emacs-lisp
 (use-package which-key
   :demand t
   :diminish ""
   :config
   (setq which-key-special-keys nil)
   ;; Set the time delay (in seconds) for the which-key popup to appear.
   (setq which-key-idle-delay .3)
   (which-key-mode))
 #+END_SRC
**** Doom-Quit
 Quit prompt with messages from Doom exit messages

 #+BEGIN_SRC emacs-lisp
 (defun doom-quit-p (&optional prompt)
   "Return t if this session should be killed. Prompts the user for
 confirmation."
 (or (yes-or-no-p (format "››› %s" (or prompt "Quit Emacs?")))
     (ignore (message "Aborted"))))
 (setq confirm-kill-emacs nil)
 (add-hook 'kill-emacs-query-functions #'doom-quit-p)
 #+END_SRC


 #+BEGIN_SRC emacs-lisp
 (defvar +doom-quit-messages
   '(;; from Doom 1
     "Please don't leave, there's more demons to toast!"
     "Let's beat it -- This is turning into a bloodbath!"
     "I wouldn't leave if I were you. DOS is much worse."
     "Don't leave yet -- There's a demon around that corner!"
     "Ya know, next time you come in here I'm gonna toast ya."
     "Go ahead and leave. See if I care."
     "Are you sure you want to quit this great editor?"
     ;; Custom
     "(setq nothing t everything 'permitted)"
     "Emacs will remember that."
     "Emacs, Emacs never changes."
     "Hey! Hey, M-x listen!"
     "I'm the man who's going to burn your house down! With lemons!"
     "It's not like I'll miss you or anything, b-baka!"
     "Okay, look. We've both said a lot of things you're going to regret..."
     "Wake up, Mr. Stallman. Wake up and smell the ashes."
     "You are *not* prepared!")
   "A list of quit messages, picked randomly by `+doom-quit'. Taken from
 http://doom.wikia.com/wiki/Quit_messages and elsewhere.")

 (defun +doom|quit (&rest _)
   (doom-quit-p
    (format "%s  Quit?"
            (nth (random (length +doom-quit-messages))
                 +doom-quit-messages))))

 (remove-hook 'kill-emacs-query-functions #'doom-quit-p)
 (add-hook 'kill-emacs-query-functions #'+doom|quit)
 #+END_SRC
**** Namespaced Keybindings
I use a lot of keybindings, with <SPC> as my "leader" key.
***** Application Keybindings
#+BEGIN_SRC emacs-lisp
(cpm-leader1 
"a"  '(:ignore t :which-key "Applications") 
"ac" '(:ignore t :which-key "Cmus")
"ad" 'deer
"ae" 'eshell
"am" 'multi-term
"ar" 'ranger
"as" 'sane-term
"aw" 'wttrin
)
#+END_SRC
***** Buffer Keybindings
#+BEGIN_SRC emacs-lisp
    (cpm-leader1
      "b"  '(:ignore t :which-key "Buffers")
      "bb" 'helm-mini
      "bc" 'spacemacs/copy-whole-buffer-to-clipboard
      "bD" 'kill-buffer-and-window
      "bd" 'kill-this-buffer
      "bf" 'browse-file-directory
      "bj" 'jump-in-buffer 
      "bk" 'evil-delete-buffer
      "bK" 'crux-kill-other-buffers
      "bn" 'spacemacs/new-empty-buffer
      ;; "bN" 'crux-kill-other-buffers
      "br" 'revert-buffer
      "bR" 'spacemacs/rename-current-buffer-file
      "bt" 'open-dir-in-iterm
  )
#+END_SRC
***** Comment Keybindings
#+BEGIN_SRC emacs-lisp
(cpm-leader1
  "c"  '(:ignore t :which-key "Commenting")
  "cb" 'org-block-wrap
  "cc" 'evil-commentary
  "cl" 'evil-commentary-line
  "cy" 'evil-commentary-yank-line
 )
#+END_SRC
***** Config Keybindings
#+BEGIN_SRC emacs-lisp
(cpm-leader1
  "C"  '(:ignore t :which-key "Config")
  "Cc" 'goto-config.org
  "Cd" 'goto-dotfiles.org
  "CD" 'goto-emacs-dir
  "Cl" 'load-config
  "Ci" 'goto-init.el
  "Co" 'goto-org-files
  "Cs" 'goto-custom.el
  )

#+END_SRC
***** File Keybindings
#+BEGIN_SRC emacs-lisp
  (cpm-leader1
    "f"  '(:ignore t :which-key "Files")
    "fd" 'fzf-directory
    "ff" 'helm-find-files
    ;; "ff" 'counsel-find-files
    ;; "fl" 'counsel-locate
    "fl" 'helm-locate
    "fo" 'crux-open-with
    "fs" 'save-buffer
    "fr" 'helm-recentf
    ;; "fr" 'counsel-recentf
    "fy" 'spacemacs/show-and-copy-buffer-filename
    "fz" 'fzf
    )
#+END_SRC
***** General Keybindings
#+BEGIN_SRC emacs-lisp
  (cpm-leader1
    "A" 'helm-apropos
    "B" #'goto-dashboard
    "?" 'helm-descbinds
    ;; "?" 'counsel-descbinds
    "<SPC>" 'helm-M-x
    ;; "<SPC>" 'counsel-M-x
    "d" 'deer
    "D" 'deer-jump-other-window
    "E" 'evil-motion-state
    "e" 'server-edit
    "G" 'general-describe-keybindings
    "h" 'helm-resume
    ;; "r" 'ivy-resume
    "j" 'avy-goto-char
    "k" 'helm-show-kill-ring
    "N" 'research-notes
    "n" 'big-notes
    ;; "W" 'woman
    "`" 'beacon-blink
    "'" 'shell-pop
    "." 'quick-commit
    ";" 'evil-commentary-line
    "[" 'spacemacs/previous-useful-buffer
    "]" 'spacemacs/next-useful-buffer
    "TAB" 'switch-to-previous-buffer)
#+END_SRC
***** Make/Compile Keybindings
#+BEGIN_SRC emacs-lisp
(cpm-leader1
  "M"   '(:ignore t :which-key "Make/Compile")
  "Mm"  'compile
  "Me"  'compile-goto-error
  "Mk"  'kill-compilation
  "Mr"  'recompile
  "Mv"  'cpm/make-move
)

(defun cpm/make-move ()
  "move files to project web directory"
   (interactive)
   (evil-ex "!make move"))


#+END_SRC
# ***** Markdown Keybindings
# #+BEGIN_SRC emacs-lisp
#   (defun my-markdown-config ()
#     "Modify keymaps in markdown mode"
#     (cpm-leader1
#       "m"   '(:ignore t :which-key "Markdown")
#       "mc"  '(:ignore t :which-key "command")
#       "mh"  '(:ignore t :which-key "insert")
#       "mi"  '(:ignore t :which-key "lists")
#       "mx"  '(:ignore t :which-key "text")
#       ;; Movement
#       "m{"   'markdown-backward-paragraph
#       "m}"   'markdown-forward-paragraph
#       ;; Completion, and Cycling
#       "m]"   'markdown-complete
#       ;; Indentation
#       "m>"   'markdown-indent-region
#       "m<"   'markdown-exdent-region
#       ;; Buffer-wide commands
#       "mc]"  'markdown-complete-buffer
#       "mcc"  'markdown-check-refs
#       "mce"  'markdown-export
#       "mcm"  'markdown-other-window
#       "mcn"  'markdown-cleanup-list-numbers
#       "mco"  'markdown-open
#       "mcp"  'markdown-preview
#       "mcv"  'markdown-export-and-preview
#       "mcw"  'markdown-kill-ring-save
#       ;; headings
#       "mhi"  'markdown-insert-header-dwim
#       "mhI"  'markdown-insert-header-setext-dwim
#       "mh1"  'markdown-insert-header-atx-1
#       "mh2"  'markdown-insert-header-atx-2
#       "mh3"  'markdown-insert-header-atx-3
#       "mh4"  'markdown-insert-header-atx-4
#       "mh5"  'markdown-insert-header-atx-5
#       "mh6"  'markdown-insert-header-atx-6
#       "mh!"  'markdown-insert-header-setext-1
#       "mh@"  'markdown-insert-header-setext-2
#       ;; Insertion of common elements
#       "m-"   'markdown-insert-hr
#       "mif"  'markdown-insert-footnote
#       "mii"  'markdown-insert-image
#       "mik"  'spacemacs/insert-keybinding-markdown
#       "miI"  'markdown-insert-reference-image
#       "mil"  'markdown-insert-link
#       "miL"  'markdown-insert-reference-link-dwim
#       "miw"  'markdown-insert-wiki-link
#       "miu"  'markdown-insert-uri
#       ;; Element removal
#       "mk"   'markdown-kill-thing-at-point
#       ;; List editing
#       "mli"  'markdown-insert-list-item
#       ;; region manipulation
#       "mxb"  'markdown-insert-bold
#       "mxi"  'markdown-insert-italic
#       "mxc"  'markdown-insert-code
#       "mxC"  'markdown-insert-gfm-code-block
#       "mxq"  'markdown-insert-blockquote
#       "mxQ"  'markdown-blockquote-region
#       "mxp"  'markdown-insert-pre
#       "mxP"  'markdown-pre-region
#       ;; Following and Jumping
#       "mN"   'markdown-next-link
#       "mf"   'markdown-follow-thing-at-point
#       "mP"   'markdown-previous-link
#       "<RET>" 'markdown-jump
#      ))
   
#   ;; (which-key-add-major-mode-key-based-replacements 'markdown-mode
#   ;;     "C-c C-a" "insert"
#   ;;     "C-c C-c" "export"
#   ;;     "C-c TAB" "images"
#   ;;     "C-c C-s" "text"
#   ;;     "C-c C-t" "header"
#   ;;     "C-c C-x" "move"
#   ;;     )
#   #+END_SRC
***** Miscellaneous Keybindings
#+BEGIN_SRC emacs-lisp
;; Show which-key top-level bindings
(global-set-key (kbd "H-k") 'which-key-show-top-level)
;; override evil insert for kill line
(general-define-key :states '(insert) "C-k" 'kill-line)
#+END_SRC
# ***** Org Keybindings
# Keybindings for org mode 
# #+BEGIN_SRC emacs-lisp
#   (cpm-leader1 
#     "o"  '(:ignore t :which-key "Org")
#     "O"  '(:ignore t :which-key "Org-Files")
#     "oh" '(:ignore t :which-key "headers")
#     "oi" '(:ignore t :which-key "insert")
#     "oS" '(:ignore t :which-key "subtree")
#     "ot" '(:ignore t :which-key "tables")
#     "or" '(:ignore t :which-key "org-reveal")
#     "oc" 'org-capture
#     "oe" '(:ignore t :which-key "export")
#     "oep" 'org-pandoc-export-to-latex-pdf
#     "oeP" 'org-pandoc-export-to-latex-pdf-and-open
#     "of" 'org-footnote-action
#     "oj" 'cpm/org-journal
#     "oP" 'org-set-property
#     ;; "P" 'org-publish-current-project
#     "op" 'org-publish-current-file
#     "o:" 'org-set-tags
#     "oa" 'org-agenda
#     "ob" 'org-tree-to-indirect-buffer
#     "oA" 'org-archive-subtree
#     "ol" 'org-open-at-point
#     "oT" 'org-show-todo-tree
#     "ov" 'org-toggle-inline-images
  
#     "orr" 'org-reveal-export-to-html-and-browse
#     "ors" 'cpm/narrowed-subtree-to-html
#     "orS" 'org-reveal-export-current-subtree
#     "orp" 'reveal-to-pdf
  
#     "o." 'org-time-stamp
#     "o!" 'org-time-stamp-inactive
  
#     ;; headings
#     "ohi" 'org-insert-heading-after-current
#     "ohI" 'org-insert-heading
  
#     ;; More cycling options (timestamps, headlines, items, properties)
#     "oL" 'org-shiftright
#     "oH" 'org-shiftleft
#     "oJ" 'org-shiftdown
#     "oK" 'org-shiftup
  
#     ;; Subtree editing
#     "oSl" 'org-demote-subtree
#     "oSh" 'org-promote-subtree
#     "oSj" 'org-move-subtree-down
#     "oSk" 'org-move-subtree-up
  
#     ;; tables
#     "ota" 'org-table-align
#     "otb" 'org-table-blank-field
#     "otc" 'org-table-convert
#     "otdc" 'org-table-delete-column
#     "otdr" 'org-table-kill-row
#     "ote" 'org-table-eval-formula
#     "otE" 'org-table-export
#     "oth" 'org-table-previous-field
#     "otH" 'org-table-move-column-left
#     "otic" 'org-table-insert-column
#     "otih" 'org-table-insert-hline
#     "otiH" 'org-table-hline-and-move
#     "otir" 'org-table-insert-row
#     "otI" 'org-table-import
#     "otj" 'org-table-next-row
#     "otJ" 'org-table-move-row-down
#     "otK" 'org-table-move-row-up
#     "otl" 'org-table-next-field
#     "otL" 'org-table-move-column-right
#     "otn" 'org-table-create
#     "otN" 'org-table-create-with-table.el
#     "otr" 'org-table-recalculate
#     "ots" 'org-table-sort-lines
#     "ottf" 'org-table-toggle-formula-debugger
#     "otto" 'org-table-toggle-coordinate-overlays
#     "otw" 'org-table-wrap-region
  
#     ;; Multi-purpose keys
#     ;; "o*" 'org-ctrl-c-star
#     ;; "oRET" 'org-ctrl-c-ret
#     "o-" 'org-ctrl-c-minus
#     "o^" 'org-sort
#     "o/" 'org-sparse-tree
  
#     "oI" 'org-clock-in
#     "on" 'org-narrow-to-subtree
#     "oN" 'widen
#     "oO" 'org-clock-out
#     "oq" 'org-clock-cancel
#     "oR" 'org-refile
#     "os" 'org-schedule
  
#     ;; insertion of common elements
#     "oil" 'org-insert-link
#     "oif" 'org-footnote-new
    
#     ;; Org files in agenda
#     "Oa" 'cpm/goto-articles.org
#     "Of" 'cpm/goto-org-files
#     "Oi" 'cpm/goto-inbox.org
#     "On" 'cpm/goto-notes.org
#     "Op" 'cpm/goto-projects.org
#     "Os" 'cpm/goto-someday.org
#     "Ot" 'cpm/goto-teaching.org
#     )
# #+END_SRC
***** Packages (Epkg) Keybindings
Keybindings for managing packages
#+BEGIN_SRC emacs-lisp
(cpm-leader1 
  "P" '(:ignore t :which-key "Packages")
  "Pl" 'epkg-list-packages
  "Pu" 'epkg-update
  "Pc" 'finder-commentary
  )
#+END_SRC
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-h C-c") 'finder-commentary)
#+END_SRC
***** Project Keybindings
#+BEGIN_SRC emacs-lisp
  (cpm-leader1 
    "p" '(:ignore t :which-key "Projects")
    "p!"  'projectile-run-shell-command-in-root
    "p&"  'projectile-run-async-shell-command-in-root
    "pa"  'projectile-toggle-between-implementation-and-test
    "pb"  'helm-projectile-switch-to-buffer
    "pc"  'projectile-compile-project
    "pC"  'desktop+-create
    "pd"  'helm-projectile-find-dir
    "pD"  'projectile-dired
    "pf"  'helm-projectile-find-file
    "pg"  'goto-projects
    "ph"  'helm-projectile
    "pJ"  'bmkp-desktop-jump
    "pG"  'projectile-regenerate-tags
    "pI"  'projectile-invalidate-cache
    "pk"  'projectile-kill-buffers
    ;; "pl"  'desktop+-load
    "pl"  'persp-switch
    "po"  'projectile-multi-occur
    "pP"  'helm-projectile-switch-project
    ;; "pp"  'helm-projectile-switch-project
    "pp"  'projectile-persp-switch-project
    ;; "pp"  'helm-persp-projectile-switch-project
    "pr"  'helm-projectile-recentf
    "pR"  'projectile-replace
    ;; "ps"  'bmkp-set-desktop-bookmark
    ;; "ps"  'desktop-save-in-desktop-dir
    "pT"  'projectile-find-test-file
    "pv"  'hydra-persp/body
    "pV"  'projectile-vc
    "py"  'projectile-find-tag
  )
#+END_SRC
***** Quit Keybindings
#+BEGIN_SRC emacs-lisp
(cpm-leader1 
  "q"  '(:ignore t :which-key "Quit")
  ;; "qq" 'save-desktop-save-buffers-kill-emacs
  "qq" 'save-buffers-kill-emacs
  "qQ" 'evil-quit-all
  "qr" 'restart-emacs)
#+END_SRC
***** Search Keybindings
#+BEGIN_SRC emacs-lisp
  (cpm-leader1
    "s" '(:ignore t :which-key "Search")
    "sa" 'helm-org-rifle-agenda-files
    "sd" 'cpm/helm-files-search-current-directory ; search current buffer's directory
    "sD" 'cpm/helm-files-do-ag ; search with directory input
    "sb" 'helm-ag-buffers
    "sf" 'helm-do-ag-this-file
    "sj" 'forward-or-backward-sexp
    "sk" 'helm-show-kill-ring
    "sl" 'last-search-buffer
    "so" 'helm-occur
    "sp" 'helm-ag-project-root
    "sr" 'helm-org-rifle
    "ss" 'helm-swoop-without-pre-input ;; search in file
    "/"  'cpm/helm-files-search-current-directory   ;; search in directory with word prompt
     )
#+END_SRC

#+RESULTS:
***** Toggle Keybindings
#+BEGIN_SRC emacs-lisp
  (cpm-leader1 
    "t"  '(:ignore t :which-key "Toggles")
    "ta" 'company-mode
    "tb" 'fancy-battery-mode
    "tB" 'beacon-mode
    "tc" 'centered-cursor-mode
    "tC" 'centered-window-mode
    "td" 'distraction-free
    "tf" 'toggle-serif
    "tF" 'toggle-frame-fullscreen
    "tg" 'git-gutter-mode
    "th" 'hl-line-mode
    "te" 'toggle-indicate-empty-lines
    "tE" 'eldoc-mode
    "tm" 'hidden-mode-line-mode
    "tM" 'spaceline-toggle-minor-modes
    "tn" 'nlinum-mode
    ;; "tn" 'display-line-numbers-mode
    "tN" 'org-numbers-overlay-mode
    "to" 'org-toggle-link-display
    "tO" 'outline-toc-mode
    "tp" 'smartparens-mode
    "tP" 'show-paren-mode 
    "tr" 'rainbow-identifiers-mode
    "ts" 'toggle-dark-light-theme
    "tt" 'helm-themes
    "tT" 'neotree-toggle
    "tw" 'writeroom-mode
    "tz" 'zone
    ;; "tt" 'counsel-load-theme
  )
#+END_SRC
***** User Keybindings
#+BEGIN_SRC emacs-lisp
  (cpm-leader1 
    "u"  '(:ignore t :which-key "User")
    "ua" 'org-agenda
    "um" 'cpm/org-to-markdown   
    "uc" 'pandoc-convert-to-pdf
    "uC" 'cpm/pandoc-convert-to-pdf 
    "uk" 'kill-compilation
    "uo" 'cpm/markdown-to-org
    "up" 'run-pandoc
    "uP" 'pandoc-pdf-open
    "us" 'sb-expand-current-file
    "uS" 'just-one-space
    "ud" 'distraction-free
    "uD" 'my-desktop
    "uj" 'goto-journal
    ;; "op" 'pandoc-convert-to-pdf
    "uw" 'count-words
    "uW" 'osx-dictionary-search-input
    "ux" 'helm-bibtex
    )
#+END_SRC
***** Version Control Keybindings
#+BEGIN_SRC emacs-lisp
(cpm-leader1
  "g"  '(:ignore t :which-key "Git")
  "gb" 'magit-blame
  "gc" 'magit-commit
  "gd" 'magit-diff
  "gl" 'magit-log
  "gn" 'git-gutter:next-hunk
  "gp" 'git-gutter:previous-hunk
  "gr" 'magit-reflog
  "gs" 'magit-status
  )
#+END_SRC
***** Window Keybindings
#+BEGIN_SRC emacs-lisp

(cpm-leader1 
  "w"  '(:ignore t :which-key "Windows")
  "wa" 'ace-window
  "wf" 'toggle-window-split
  "wc" 'delete-window
  "wd" 'delete-window
  "wm" 'delete-other-windows
  "wr" 'rotate-windows
  "wR" 'rotate-windows-backward
  "wv" 'split-window-right-and-focus
  "wV" 'evil-window-vsplit
  "wx" 'cpm/window-exchange
  "w-" 'evil-window-split
  "w_" 'split-window-below-and-focus
  )
#+END_SRC
***** Wiki Keybindings
#+BEGIN_SRC emacs-lisp
  (cpm-leader1
    "W" '(:ignore t :which-key "Wiki")
    "Wc" 'org-wiki-close
    "Wd" 'org-wiki-dired-all
    "Wk" 'org-wiki-close
    "Wh" 'org-wiki-helm
    "WH" 'org-wiki-help
    "WI" 'org-wiki-index
    "Wi" 'org-wiki-insert
    "Wl" 'org-wiki-link
    "Wm" 'org-wiki-make-page
    "Wv" 'org-wiki-server-toggle
    "We" 'org-wiki-export-html
    "Wp" 'org-wiki-panel
    "Ws" 'org-wiki-search
    "Wt" 'org-wiki-header
  )
#+END_SRC
***** Zotero Keybindings 
#+BEGIN_SRC emacs-lisp
(cpm-leader1
  "z" '(:ignore t :which-key "Zotero")
  "za" 'org-zotxt-open-attachment
  "zi" 'org-zotxt-insert-reference-link
  "zu" 'org-zotxt-update-reference-link-at-point
)
#+END_SRC
**** Diminish Modes
 Tidy Up modeline modes.
 #+BEGIN_SRC emacs-lisp
 (use-package diminish :defer 4)
 #+END_SRC
***** Diminish minor modes
 #+BEGIN_SRC emacs-lisp
   (diminish 'visual-line-mode)
   (diminish 'sticky-buffer-mode "𝓢")
   (diminish 'subword-mode)
   (eval-after-load "flyspell" '(diminish 'flyspell-mode "Ⓢ")) 
   (eval-after-load "abbrev" '(diminish 'abbrev-mode "Ⓐ"))
   (eval-after-load "lispy" '(diminish 'lispy-mode "")) 
   (eval-after-load "lispyville" '(diminish 'lispyville-mode "Ⓛ")) 
   (eval-after-load "centered-window-mode" '(diminish 'centered-window-mode "⦿"))
   (eval-after-load "org-indent" '(diminish 'org-indent-mode))
   (eval-after-load "simple" '(diminish 'auto-fill-function "Ⓕ")) 
   (eval-after-load "pandoc-mode" '(diminish 'pandoc-mode "Ⓟ"))
   (eval-after-load "git-gutter+" '(diminish 'git-gutter+-mode))
   (eval-after-load "company" '(diminish 'company-mode "Ⓒ"))
   (eval-after-load "cm-mode" '(diminish 'cm-mode "ⓒ"))
   (eval-after-load "reftex" '(diminish 'reftex-mode "ⓡ"))
   (eval-after-load "autorevert" '(diminish 'auto-revert-mode "Ⓡ"))
   (eval-after-load "simple" '(diminish 'auto-revert-mode "Ⓡ"))
   (eval-after-load "aggressive-indent" '(diminish 'aggressive-indent-mode "Ⓘ"))
   (eval-after-load "auto-indent-mode" '(diminish 'auto-indent-mode "ⓘ"))
   (eval-after-load "smartparens" '(diminish 'smartparens-mode "ⓟ"))
   (eval-after-load "org-zotxt" '(diminish 'org-zotxt-mode ""))
   (eval-after-load "back-button" '(diminish 'back-button-mode ""))
   ;; (eval-after-load "undo-tree" '(diminish 'undo-tree-mode "Ⓤ"))
   (eval-after-load "undo-tree" '(diminish 'undo-tree-mode ""))
   (eval-after-load "projectile" '(diminish 'projectile-mode ""))
   (eval-after-load "helm" '(diminish 'helm-mode ""))
   #+END_SRC
**** Popup Windows
[[https://github.com/wasamasa/shackle][Package]] that puts an end to popped up buffers not behaving they way you'd like them to.

#+BEGIN_SRC emacs-lisp
(use-package shackle
  :demand t
  :config
  ;; make helm pop-ups behave
  (setq helm-display-function #'pop-to-buffer)
  (setq shackle-rules '(("\\`\\*helm.*?\\*\\'" :regexp t :align t :ratio 0.46)))
  (shackle-mode 1))
#+END_SRC

** Navigation
*** Helm
[[https://emacs-helm.github.io/helm/][Helm]] is a robust and well-designed completion framework. It can do [[https://tuhdo.github.io/helm-intro.html][quite a lot]].
**** Helm Settings
#+BEGIN_SRC emacs-lisp 
  (use-package helm
    :diminish (helm-mode . "")
    ;; :commands (helm-mini helm-M-x helm-find-files helm-find)
    :init
    (setq helm-locate-fuzzy-match nil
          helm-locate-command "mdfind -interpret -name %s %s")
    :config
    (progn
      ;; Use helm to provide :ls, unless ibuffer is used
      (evil-ex-define-cmd "buffers" 'helm-buffers-list)
      (setq helm-M-x-fuzzy-match t  ;; Use fuzzy match in helm
            helm-apropos-fuzzy-match t
            helm-buffers-fuzzy-matching t
            helm-imenu-fuzzy-match t
            helm-recentf-fuzzy-match t
            helm-prevent-escaping-from-minibuffer t
            helm-bookmark-show-location t
            helm-ff-file-name-history-use-recentf t
            helm-find-files-sort-directories t
            helm-display-header-line nil
            helm-move-to-line-cycle-in-source nil
            helm-always-two-windows t                       
            helm-split-window-in-side-p nil
            ;; helm-split-window-default-side 'other
            helm-echo-input-in-header-line t)
      (setq helm-boring-buffer-regexp-list '("\\*SPEEDBAR" "\\*magit" "\\*Sunshine" "\\*Help" "\\*Shell Command Output" "\\*Flycheck error message" "\\*Compile-Log" "\\` " "\\*helm" "\\*helm-mode" "\\*Echo Area" "\\*Minibuf" "\\*osx-location"))
      (helm-autoresize-mode 1)
      (setq helm-autoresize-max-height 40)
      (setq helm-autoresize-min-height 35)
      (general-define-key "M-x" 'helm-M-x)
      (define-key helm-map (kbd "C-a") (kbd "RET"))
      ;;; helm vim-bindings in buffer ;;
      (map! (:map helm-map
        "TAB"   'helm-execute-persistent-action ; rebind tab to do persistent action
        "C-i"   'helm-execute-persistent-action ; make TAB works in terminal
        "C-z"   'helm-select-action ; list actions using C-z
        "C-j"   'helm-next-line
        "C-k"   'helm-previous-line
        "C-h"   'helm-next-source
        "C-l"   'helm-previous-source
        "C-S-h" 'describe-key)))
       (helm-mode 1))
#+END_SRC
**** Hide Mode Lines
Hide modelines of other windows while helm is open, again from
https://github.com/hatschipuh/better-helm.

#+BEGIN_SRC emacs-lisp
  (defvar my-helm-bottom-buffers nil
	"List of bottom buffers before helm session.
	Its element is a pair of `buffer-name' and `mode-line-format'.")

  (defun my-helm-bottom-buffers-init ()
	(setq-local mode-line-format (default-value 'mode-line-format))
	(setq my-helm-bottom-buffers
	  (cl-loop for w in (window-list)
		   when (window-at-side-p w 'bottom)
		   collect (with-current-buffer (window-buffer w)
				 (cons (buffer-name) mode-line-format)))))

  (defun my-helm-bottom-buffers-hide-mode-line ()
	(setq-default cursor-in-non-selected-windows nil)
	(mapc (lambda (elt)
		(with-current-buffer (car elt)
		  (setq-local mode-line-format nil)))
	  my-helm-bottom-buffers))

  (defun my-helm-bottom-buffers-show-mode-line ()
	(setq-default cursor-in-non-selected-windows t)
	(when my-helm-bottom-buffers
	  (mapc (lambda (elt)
		  (with-current-buffer (car elt)
		(setq-local mode-line-format (cdr elt))))
		my-helm-bottom-buffers)
	  (setq my-helm-bottom-buffers nil)))

  (defun my-helm-keyboard-quit-advice (orig-func &rest args)
	(my-helm-bottom-buffers-show-mode-line)
	(apply orig-func args))

  (add-hook 'helm-before-initialize-hook #'my-helm-bottom-buffers-init)
  (add-hook 'helm-after-initialize-hook #'my-helm-bottom-buffers-hide-mode-line)
  (add-hook 'helm-exit-minibuffer-hook #'my-helm-bottom-buffers-show-mode-line)
  (add-hook 'helm-cleanup-hook #'my-helm-bottom-buffers-show-mode-line)
  (advice-add 'helm-keyboard-quit :around #'my-helm-keyboard-quit-advice)
#+END_SRC
**** Hide Minibuffer
Hide minibuffer while helm is active

#+BEGIN_SRC emacs-lisp
  (defun my-helm-hide-minibuffer-maybe ()
	(when (with-helm-buffer helm-echo-input-in-header-line)
	  (let ((ov (make-overlay (point-min) (point-max) nil nil t)))
	(overlay-put ov 'window (selected-window))
	(overlay-put ov 'face (let ((bg-color (face-background 'default nil)))
				`(:background ,bg-color :foreground ,bg-color)))
	(setq-local cursor-type nil))))
  (add-hook 'helm-minibuffer-set-up-hook #'helm-hide-minibuffer-maybe)
#+END_SRC
**** Helm packages
***** Helm ag
#+begin_src emacs-lisp
  (use-package helm-ag  
    :commands (helm-ag helm-ag-buffers helm-ag-this-file helm-do-ag helm-ag-project-root cpm/helm-files-do-ag cpm/helm-files-search-current-directory)
    :config
    (setq helm-ag-base-command "rg --no-heading")
    (setq helm-ag-fuzzy-match t))
#+end_src
***** Helm descbinds
#+begin_src emacs-lisp 
(use-package helm-descbinds 
  :commands helm-descbinds
  :config
  (setq helm-descbinds-window-style 'same-window)
  (add-hook 'helm-mode-hook 'helm-descbinds-mode))
#+end_src
***** Helm git list
#+begin_src emacs-lisp
(use-package helm-ls-git :commands helm-ls-git-ls)
#+end_src
***** Helm hunks
#+BEGIN_SRC emacs-lisp
  (use-package helm-hunks :commands helm-hunks)

#+END_SRC
***** Helm swoop
[[https://github.com/ShingoFukuyama/helm-swoop][Search]] on steroids
#+begin_src emacs-lisp
  (use-package helm-swoop
    :commands (helm-swoop helm-swoop-back-to-last-point helm-multi-swoop helm-multi-swoop-all)
    :config
    (setq helm-swoop-use-fuzzy-match t)
    (setq helm-swoop-split-with-multiple-windows t))
#+end_src
***** Helm flyspell

Use helm with flyspell
#+begin_src emacs-lisp
(use-package helm-flyspell
  :if (not noninteractive)
  :commands helm-flyspell-correct
  :config
  (general-define-key :keymaps 'flyspell-mode-map 
     "C-;" 'helm-flyspell-correct))
#+end_src
***** Helm recent directories
Recent directories
#+begin_src emacs-lisp
(use-package helm-dired-recent-dirs
    :commands helm-dired-recent-dirs-view)
#+end_src
***** Helm files
#+begin_src emacs-lisp 
  (use-package helm-files
    :ensure nil
    :config
    (setq helm-ff-skip-boring-files t)
    (setq helm-idle-delay 0.05)
    (setq helm-input-idle-delay 0.05)
    (setq helm-ff-file-name-history-use-recentf t)
    (setq helm-boring-file-regexp-list
    '("\\.git$" "\\.hg$" "\\.svn$" "\\.CVS$" "\\._darcs$" "\\.la$" "\\.o$" "~$"
      "\\.so$" "\\.a$" "\\.elc$" "\\.fas$" "\\.fasl$" "\\.pyc$" "\\.pyo$")))
#+end_src
***** Helm-projectile
#+BEGIN_SRC emacs-lisp
  (use-package helm-projectile
    :commands (helm-projectile-switch-to-buffer
               helm-projectile-find-dir
               helm-projectile-dired-find-dir
               helm-projectile-recentf
               helm-projectile-find-file
               helm-projectile-grep
               helm-projectile
               helm-projectile-switch-project)
    :init
    (setq projectile-switch-project-action 'helm-projectile))
#+END_SRC
***** Helm interface for themes (helm-themes)
#+begin_src emacs-lisp
  (use-package helm-themes
    :commands helm-themes)
  (defadvice helm-themes--load-theme (after helm-themes--load-theme-after activate) (require 'powerline) (powerline-reset)) 
  ;; (ad-unadvise 'helm-themes--load-theme)
#+end_src
*** Ivy
Generic completion frontend that's just awesome! Let's install and enable it.

#+BEGIN_SRC emacs-lisp 
(use-package ivy 
  :diminish ivy-mode
  :general
  (:keymaps 'ivy-minibuffer-map
    "C-j" 'ivy-next-line
    "C-k" 'ivy-previous-line)
  :config
  (setq ivy-use-virtual-buffers t
        ;; number of result lines to display
        ivy-height 10
        ;; no regexp by default
        ivy-initial-inputs-alist nil
        ivy-re-builders-alist
        ;; allow input not in order
        '((t   . ivy--regex-ignore-order))
        ivy-count-format "%d/%d "))
#+END_SRC
*** Counsel
Counsel allows us to utilize ivy by replacing many built-in and common functions
with richer versions. Let's install it!

#+BEGIN_SRC emacs-lisp :tangle no
(use-package counsel-projectile :commands counsel-projectile-bookmark)
(use-package counsel
  :commands (council-org-goto jump-in-buffer)
  :config
  (map! (:map counsel-mode-map
         :ni "C-j" #'ivy-next-line
         :ni "C-k" #'ivy-previous-line)))

#+END_SRC
*** Swiper
Swiper is an awesome searching utility with a quick preview. Let's install it and
load it when =swiper= or =swiper-all= is called.

#+BEGIN_SRC emacs-lisp
(use-package swiper
  :commands (swiper swiper-all))
#+END_SRC
*** Bookmark
#+BEGIN_SRC emacs-lisp
    (use-package bookmark+
      ;; :commands bmkp-set-desktop-bookmark
      :defer 10
      :init
      (setq bookmark-default-file
               (concat cmacs-cache-dir "bookmarks"))
      (setq bmkp-last-as-first-bookmark-file (concat cmacs-cache-dir "bookmarks"))
  )
#+END_SRC 
*** Hydra
#+BEGIN_SRC emacs-lisp
(use-package hydra
  :defer 5
  :config
  ;; hydra for TODOs
  (defhydra hydra-todo (:pre
                  (hl-todo-mode 1)
              :post
             (hl-todo-mode -1))
  "Todo"
  ("n" hl-todo-next "Next")
  ("p" hl-todo-previous "Previous")
  ("o" hl-todo-occur "Occur")
  ("q" nil "Quit" :color blue :exit t))
)
#+END_SRC
*** Saveplace
#+BEGIN_SRC emacs-lisp
  (use-package saveplace
    :init
    (save-place-mode 1)
    :config
    (setq save-place-file (concat cmacs-cache-dir "saved-places")
    ;; (setq save-place-forget-unreadable-files nil)
  ))
#+END_SRC
*** Ace Window
Ace [[https://github.com/abo-abo/ace-window][window management]]. 
#+BEGIN_SRC emacs-lisp
(use-package ace-window
  :commands (ace-window ace-swap-window aw-flip-window cpm/swap-windows))
#+END_SRC
*** Avy
#+BEGIN_SRC emacs-lisp
(use-package avy
  :commands (avy-goto-char))
#+END_SRC
*** Windows
**** Window Numbering
Numbered window shortcuts for Emacs
#+BEGIN_SRC emacs-lisp
   (use-package window-numbering
     :demand t
     :config
     (defun window-numbering-install-mode-line (&optional position)
     "Do nothing, the display is handled by the powerline.")
     (setq window-numbering-auto-assign-0-to-minibuffer nil)
     (cpm-leader1
       "0" 'select-window-0
       "1" 'select-window-1
       "2" 'select-window-2
       "3" 'select-window-3
       "4" 'select-window-4
       "5" 'select-window-5)
     (window-numbering-mode 1)

  ;; make sure neotree is always 0
   (defun spacemacs//window-numbering-assign ()
     "Custom number assignment for neotree."
     (when (and (boundp 'neo-buffer-name)
                (string= (buffer-name) neo-buffer-name)
                ;; in case there are two neotree windows. Example: when
                ;; invoking a transient state from neotree window, the new
                ;; window will show neotree briefly before displaying the TS,
                ;; causing an error message. the error is eliminated by
                ;; assigning 0 only to the top-left window
                (eq (selected-window) (window-at 0 0)))
       0))

   ;; using lambda to work-around a bug in window-numbering, see
   ;; https://github.com/nschum/window-numbering.el/issues/10
   (setq window-numbering-assign-func
         (lambda () (spacemacs//window-numbering-assign))))
#+END_SRC
**** Unset window keys
A nice tip from [[http://pragmaticemacs.com/emacs/use-your-digits-and-a-personal-key-map-for-super-shortcuts/][Pragmatic emacs]]
#+BEGIN_SRC emacs-lisp
;; unset C- and M- digit keys
(dotimes (n 10)
  (global-unset-key (kbd (format "C-%d" n)))
  (global-unset-key (kbd (format "M-%d" n)))
  )
#+END_SRC
**** Windmove
#+BEGIN_SRC emacs-lisp
(use-package windmove
  :commands (windmove-up windmove-down windmove-left windmove-right)
  :config
  (defun split-window-right-and-focus ()
  "Split the window horizontally and focus the new window."
  (interactive)
  (split-window-right)
  (windmove-right))
  (defun split-window-below-and-focus ()
  "Split the window vertically and focus the new window."
  (interactive)
  (split-window-below)
  (windmove-down))
  ;; add edit mode keybindings
  (global-set-key (kbd "<H-up>")     'windmove-up)
  (global-set-key (kbd "<H-down>")   'windmove-down)
  (global-set-key (kbd "<H-left>")   'windmove-left)
  (global-set-key (kbd "<H-right>")  'windmove-right)
  )
#+END_SRC
*** Ranger & Deer
Better dired navigation using ranger-like settings
#+BEGIN_SRC emacs-lisp
  (use-package ranger
    :commands (ranger deer deer-jump-other-window)
    :init
    (setq ranger-override-dired t
          ranger-cleanup-eagerly t)
    ;; set up image-dired to allow picture resize
    (setq image-dired-dir (concat cmacs-cache-dir "image-dir"))
    (unless (file-directory-p image-dired-dir)
      (make-directory image-dired-dir t))
    :config
    (define-key dired-mode-map "Y" 'ora-dired-rsync)
    (setq  ranger-dont-show-binary t
           ranger-excluded-extensions '("mkv" "iso" "mp4")
           ranger-max-preview-size 25
           ranger-preview-file t
           ranger-show-dotfiles t
           ranger-width-parents 0.25
           ranger-width-preview 0.55 
           ))

  (defun deer-jump-other-window (&optional path)
    "Launch dired in a minimal ranger window in other window."
    (interactive)
    (switch-to-buffer-other-window (current-buffer))
    (deer path))

#+END_SRC
*** Recent files
#+BEGIN_SRC emacs-lisp
  (use-package recentf
    :demand t
    :config 
    (setq recentf-save-file (concat cmacs-etc-dir "recentf"))
    ;; remove agenda files from list.
    (setq recentf-exclude '("projects.org"
                            "inbox.org"
                            "someday.org"
                            "bookmark")
          recentf-max-saved-items 300
          recentf-max-menu-items 10))
#+END_SRC

** Org
*** Settings
**** Org Directories 
     #+BEGIN_SRC emacs-lisp
     (setq org-directory "~/Dropbox/org-files")
     (setq org-default-notes-file (concat org-directory "/inbox.org"))
     (setq org-archive-location (concat org-directory "/org-archive/archived.org::"))
     #+END_SRC
**** State Settings
     #+BEGIN_SRC emacs-lisp
     (setq org-todo-keywords
      '((sequence "TODO" "STARTED" "IN-PROGRESS" "WAITING" "|" "DONE" "CANCELED")))
     #+END_SRC
**** Org Logging
     #+BEGIN_SRC emacs-lisp
    ; log timestamp when task is marked "DONE" or other finished keyword
    (setq org-log-done 'time)
     #+END_SRC
**** Org Babel Languages
#+BEGIN_SRC emacs-lisp
(with-eval-after-load 'org
(org-babel-do-load-languages
 'org-babel-load-languages
 '((python . t)
   (C . t)
   (calc . t)
   (latex . t)
   (java . t)
   (ruby . t)
   (lisp . t)
   (scheme . t)
   (shell . t)
   (sqlite . t)
   (js . t)))

(defun my-org-confirm-babel-evaluate (lang body)
  "Do not confirm evaluation for these languages."
  (not (or (string= lang "C")
           (string= lang "java")
           (string= lang "python")
           (string= lang "emacs-lisp")
           (string= lang "sqlite"))))
(setq org-confirm-babel-evaluate 'my-org-confirm-babel-evaluate))
#+END_SRC
**** Org Babel Source Blocks
#+BEGIN_SRC emacs-lisp
(setq org-src-fontify-natively t
      org-src-window-setup 'current-window
      org-src-strip-leading-and-trailing-blank-lines t
      org-src-preserve-indentation t
      org-src-tab-acts-natively t)
#+END_SRC

**** Org Config Settings
#+BEGIN_SRC emacs-lisp
  (setq-default 
        org-return-follows-link t ;; make RET follow links
        org-list-allow-alphabetical t ;; allow alphabetical list
        org-hide-emphasis-markers t  ;; hide markers
        org-pretty-entities t ;; make latex look good
        org-pretty-entities-include-sub-superscripts t
        org-hide-leading-stars t
        org-startup-folded t
        org-startup-indented t
        org-M-RET-may-split-line '((default . nil))  ;; don't split line when creating a new headline, list item, or table field
        org-fontify-quote-and-verse-blocks t ;; make quotes stand out
        org-table-export-default-format "orgtbl-to-csv" ;; export for org-tables to csv
        ;; org-ellipsis "↷" ;; nicer elipses "↴" "▼"
        org-startup-indented t ;; start in indent mode
        org-imenu-depth 8
        imenu-auto-rescan t)
#+END_SRC
#+BEGIN_SRC emacs-lisp
#+END_SRC
#+BEGIN_SRC emacs-lisp
#+END_SRC
#+BEGIN_SRC emacs-lisp
#+END_SRC
#+BEGIN_SRC emacs-lisp
#+END_SRC
*** Org Keybindings

#+BEGIN_SRC emacs-lisp
     (with-eval-after-load 'org
       (general-define-key :states '(normal) :keymaps 'org-mode-map
          "RET" 'org-open-at-point     ;; Open with return in evil
          "L" 'org-shiftright
          "H" 'org-shiftleft
          "$" 'org-end-of-line
          "^" 'org-beginning-of-line
          "<" 'org-metaleft
          ">" 'org-metaright
          "-" 'org-cycle-list-bullet)
       ;; normal & insert state shortcuts.
       (general-define-key :states '(normal insert) :keymaps 'org-mode-map
          "TAB" 'org-cycle
          "s-l" 'org-metaright
          "s-h" 'org-metaleft
          "s-k" 'org-metaup
          "s-j" 'org-metadown
          "s-L" 'org-shiftmetaright
          "s-H" 'org-shiftmetaleft
          "s-K" 'org-shiftmetaup
          "s-J" 'org-shiftmetadown
          "s-o" '(lambda () (interactive)
                   (evil-org-eol-call
                    '(lambda()
                       (org-insert-heading)
                       (org-metaright))))
          "s-t" '(lambda () (interactive)
                   (evil-org-eol-call
                    '(lambda()
                       (org-insert-todo-heading nil)
                       (org-metaright)))))
       ;; Use tab in insert mode
       (general-define-key :states '(insert) :keymaps 'org-mode-map "\t" nil
          "RET" #'org-return-indent
          "C-j" nil
          "C-k" nil
          "C-j"   #'org-next-visible-heading
          "C-k"   #'org-previous-visible-heading
          "C-S-j"     #'org-forward-heading-same-level
          "C-S-k"     #'org-backward-heading-same-level))

  ;; local leader keybindings
  (with-eval-after-load 'org
    (map! (:map org-mode-map 
      (:localleader
      :n  "RET" #'org-archive-subtree
      :n  "SPC" #'org-toggle-checkbox
      :n  "/"   #'org-sparse-tree
      :n  "="   #'org-align-all-tags
      :n  "?"   #'org-tags-view
      :n  ":"   #'org-set-tags
      :n  "a"   #'org-agenda
      :n  "A"   #'org-archive-subtree
      :n  "b"   #'org-tree-to-indirect-buffer
      :n  "c"   #'org-capture
      :n  "d"   #'org-time-stamp
      :n  "D"   #'org-deadline
      :n  "e"   #'org-edit-special
      :n  "n"   #'org-narrow-to-subtree
      :n  "N"   #'widen
      :n  "r"   #'org-refile
      :n  "s"   #'org-schedule
      :n  "t"   #'counsel-org-tag
      :n  "T"   #'org-todo
      :n  "v"   #'variable-pitch-mode
      :nv "l"   #'org-insert-link
      :nv "L"   #'org-store-link
      :n  "+"   #'org-timestamp-up-day
      :n  "-"   #'org-timestamp-down-day
      :n  "<"   #'org-metaleft
      :n  ">"   #'org-metaright
      (:desc "Insert..." :prefix "i"
        :nv     "l" #'org-insert-link
        :nv     "f" #'org-footnote-new)
      (:desc "Org files..." :prefix "O"
        :nv "a" #'cpm/goto-articles.org
        :nv "f" #'cpm/goto-org-files
        :nv "i" #'cpm/goto-inbox.org
        :nv "n" #'cpm/goto-notes.org
        :nv "p" #'cpm/goto-projects.org
        :nv "s" #'cpm/goto-someday.org
        :nv "t" #'cpm/goto-teaching.org)
      (:desc "RevealJS..." :prefix "R"
        :nv       "r" #'org-reveal-export-to-html-and-browse
        :nv       "s" #'cpm/narrowed-subtree-to-html
        :nv       "S" #'org-reveal-export-current-subtree
        :nv       "p" #'reveal-to-pdf))))

  (after! org-agenda
    (map! :map org-agenda-mode-map
          :e "<escape>" #'org-agenda-Quit
          :e "m"   #'org-agenda-month-view
          :e "C-j" #'org-agenda-next-item
          :e "C-k" #'org-agenda-previous-item
          :e "C-n" #'org-agenda-next-item
          :e "C-p" #'org-agenda-previous-item)))
#+END_SRC
*** Hook
#+BEGIN_SRC emacs-lisp
    (add-hook 'org-mode-hook
        (lambda () 
          (turn-on-auto-fill)
          (flyspell-mode 1)
          (cmacs|disable-line-numbers)
          (org-bullets-mode 1)
          (global-git-gutter-mode 0)))
#+END_SRC
*** FIXME Org Template Expansions

#+BEGIN_SRC emacs-lisp
(with-eval-after-load 'org
(add-to-list 'org-structure-template-alist
  '("E" "#+BEGIN_SRC emacs-lisp\n?\n#+END_SRC"))
(add-to-list 'org-structure-template-alist
  '("n" "#+BEGIN_NOTES\n?\n#+END_NOTES"))
(add-to-list 'org-structure-template-alist
  '("t" "#+BEGIN_COMMENT TODO: ?  #+END_COMMENT"))
(add-to-list 'org-structure-template-alist
  '("b" "#+REVEAL: split?"))
(add-to-list 'org-structure-template-alist
  '("f" "#+ATTR_REVEAL: :frag (appear)?")))
#+END_SRC

*** Org Bullets
#+BEGIN_SRC emacs-lisp
(use-package org-bullets
  :init (add-hook 'org-mode-hook 'org-bullets-mode)
  :config 
  (setq org-bullets-bullet-list '("❂" "⁑" "⁂" "⁘" "⁙" "✶" "✪" "✵")))
#+END_SRC
*** Org Prettify Source Blocks
Make source blocks look better. Courtesy of [[https://pank.eu/blog/pretty-babel-src-blocks.html][Rasmus Pank Roulund]].
#+BEGIN_SRC emacs-lisp
  (with-eval-after-load 'org
    (defvar-local rasmus/org-at-src-begin -1
      "Variable that holds whether last position was a ")

    (defvar rasmus/ob-header-symbol ?☰
      "Symbol used for babel headers")

    (defun rasmus/org-prettify-src--update ()
      (let ((case-fold-search t)
            (re "^[ \t]*#\\+begin_src[ \t]+[^ \f\t\n\r\v]+[ \t]*")
            found)
        (save-excursion
          (goto-char (point-min))
          (while (re-search-forward re nil t)
            (goto-char (match-end 0))
            (let ((args (org-trim
                         (buffer-substring-no-properties (point)
                                                         (line-end-position)))))
              (when (org-string-nw-p args)
                (let ((new-cell (cons args rasmus/ob-header-symbol)))
                  (cl-pushnew new-cell prettify-symbols-alist :test #'equal)
                  (cl-pushnew new-cell found :test #'equal)))))

          (setq prettify-symbols-alist
                (cl-set-difference prettify-symbols-alist
                                   (cl-set-difference
                                    (cl-remove-if-not
                                     (lambda (elm)
                                       (eq (cdr elm) rasmus/ob-header-symbol))
                                     prettify-symbols-alist)
                                    found :test #'equal)))

          ;; Clean up old font-lock-keywords.
          (font-lock-remove-keywords nil prettify-symbols--keywords)
          (setq prettify-symbols--keywords (prettify-symbols--make-keywords))
          (font-lock-add-keywords nil prettify-symbols--keywords)
          (while (re-search-forward re nil t)
            (font-lock-flush (line-beginning-position) (line-end-position))))))

    (defun rasmus/org-prettify-src ()
      "Hide src options via `prettify-symbols-mode'.

    `prettify-symbols-mode' is used because it has uncollpasing. It's
    may not be efficient."
      (let* ((case-fold-search t)
             (at-src-block (save-excursion
                             (beginning-of-line)
                             (looking-at "^[ \t]*#\\+begin_src[ \t]+[^ \f\t\n\r\v]+[ \t]*"))))
        ;; Test if we moved out of a block.
        (when (or (and rasmus/org-at-src-begin
                       (not at-src-block))
                  ;; File was just opened.
                  (eq rasmus/org-at-src-begin -1))
          (rasmus/org-prettify-src--update))
        (setq rasmus/org-at-src-begin at-src-block)))

    (defun rasmus/org-prettify-symbols ()
      (mapc (apply-partially 'add-to-list 'prettify-symbols-alist)
            (cl-reduce 'append
                       (mapcar (lambda (x) (list x (cons (upcase (car x)) (cdr x))))
                               `(("#+begin_src" . ?╦) ;; ➤ 🖝 ➟ ➤ ✎ ✎
                                 ("#+end_src"   . ?╩) ;; □
                                 ("#+header:" . ,rasmus/ob-header-symbol)
                                 ("#+begin_comment" . ?✎)
                                 ("#+end_comment" . ?✎)
                                 ("#+begin_notes" . ?➤)
                                 ("#+end_notes" . ?➤)
                                 ("#+begin_quote" . ?»)
                                 ("#+end_quote" . ?«)))))
      (turn-on-prettify-symbols-mode))
    ;; turn off hiding of source comments
    ;; (add-hook 'post-command-hook 'rasmus/org-prettify-src t t))
    (add-hook 'org-mode-hook #'rasmus/org-prettify-symbols))
#+END_SRC

*** Org-Goto
Make counsel display org headings nicely. 
#+BEGIN_SRC emacs-lisp
(with-eval-after-load 'org
  (setq counsel-org-goto-display-style 'path)
  (setq counsel-org-goto-separator " ➜ ")
  (setq counsel-org-goto-face-style 'org)
  (define-key org-mode-map (kbd "C-c C-j") 'counsel-org-goto)
  (define-key org-mode-map (kbd "C-u C-c C-j") 'counsel-org-goto-all))
#+END_SRC
*** Org-Reveal
#+BEGIN_SRC emacs-lisp
  (use-package ox-reveal
  :commands (org-reveal-export-current-subtree org-reveal-export-to-html-and-browse)
  :config
  (setq org-reveal-root (concat "file://" (getenv "HOME") "/bin/reveal.js")
        org-reveal-theme "moon"
        org-reveal-default-frag-style "roll-in"
        org-reveal-hlevel 2
        ))
       
(defun cpm/narrowed-subtree-to-html ()
  "export narrowed tree to html"
  (interactive)
  (org-reveal-export-current-subtree)
  (org-narrow-to-subtree))
#+END_SRC
*** Org-Agenda
Settings for the [[http://orgmode.org/manual/Agenda-Views.html][agenda]]. 
#+BEGIN_SRC emacs-lisp
  (with-eval-after-load 'org-agenda
  (general-define-key :keymaps 'org-agenda-mode-map 
                      "j" 'org-agenda-next-item
                      "k" 'org-agenda-previous-item))
  (setq org-agenda-files '("~/Dropbox/org-files/"))
  
;; automatically refresh the agenda after adding a task
(add-hook 'org-capture-after-finalize-hook 'cpm/org-agenda-refresh)

(defun cpm/org-agenda-refresh ()
(interactive)
(when (get-buffer "*Org Agenda*")
    (with-current-buffer "*Org Agenda*"
        (org-agenda-redo t)
        (message "[org agenda] refreshed!"))))
#+END_SRC

**** TESTING Org-Super-Agenda
[[https://github.com/alphapapa/org-super-agenda][Supercharge]] org-agenda
#+BEGIN_SRC emacs-lisp
(use-package org-super-agenda
  :preface
  (defun super-jump-to-org-agenda ()
    (interactive)
    (let ((org-super-agenda-groups
           '((:name "Today"
                    :time-grid t
                    :todo "TODAY")
             (:name "Important"
                    :tag "bills"
                    :priority "A")
             (:todo "WAITING" :order 8)
             (:todo ("SOMEDAY" "TO-READ" "CHECK" "TO-WATCH" "WATCHING")
                    :order 9)
             (:priority<= "B" :order 1))))
      (org-agenda nil "a")))
  :config
  (org-super-agenda-mode))
#+END_SRC
*** Org Capture
#+BEGIN_SRC emacs-lisp
      (add-hook 'org-capture-mode-hook 'evil-insert-state)
      (setq org-capture-templates
            '(("p" "Projects" entry (file+headline "~/Dropbox/org-files/projects.org" "Unfiled")
                   "** STARTED %? \n  %i\n  Captured on: %u\n")
              ("c" "Capture" entry (file "~/Dropbox/org-files/inbox.org")
                   "* TODO %?\n %i")
              ("j" "Journal" entry (file+datetree "~/Dropbox/org-files/journal.org")
                   "**** %<%H:%M>\n%?")
              ("n" "Notes" entry (file "~/Dropbox/org-files/org-notes.org")
              "* %? \n Captured on: %U\n")))

  ;; Add date to captured items
  (defun add-property-with-date-captured ()
    "Add DATE_CAPTURED property to the current item."
    (interactive)
    (org-set-property "DATE_CAPTURED" (format-time-string "%c")))

  (add-hook 'org-capture-before-finalize-hook 'add-property-with-date-captured)
        (defun cpm/org-journal ()
        (interactive) (org-capture nil "j"))

    (defadvice org-capture
        (after make-full-window-frame activate)
      "Advise capture to be the only window when used as a popup"
      (if (equal "What are you doing?" (frame-parameter nil 'name))
          (delete-other-windows)))
    (defadvice org-capture-finalize
        (after delete-capture-frame activate)
      "Advise capture-finalize to close the frame"
      (if (equal "What are you doing?" (frame-parameter nil 'name))
          (delete-frame)))

#+END_SRC

**** FIXME Org Global Capture
Good tips from [[https://www.reddit.com/r/emacs/comments/6lzyg2/heres_how_to_do_emacsclient_global_orgcapture/][reddit]]. But unfortunately doesn't seem to work on High
Sierra for me :(
#+BEGIN_SRC emacs-lisp
; https://cestlaz.github.io/posts/using-emacs-24-capture-2/
; Bind Key to: emacsclient -ne "(make-capture-frame)"

(defadvice org-capture-finalize 
    (after delete-capture-frame activate)
  "Advise capture-finalize to close the frame"
  (if (equal "capture" (frame-parameter nil 'name))
      (delete-frame)))

(defadvice org-capture-destroy
    (after delete-capture-frame activate)
  "Advise capture-destroy to close the frame"
  (if (equal "capture" (frame-parameter nil 'name))
      (delete-frame)))

(use-package noflet
   :defer 2
   :ensure t )
(defun make-capture-frame ()
  "Create a new frame and run org-capture."
  (interactive)
  (make-frame '((name . "capture")))
  (select-frame-by-name "capture")
  (delete-other-windows)
  (noflet ((switch-to-buffer-other-window (buf) (switch-to-buffer buf)))
          (org-capture)))

#+END_SRC

*** Org Refile
Set refile settings.  I got a lot of help on this from [[https://blog.aaronbieber.com/2017/03/19/organizing-notes-with-refile.html][Aaron Bieber's discussion]].

With this set, you can trigger Refile with C-c C-w in any Org file and
get a completing read of all headings up to three levels deep in all
files in =org-agenda-files=. You can also refile to the top header in a
document and create new parents.
#+BEGIN_SRC emacs-lisp
(setq org-refile-targets '((org-agenda-files :maxlevel . 3)))
(setq org-refile-use-outline-path 'file)
(setq org-outline-path-complete-in-steps nil)
(setq org-refile-allow-creating-parent-nodes 'confirm)
#+END_SRC
*** Org & Pandoc (Ox-pandoc)

#+BEGIN_SRC emacs-lisp
    (use-package ox-pandoc
      ;; :after org
      ;; :commands (org-pandoc-publish-to-html5)
      :defer 5
      :config
      ;; default options for all output formats
      ;; (setq org-pandoc-command (expand-file-name "~/.local/bin/pandoc"))
      ;; (setq org-pandoc-options '((standalone . t)))
      ;; cancel above settings only for 'docx' format
      (setq org-pandoc-options-for-docx '((standalone . nil)))
      ;; special settings for beamer-pdf and latex-pdf exporters
      (setq org-pandoc-options-for-beamer-pdf '((latex-engine . "xelatex")))
      (setq org-pandoc-options-for-latex-pdf '((latex-engine . "xelatex")))


      ;; Pandoc publishing functions 
      (defun org-pandoc-publish-to (format plist filename pub-dir)
      (setq org-pandoc-format format)
      (let ((tempfile
            (org-publish-org-to
                'pandoc filename (concat (make-temp-name ".tmp") ".org") plist pub-dir))
              (outfile (format "%s.%s"
                       (concat
                        pub-dir
                        (file-name-sans-extension (file-name-nondirectory filename)))
                       (assoc-default format org-pandoc-extensions))))
                (org-pandoc-put-options (org-pandoc-plist-to-alist plist))
                (let ((process
                 (org-pandoc-run tempfile outfile format 'org-pandoc-sentinel
                         org-pandoc-option-table))
                (local-hook-symbol
                 (intern (format "org-pandoc-after-processing-%s-hook" format))))
                  (process-put process 'files (list tempfile))
                  (process-put process 'output-file filename)
                  (process-put process 'local-hook-symbol local-hook-symbol))))

      ;; helper functions
      (defun org-pandoc-publish-to-html (p f pd)
      (org-pandoc-publish-to 'html p f pd))

      (defun org-pandoc-publish-to-html5 (p f pd)
      (org-pandoc-publish-to 'html5 p f pd))

      (defun org-pandoc-publish-to-org (p f pd)
      (org-pandoc-publish-to 'org p f pd))

      (defun org-pandoc-publish-to-markdown (p f pd)
      (org-pandoc-publish-to 'markdown p f pd))

      (defun org-pandoc-pan-to-pub (o)
      (intern (format ":org-pandoc-%s" o)))

            (defun org-pandoc-pub-to-pan (o)
            (intern (substring (symbol-name o) 12)))

            (defconst org-pandoc-publish-options
              (mapcar 'org-pandoc-pan-to-pub
                  (append org-pandoc-valid-options org-pandoc-colon-separated-options
                      org-pandoc-file-options)))

            (defun org-pandoc-plist-to-alist (plist)
              (let ((alist '()))
                (while plist
                  (let ((p (car plist)) (v (cadr plist)))
                (when (member p org-pandoc-publish-options)
                  (add-to-list 'alist (cons (org-pandoc-pub-to-pan p) v))))
                  (setq plist (cddr plist)))
                alist))


  ;; (org-link-set-parameters
  ;;  "wiki"
  ;;  :export (lambda (path desc backend)
  ;;        (message-box "%s" backend)
  ;;        (cond
  ;;         ((eq backend 'html)
  ;;          (format "<a href='%s.html'>%s</a>" path (or desc path)))
  ;;         ((eq backend 'pandoc)
  ;;          (format "\<a href='%s.html'\>%s\</a\>" path (or desc path))))))

  )
#+END_SRC 
*** Org Rifle
Search [[https://github.com/alphapapa/helm-org-rifle][rapidly]] through org files using helm
#+BEGIN_SRC emacs-lisp
  (use-package helm-org-rifle
    :commands (helm-org-rifle helm-org-rifle-agenda-files helm-org-rifle-org-directory))
#+END_SRC
*** Org-Download
Drag and drop images to Emacs org-mode. Courtesy of [[https://github.com/abo-abo/org-download][abo-abo]]. 
#+BEGIN_SRC emacs-lisp
  (use-package org-download
     ;; :after org
     :defer t
     :config
     (setq org-download-method 'directory)
           org-download-image-dir "/Users/roambot/Dropbox/org-files/org-pictures"
           org-download-image-latex-width 500
   )
#+END_SRC
*** Org Pomodoro
Helps with time tracking
#+BEGIN_SRC emacs-lisp
  (use-package org-pomodoro
    :commands org-pomodoro
    :ensure t
    :init
    (progn
      (setq org-pomodoro-audio-player "/usr/bin/afplay")))
#+END_SRC emacs-lisp
*** Open Docx Files In Default Application (Ie Msword)
Open exported docx files in Word/Open Office rather than emacs
#+BEGIN_SRC emacs-lisp
  (setq org-file-apps
        '(("\\.docx\\'" . default)
          ("\\.mm\\'" . default)
          ("\\.x?html?\\'" . default)
          ("\\.pdf\\'" . default)
          (auto-mode . emacs)))
#+END_SRC
*** Org Indirect Buffer
Some advice to automatically switch to a new indirect buffer upon creation
#+BEGIN_SRC emacs-lisp
(defadvice org-tree-to-indirect-buffer (after org-tree-to-indirect-buffer-after activate) (other-window 1))
#+END_SRC

*** Org Functions
Some useful org-specific functions
*** Org-Fill Functions
 Functions to calculate apt offsets and call regular org fill stuff. There's a
 useful [[http://stackoverflow.com/questions/14351154/org-mode-outline-level-specific-fill-column-values][stack overflow thread]] on this. 
#+BEGIN_SRC emacs-lisp
(defun calc-offset-on-org-level ()
  "Calculate offset (in chars) on current level in org mode file."
  (* (or (org-current-level) 0) org-indent-indentation-per-level))

(defun my-org-fill-paragraph (&optional JUSTIFY)
  "Calculate apt fill-column value and fill paragraph."
  (let* ((fill-column (- fill-column (calc-offset-on-org-level))))
    (org-fill-paragraph JUSTIFY)))

(defun my-org-auto-fill-function ()
  "Calculate apt fill-column value and do auto-fill"
  (let* ((fill-column (- fill-column (calc-offset-on-org-level))))
    (org-auto-fill-function)))
    
(defun my-org-mode-hook ()
  (setq fill-paragraph-function   'my-org-fill-paragraph
        normal-auto-fill-function 'my-org-auto-fill-function))

(add-hook 'org-load-hook 'my-org-mode-hook)
(add-hook 'org-mode-hook 'my-org-mode-hook)
#+END_SRC
*** Narrow & Advance/Retreat
Functions to advance forwards or backwards through narrowed tree
#+BEGIN_SRC emacs-lisp
(defun org-advance ()
  (interactive)
  (when (buffer-narrowed-p)
    (beginning-of-buffer)
    (widen)
    (org-forward-heading-same-level 1))
  (org-narrow-to-subtree))

(defun org-retreat ()
  (interactive)
  (when (buffer-narrowed-p)
    (beginning-of-buffer)
    (widen)
    (org-backward-heading-same-level 1))
  (org-narrow-to-subtree))
#+END_SRC
*** Org files
#+BEGIN_SRC emacs-lisp
(defun cpm/goto-org-files ()
  "goto org-files directory"
  (interactive)
  (require 'ranger)
  (find-file "~/Dropbox/org-files"))
(defun cpm/goto-inbox.org ()
  "goto org-inbox"
  (interactive)
  (find-file "~/Dropbox/org-files/inbox.org"))
(defun cpm/goto-projects.org ()
  "goto org-projects"
  (interactive)
  (find-file "~/Dropbox/org-files/projects.org"))
(defun cpm/goto-articles.org ()
  "goto org-articles"
  (interactive)
  (find-file "~/Dropbox/org-files/articles.org"))
(defun cpm/goto-teaching.org ()
  "goto org-teaching"
  (interactive)
  (find-file "~/Dropbox/org-files/teaching.org"))
(defun cpm/goto-notes.org ()
  "goto org-notes"
  (interactive)
  (find-file "~/Dropbox/org-files/notes.org"))
(defun cpm/goto-someday.org ()
  "goto org-someday"
  (interactive)
  (find-file "~/Dropbox/org-files/someday.org"))
#+END_SRC
*** Org Numbers Overlay
[[https://github.com/larkery/emacs/blob/master/site-lisp/org-numbers-overlay.el][This]] is a useful minor-mode to number org-mode headings. It came up in
the course of [[https://www.reddit.com/r/emacs/comments/6crtzw/it_is_possible_to_display_numbers_at_the/][this reddit]] discussion. 
#+BEGIN_SRC emacs-lisp
(define-minor-mode org-numbers-overlay-mode
  "Add overlays to org headings which number them"
  nil " *1." nil

  (let ((hooks '(after-save-hook
                 org-insert-heading-hook))
        (funcs '(org-promote
                 org-cycle-level
                 org-promote-subtree
                 org-demote
                 org-demote-subtree
                 org-move-subtree-up
                 org-move-subtree-down
                 org-move-item-down
                 org-move-item-up
                 org-cut-subtree
                 org-insert-todo-heading
                 org-insert-todo-subheading
                 org-meta-return
                 org-set-property
                 org-move)))
    (if org-numbers-overlay-mode
        (progn
          (org-numbers-overlay-update)
          (dolist (fn funcs)
            (advice-add fn :after #'org-numbers-overlay-update))
          (dolist (hook hooks)
            (add-hook hook #'org-numbers-overlay-update)))

      (progn
        (dolist (fn funcs)
          (advice-add fn :after #'org-numbers-overlay-update))
        (dolist (hook hooks)
          (remove-hook hook #'org-numbers-overlay-update))

        (loop for o in (overlays-in (point-min) (point-max))
              if (eq (overlay-get o 'type) 'org-number)
              do (delete-overlay o))))))

(defun org-numbers-overlay-update (&rest args)
  (when org-numbers-overlay-mode
    (let ((levels (make-vector 10 0)))
      (save-excursion
        (widen)
        (goto-char (point-min))
        (while (outline-next-heading)
          (if (assoc "UNNUMBERED" (org-entry-properties))
              ;; if it's unnumbered delete any overlays we have on it
              (loop for o in (overlays-in (point)
                                          (save-excursion (end-of-line) (point)))
                    if (eq (overlay-get o 'type) 'org-number)
                    do (delete-overlay o))
            ;; if it's not unnumbered add a number or update it
            (let* ((detail (org-heading-components))
                   (level (- (car detail) 1))
                   (lcounter (1+ (aref levels level)))
                   (o (or (loop for o in (overlays-in (point)
                                                      (save-excursion (end-of-line) (point)))
                                if (eq (overlay-get o 'type) 'org-number)
                                return o)
                          (make-overlay (point) (+ (point) (car detail))))))
              (aset levels level lcounter)
              (loop for i from (1+ level) to 9
                    do (aset levels i 0))
              (overlay-put o 'type 'org-number)
              (overlay-put o 'evaporate t)
              (overlay-put o 'after-string
                           (let (s)
                             (loop for i across levels
                                   until (zerop i)
                                   do (setf s (if s (format "%s.%d" s i)
                                                (format " %d" i))
                                            ))
                             s)))))))))
(provide 'org-numbers-overlay)
#+END_SRC
*** Toc-org
Let's install and load the =toc-org= package after org mode is loaded. This is the
package that automatically generates an up to date table of contents for us.

#+BEGIN_SRC emacs-lisp
(use-package toc-org
  :after org
  :init (add-hook 'org-mode-hook #'toc-org-enable))
#+END_SRC

*** Org Miscellaneous Packages  
Other useful org packages

#+BEGIN_SRC emacs-lisp
  (use-package htmlize :defer t :ensure t)
  (use-package org-inlinetask :ensure nil :commands org-inlinetask-insert-task)
  ;; ignore export of headlines marked with :ignore: tag
  (use-package ox-extra
    :ensure nil
    :after org
    :config
    (ox-extras-activate '(ignore-headlines)))
#+END_SRC 
*** Org Wiki
#+begin_src emacs-lisp
(use-package org-wiki
  :recipe (org-wiki :type git :host github :repo "caiorss/org-wiki")
  :commands (org-wiki-export-html-sync org-wiki-open org-wiki-helm org-wiki-dired org-wiki-index)
  :init
  (setq  org-wiki-location "~/Dropbox/org-files/Wiki")
)
#+end_src

*** Org Version
A [[https://github.com/raxod502/radian/blob/ee92ea6cb0473bf7d20c6d381753011312ef4a52/radian-emacs/radian-org.el#L46-L112][useful hack]] to get =org-version= working. 
#+begin_src emacs-lisp 
  ;; This section is devoted to fixing the asinine version-check
  ;; handling in Org (it's not designed to handle the case where you
  ;; run straight from the Git repo, apparently). This is one of the
  ;; worse hacks I've ever had the misfortune to create in Emacs.


  ;; First we define a function to return a proper version string
  ;; based on the Git repo. (This is somewhat similar to what happens
  ;; in org-fixup.el.) We should really define a function that will
  ;; return the latest tag, as well, but this remains a FIXME for now.
  (defun radian--org-git-version ()
    "Return the abbreviated SHA for the Org Git repo."
    (let ((default-directory (concat user-emacs-directory
                                     "straight/repos/org/")))
      (if (executable-find "git")
          (with-temp-buffer
            ;; Returns the shortest prefix of the SHA for HEAD that is
            ;; unique, down to a minimum of 4 characters (see
            ;; git-rev-parse(1)).
            (call-process "git" nil '(t nil) nil
                          "rev-parse" "--short" "HEAD")
            (if (> (buffer-size) 0)
                (string-trim (buffer-string))
              ;; This shouldn't happen, unless somehow Org is not
              ;; actually a Git repo.
              "revision unknown"))
        ;; This also shouldn't happen, because how would you have
        ;; gotten Org in the first place, then? But the real world
        ;; sucks and we have to account for stuff like this.
        "git not available")))


  ;; Here we're defining `org-git-version' and `org-release' eagerly.
  ;; Pay close attention here, since we actually do this multiple
  ;; times. The control flow is really weird. The reason we define the
  ;; functions here is that Emacs includes its own copy of Org, and
  ;; these functions are autoloaded by Emacs. Now, normally the
  ;; built-in autoloads are overridden by the version of Org
  ;; downloaded from EmacsMirror, but since we're running straight
  ;; from the Git repo, `org-git-version' and `org-release' are not
  ;; generated and autoloaded. So in order to avoid the original
  ;; autoloads from being triggered under any circumstances, we have
  ;; to overwrite them here.
  (defalias #'org-git-version #'radian--org-git-version)
  (defun org-release () "9.1.3") ; FIXME: replace with a real function


  ;; Now, the culprit function is `org-check-version', which is
  ;; defined in org-compat.el and called from org.el. The problem with
  ;; this function is that if the version of Org in use is not a
  ;; release version (i.e. it's running straight from the repo, as we
  ;; are doing), then it prints a warning. We don't want this. The
  ;; natural thought is to override `org-check-version'.
  ;; Unfortunately, this is completely impossible since
  ;; `org-check-version' is a macro, and org.el (which is where the
  ;; macro is used) is byte-compiled, so the code of
  ;; `org-check-version' is hardcoded into org.elc. The easiest way
  ;; around the problem, other than doing something even more
  ;; horrifying like suppressing warnings while loading Org, seems to
  ;; be to *pretend* that org-version.el is available, even though it
  ;; doesn't exist. Then `org-check-version' happily defines
  ;; `org-git-version' and `org-release' as autoloads pointing to
  ;; org-version.el. Of course, then after Org is loaded, we have to
  ;; override those autoloads to make the functions point back to what
  ;; we want. Right now, the definition of `org-release' generated by
  ;; `org-check-version' is the same as the one used above, so we
  ;; don't bother to change it. That should change, FIXME.
  (provide 'org-version)
  (with-eval-after-load 'org
    (defalias #'org-git-version #'radian--org-git-version))
#+end_src

** Search
*** Ag
 #+BEGIN_SRC emacs-lisp
   (use-package ag
   :commands (helm-do-ag cpm/helm-files-do-ag cpm/helm-files-search-current-directory helm-do-ag-this-file helm-ag-buffers)
   :config
   (progn
     (defun ag/jump-to-result-if-only-one-match ()
       "Jump to the first ag result if that ag search came up with just one match."
       (let (only-one-match)
         (when (member "--stats" ag-arguments)
           (save-excursion
             (goto-char (point-min))
             (setq only-one-match (re-search-forward "^1 matches\\s-*$" nil :noerror)))
           (when only-one-match
             (next-error)
             (kill-buffer (current-buffer))
             (message (concat "ag: Jumping to the only found match and "
                              "killing the *ag* buffer."))))))
     (add-hook 'ag-search-finished-hook #'ag/jump-to-result-if-only-one-match)  
    
     ;; Set default ag arguments
     ;; It looks like the ~/.agignore is used when launching ag from emacs too.
     ;; So the ignores from ~/.agignore don't have to be set here again.

     (setq ag-highlight-search t)
     ;; By default, ag.el will open results in a different window in the frame, so
     ;; the results buffer is still visible. You can override this so the results
     ;; buffer is hidden and the selected result is shown in its place:
     (setq ag-reuse-window nil)
     ;; reuse the same *ag* buffer for all your searches
     (setq ag-reuse-buffers t)
     ;; ;; To save buffer automatically when `wgrep-finish-edit'
     ;; (setq wgrep-auto-save-buffer t)

     (with-eval-after-load 'projectile
       ;; Override the default function to use the projectile function instead
       (defun ag/project-root (file-path)
         (let ((proj-name (projectile-project-root)))
           (if proj-name
               proj-name ; return `projectile-project-root' if non-nil
             ;; Else condition is same as the `ag/project-root' definition
             ;; from ag.el
             (if ag-project-root-function
                 (funcall ag-project-root-function file-path)
               (or (ag/longest-string
                    (vc-git-root file-path)
                    (vc-svn-root file-path)
                    (vc-hg-root file-path))
                   file-path))))))))

 #+END_SRC
 
*** Ripgrep (rg)
 #+BEGIN_SRC emacs-lisp 
 (use-package rg 
   :commands rg)
 #+END_SRC
*** Anzu
[[https://github.com/syohex/emacs-anzu][anzu.el]] is an Emacs port of anzu.vim. anzu.el provides a minor mode which displays current match and total matches information in the mode-line in various search modes.
#+BEGIN_SRC emacs-lisp
(use-package anzu
  :commands (isearch-foward isearch-backward)
  :config (global-anzu-mode))
(use-package evil-anzu
  :commands (evil-search-forward evil-search-backward))
#+END_SRC
** Shell
*** Sane term
 Sane settings for ansi-term
 #+BEGIN_SRC emacs-lisp
   (use-package sane-term
     :commands sane-term
     :init
     ;; shell to use for sane-term
     (setq sane-term-shell-command "/usr/local/bin/zsh")
     ;; sane-term will create first term if none exist
     (setq sane-term-initial-create t)
     ;; `C-d' or `exit' will kill the term buffer.
     (setq sane-term-kill-on-exit t)
     ;; After killing a term buffer, not cycle to another.
     (setq sane-term-next-on-kill nil))
 #+END_SRC
*** Shell Pop
 A popup shell
 #+begin_src emacs-lisp 
   (use-package shell-pop
     :commands shell-pop
     :init
     (setq shell-pop-term-shell "/usr/local/bin/zsh")
     (setq shell-pop-shell-type '("eshell" "*eshell*" (lambda nil (eshell))))
     :config
       (defun ansi-term-handle-close ()
        "Close current term buffer when `exit' from term buffer."
        (when (ignore-errors (get-buffer-process (current-buffer)))
          (set-process-sentinel (get-buffer-process (current-buffer))
                                (lambda (proc change)
                                  (when (string-match "\\(finished\\|exited\\)" change)
                                    (kill-buffer (when (buffer-live-p (process-buffer proc)))
                                    (delete-window))))))
      (add-hook 'shell-pop-out-hook 'kill-this-buffer)
      (add-hook 'term-mode-hook (lambda () (nlinum-mode -1) (linum-mode -1) (ansi-term-handle-close)))))
 #+end_src
*** Shell settings
 Other useful shell settings  
 #+begin_src emacs-lisp
 ;; basic settings
 ;; (evil-set-initial-state 'term-mode 'emacs)
 (setq explicit-shell-file-name "/usr/local/bin/zsh")
 ;; don't add newline in long lines
 (setq-default term-suppress-hard-newline t)
 ;; kill process buffers without query
 (setq kill-buffer-query-functions (delq 'process-kill-buffer-query-function kill-buffer-query-functions))
 (global-set-key (kbd "C-x k") 'kill-this-buffer) 
 ;; kill ansi-buffer on exit
 (defadvice term-sentinel (around my-advice-term-sentinel (proc msg))
   (if (memq (process-status proc) '(signal exit))
       (let ((buffer (process-buffer proc)))
          ad-do-it
          (kill-buffer buffer))
         ad-do-it))
       (ad-activate 'term-sentinel)

;; clickable links & no highlight of line
(defun my-term-hook ()
  (goto-address-mode) (global-hl-line-mode 0))
(add-hook 'term-mode-hook 'my-term-hook)
    
;; paste and navigation
(defun term-send-tab ()
"Send tab in term mode."
  (interactive)
  (term-send-raw-string "\t"))

;; Emacs doesn’t handle less well, so use cat instead for the shell pager 
(setenv "PAGER" "cat")

 #+end_src
*** Compilation buffer

 Whenever I run ~compile~, the buffer stays even after a successful compilation. Let's make it close automatically if the compilation is successful.

 #+BEGIN_SRC emacs-lisp
 (setq compilation-finish-functions
       (lambda (buf str)
         (if (null (string-match ".*exited abnormally.*" str))
             ;;no errors, make the compilation window go away in a few seconds
             (progn
               (run-at-time "0.4 sec" nil
                            (lambda ()
                              (select-window (get-buffer-window (get-buffer-create "*compilation*")))
                              (switch-to-buffer nil)
                              (delete-window)))
               (message "No Compilation Errors!")))))
 #+END_SRC
*** Completion buffer
 Kill the completion buffer
 #+BEGIN_SRC emacs-lisp
   ;; Remove completion buffer when done
   (add-hook 'minibuffer-exit-hook 
   '(lambda ()
            (let ((buffer "*Completions*"))
              (and (get-buffer buffer)
               (kill-buffer buffer)))))
 #+END_SRC
*** Virtualenvwrapper
 #+BEGIN_SRC emacs-lisp
   (use-package virtualenvwrapper
     :defer 5
     :config
     (venv-initialize-interactive-shells) ;; if you want interactive shell support
     (venv-initialize-eshell) ;; if you want eshell support
     (setq venv-location "/Users/roambot/bin/virtualenvs")
     (setq venv-project-home "/Users/roambot/Dropbox/Work/projects/")
     (add-hook 'venv-postactivate-hook (lambda () (workon-venv))))

   (defcustom venv-project-home
     (expand-file-name (or (getenv "PROJECT_HOME") "/Users/roambot/Dropbox/Work/projects/"))
       "The location(s) of your virtualenv projects."
       :group 'virtualenvwrapper)

   (defun workon-venv ()
    "change directory to project in eshell"
     (eshell/cd (concat venv-project-home venv-current-name)))
 #+END_SRC
*** Tramp
An easy way to ssh
#+BEGIN_SRC emacs-lisp
(use-package tramp-term
  :commands tramp-term
)
#+END_SRC
*** Eshell
 Eshell is an [[https://www.masteringemacs.org/article/complete-guide-mastering-eshell][elisp shell]]. It has its own configuration parameters, distinct
 from those of shell or ansi-terminal.
**** Eshell Settings
 Basic settings
 #+BEGIN_SRC emacs-lisp 
   (use-package eshell
     :commands eshell
     :init
     (use-package em-cmpl    :demand t :ensure nil)
     (use-package em-prompt  :demand t :ensure nil)
     (use-package em-term    :demand t :ensure nil)
     (use-package em-alias   :demand t :ensure nil)
     (use-package em-smart   :demand t :ensure nil)
     ;; plan 9
     (setq eshell-where-to-jump 'begin)
     (setq eshell-review-quick-commands nil)
     (setq eshell-smart-space-goes-to-end t)
     (setq eshell-directory-name (concat cmacs-etc-dir "/eshell")
           eshell-history-file-name (concat cmacs-etc-dir "eshell/history")
           eshell-aliases-file (concat cmacs-etc-dir "eshell/alias")
           eshell-last-dir-ring-file-name (concat cmacs-etc-dir "eshell/lastdir")
           eshell-highlight-prompt nil
           eshell-buffer-shorthand t
           eshell-cmpl-ignore-case t
           eshell-cmpl-cycle-completions t
           eshell-destroy-buffer-when-process-dies t
           eshell-history-size 10000
           ;; auto truncate after 12k lines
           eshell-buffer-maximum-lines 12000
           eshell-hist-ignoredups t
           eshell-error-if-no-glob t
           eshell-glob-case-insensitive t
           eshell-scroll-to-bottom-on-input 'all
           eshell-scroll-to-bottom-on-output 'all
           eshell-list-files-after-cd t
           eshell-banner-message ""
           ;; eshell-banner-message (message "Emacs initialized in %.2fs \n\n" (float-time (time-subtract (current-time) my-start-time)))
           ;; eshell-banner-message "What would you like to do?\n\n"
         )
         ;; Visual commands
     (setq eshell-visual-commands '("ranger" "vi" "screen" "top" "less" "more" "lynx"
                                        "ncftp" "pine" "tin" "trn" "elm" "vim"
                                        "nmtui" "alsamixer" "htop" "el" "elinks"
                                        ))
     (setq eshell-visual-subcommands '(("git" "log" "diff" "show"))))



   (defun my/setup-eshell ()
    (interactive)
     ;; turn off semantic-mode in eshell buffers
     (semantic-mode -1)
     ;; turn off hl-line-mode
     (hl-line-mode -1))

     ;; helm support
     (add-hook 'eshell-mode-hook
          (lambda ()
            (eshell-cmpl-initialize)
            (define-key eshell-mode-map [remap eshell-pcomplete] 'helm-esh-pcomplete)
            (define-key eshell-mode-map (kbd "M-l") 'helm-eshell-history)
            (my/setup-eshell)))

         ;; (defun my/truncate-eshell-buffers ()
         ;;   "Truncates all eshell buffers"
         ;;   (interactive)
         ;;   (save-current-buffer
         ;;     (dolist (buffer (buffer-list t))
         ;;       (set-buffer buffer)
         ;;       (when (eq major-mode 'eshell-mode)
         ;;         (eshell-truncate-buffer)))))

         ;; After being idle for 5 seconds, truncate all the eshell-buffers if
         ;; needed. If this needs to be canceled, you can run `(cancel-timer
         ;; my/eshell-truncate-timer)'
         ;; (setq my/eshell-truncate-timer
         ;;       (run-with-idle-timer 5 t #'my/truncate-eshell-buffers))

         (when (not (functionp 'eshell/rgrep))
           (defun eshell/rgrep (&rest args)
             "Use Emacs grep facility instead of calling external grep."
             (eshell-grep "rgrep" args t)))

 #+END_SRC
**** CHECK Eshell Path Shortening
Courtesy of [[https://www.emacswiki.org/emacs/EshellPrompt][emacs wiki]] and [[https://github.com/kaihaosw/eshell-prompt-extras/blob/master/eshell-prompt-extras.el#L193][eshell-prompt-extras]]
#+BEGIN_SRC emacs-lisp
(defun epe-fish-path (path)
  "Return a potentially trimmed-down version of the directory PATH, replacing
parent directories with their initial characters to try to get the character
length of PATH (sans directory slashes) down to MAX-LEN."
  (let* ((components (split-string (abbreviate-file-name path) "/"))
         (max-len 30)
         (len (+ (1- (length components))
                 (cl-reduce '+ components :key 'length)))
         (str ""))
    (while (and (> len max-len)
                (cdr components))
      (setq str (concat str
                        (cond ((= 0 (length (car components))) "/")
                              ((= 1 (length (car components)))
                               (concat (car components) "/"))
                              (t
                               (if (string= "."
                                            (string (elt (car components) 0)))
                                   (concat (substring (car components) 0 2)
                                           "/")
                                 (string (elt (car components) 0) ?/)))))
            len (- len (1- (length (car components))))
            components (cdr components)))
    (concat str (cl-reduce (lambda (a b) (concat a "/" b)) components))))
#+END_SRC
**** CHECK Eshell Prompt Extras
Some bling for the prompt plus a custom theme. In general it makes the
 prompt display more useful info. I got a lot of help from looking at
 [[https://github.com/bling/dotemacs/blob/master/config/init-eshell.el][bling's eshell config]] as well as the package [[https://github.com/hiddenlotus/eshell-prompt-extras][eshell-prompt-extras]] and
 the dakrone theme.

 Note that path shortening isn't working right now. 
#+BEGIN_SRC emacs-lisp
      (use-package eshell-prompt-extras
        :after eshell
        :if (display-graphic-p)
        :requires eshell 
        :init
        (setq eshell-highlight-prompt nil
              epe-git-dirty-char "✘"
              epe-git-untracked-char "…"; "⇆" "⟀" "⟿" "⤭" 
              eshell-prompt-function 'cpm-eshell-theme)
        :config
        (defun cpm-eshell-theme ()
        "A eshell-prompt lambda theme with directory shrinking."
        (require 'all-the-icons)
        (setq eshell-prompt-regexp "^[^#\nλ]* λ[#]* ")
        (let* ((pwd-repl-home (lambda (pwd)
                                (let* ((home (expand-file-name (getenv "HOME")))
                                       (home-len (length home)))
                                  (if (and
                                       (>= (length pwd) home-len)
                                       (equal home (substring pwd 0 home-len)))
                                      (concat "~" (substring pwd home-len))
                                    pwd))))
               (shrink-paths (lambda (p-lst)
                               (if (> (length p-lst) 3) ;; shrink paths deeper than 3 dirs
                                   (concat
                                    (mapconcat (lambda (elm)
                                                 (if (zerop (length elm)) ""
                                                   (substring elm 0 1)))
                                               (butlast p-lst 3)
                                               "/")
                                    "/"
                                    (mapconcat (lambda (elm) elm)
                                               (last p-lst 3)
                                               "/"))
                                 (mapconcat (lambda (elm) elm)
                                            p-lst
                                            "/")))))
          (concat
           (epe-colorize-with-face "┌─[" 'epe-dir-face)
           (epe-colorize-with-face (all-the-icons-faicon "clock-o" :v-adjust .025 :height .75) '(foreground-color . "#839496"))
           (epe-colorize-with-face " " 'epe-dir-face)
           (epe-colorize-with-face (format-time-string "%H:%M:%S") '(foreground-color . "#839496"))
           (epe-colorize-with-face "]" 'epe-dir-face)
           (when (epe-remote-p)
           (epe-colorize-with-face "──[" 'epe-dir-face)
             (epe-colorize-with-face
              (concat (epe-remote-user) "@" (epe-remote-host) " ")
              'epe-remote-face)
              (epe-colorize-with-face "]──" 'epe-dir-face))
           (when epe-show-python-info
             (when (fboundp 'epe-venv-p)
               (when (and (epe-venv-p) venv-current-name)
                 (concat 
                   (epe-colorize-with-face "──" 'epe-dir-face)
                   (epe-colorize-with-face "(" 'epe-dir-face) 
                   ;; (propertize venv-current-name 'face `(:foreground "base01" :slant italic))
                   (epe-colorize-with-face (all-the-icons-alltheicon "python" :v-adjust .025 :height .75) 'epe-venv-face)
                   (epe-colorize-with-face " " 'epe-venv-face)
                   (epe-colorize-with-face venv-current-name 'epe-venv-face)
                   (epe-colorize-with-face ")" 'epe-dir-face))))) 
                   (epe-colorize-with-face "──" 'epe-dir-face)
           (epe-colorize-with-face "[" 'epe-dir-face)
           (epe-colorize-with-face (all-the-icons-faicon "folder-open-o" :v-adjust .025 :height .75) 'font-lock-type-face)
           (epe-colorize-with-face " " 'epe-dir-face)
           (epe-colorize-with-face (funcall
                                    shrink-paths
                                    (split-string
                                     (funcall pwd-repl-home (eshell/pwd)) "/ "))
                                   'font-lock-type-face)
           ;; (epe-colorize-with-face "]" 'epe-dir-face)

           (when (epe-git-p)
               (concat 
               (epe-colorize-with-face "]──[" 'epe-dir-face)
                 ;; (propertize "" 'face 'font-lock-string-face)
                (epe-colorize-with-face (all-the-icons-alltheicon "git" :v-adjust .025 :height .75) 'font-lock-string-face)
                 (epe-colorize-with-face " " 'font-lock-string-face)
                  (concat
                      (epe-colorize-with-face (epe-git-branch) 'font-lock-string-face)
                       (let* ((status (shell-command-to-string "git status --porcelain"))
                                   (parts (split-string status " \n" t " "))
                                   (states (mapcar #'string-to-char parts))
                                   (added (count-if (lambda (char) (= char ?A)) states))
                                   (modified (count-if (lambda (char) (= char ?M)) states))
                                   (deleted (count-if (lambda (char) (= char ?D)) states)))
                              (when (> (+ added modified deleted) 0)
                                (concat (propertize "(" 'face 'font-lock-comment-face)
                                (propertize (format "+%d/~%d/-%d" added modified deleted) 'face `(:foreground "#d33682"))
                                (propertize ")" 'face 'font-lock-comment-face))
                                ))
                       (epe-colorize-with-face (epe-git-dirty) 'font-lock-warning-face))
                       (epe-colorize-with-face 
                         (concat
                         (epe-git-untracked) 
                         (unless (= (epe-git-unpushed-number) 0)
                           (concat ":" (number-to-string (epe-git-unpushed-number)))))
                       'font-lock-comment-face))
  )
           (epe-colorize-with-face "]\n" 'epe-dir-face)
           (epe-colorize-with-face "└─ λ" 'epe-dir-face) ;; └─>  └─
           (epe-colorize-with-face (if (= (user-uid) 0) "#" "") 'epe-sudo-symbol-face)
           " ")))
    )
#+END_SRC
**** Shell Switcher
 Useful for switching between [[https://github.com/DamienCassou/shell-switcher][multiple instances]] of eshell. But you can
 configure for any shell that you use.
 #+BEGIN_SRC emacs-lisp
   (use-package shell-switcher
     :general
     ("C-'" 'shell-switcher-switch-buffer)
     ;; :init
     ;; (add-hook 'eshell-mode-hook 'shell-switcher-manually-register-shell)
     :config
     (setq shell-switcher-mode t))
 #+END_SRC
**** Clear Eshell 
 Make eshell act like a standard unix terminal.
 #+BEGIN_SRC emacs-lisp
   (defun eshell-clear-buffer ()
   "Clear terminal"
   (interactive)
   (let ((inhibit-read-only t))
     (erase-buffer)
     (eshell-send-input)))
 (add-hook 'eshell-mode-hook
       '(lambda()
           (local-set-key (kbd "C-l") 'eshell-clear-buffer)))
 #+END_SRC
**** Eshell Magit
 #+BEGIN_SRC emacs-lisp
 (defun eshell/magit ()
 "Function to open magit-status for the current directory"
   (interactive)
   (magit-status default-directory)
   nil)
 #+END_SRC
**** Eshell Fringe Status
Show [[https://github.com/ryuslash/eshell-fringe-status][last status in fringe]]
#+BEGIN_SRC emacs-lisp
(use-package eshell-fringe-status
  :defer
  :init
  (add-hook 'eshell-mode-hook 'eshell-fringe-status-mode))
#+END_SRC
** Completion
*** Yasnippet
#+BEGIN_SRC emacs-lisp
  (use-package yasnippet                
    :commands (yas-expand yas-minor-mode)
    :diminish (yas-minor-mode . " Ⓨ")
    :init
    (progn
      (add-hook 'prog-mode-hook #'yas-minor-mode)
      (add-hook 'org-mode-hook #'yas-minor-mode)
      (add-hook 'markdown-mode-hook #'yas-minor-mode)
      ;; snippet directory
      (setq yas-snippet-dirs (concat cmacs-etc-dir "snippets"))
      (unless (file-directory-p yas-snippet-dirs)
        (make-directory yas-snippet-dirs))
      ;; (add-hook 'term-mode-hook (lambda()
      ;;     (setq yas-dont-activate t)))
      )
     :config 
     (yas-reload-all))

#+END_SRC

*** Company
#+BEGIN_SRC emacs-lisp
    (use-package company
        :commands (company-mode)
        :init
        (progn
          ;; (add-hook 'after-init-hook 'global-company-mode)
          (add-hook 'prog-mode-hook 'company-mode)
          (add-hook 'org-mode-hook 'company-mode)
          (add-hook 'markdown-mode-hook 'company-mode)  
          (setq company-idle-delay 0.3
                company-minimum-prefix-length 3
                company-require-match nil
                company-dabbrev-ignore-case nil
                company-dabbrev-downcase nil))
        :config
        (progn
          ;; latex
          (add-to-list 'company-backends #'company-latex-commands)

          ;; key bindings
          (let ((map company-active-map))
            (define-key map (kbd "C-/") 'company-search-candidates)
            (define-key map (kbd "C-M-/") 'company-filter-candidates)
            (define-key map (kbd "C-d") 'company-show-doc-buffer)
            (define-key map (kbd "C-j") 'company-select-next)
            (define-key map (kbd "C-k") 'company-select-previous)
            (define-key map (kbd "C-l") 'company-complete-selection))
          ;; Nicer looking faces
          (custom-set-faces
           '(company-tooltip-common
             ((t (:inherit company-tooltip :weight bold :underline nil))))
           '(company-tooltip-common-selection
             ((t (:inherit company-tooltip-selection :weight bold :underline nil)))))
  ))
#+END_SRC
***** Helm Company
#+BEGIN_SRC emacs-lisp
(use-package helm-company
  :commands (helm-company)
  :config (company-mode))
#+END_SRC
***** Company Bibtex
#+BEGIN_SRC emacs-lisp
(use-package company-bibtex
  :after company
  :config
  (add-to-list 'company-backends #'company-bibtex)
  (setq company-bibtex-bibliography "/Users/roambot/Dropbox/Work/master.bib"))
#+END_SRC
***** Company Shell
#+BEGIN_SRC emacs-lisp
(use-package company-shell
  :after company
  :config
  (add-to-list 'company-backends #'company-shell))
#+END_SRC
***** Company Eshell
Now you can have [[http://whyarethingsthewaytheyare.com/fishlike-autosuggestions-in-eshell/][Fish-like autosuggestions]] in eshell
#+BEGIN_SRC emacs-lisp
(defun company-eshell-autosuggest-candidates (prefix)
  (let* ((history
          (delete-dups
           (mapcar (lambda (str)
                     (string-trim (substring-no-properties str)))
                   (ring-elements eshell-history-ring))))
         (most-similar (cl-find-if
                        (lambda (str)
                          (string-prefix-p prefix str))
                        history)))
    (when most-similar
      `(,most-similar))))

(defun company-eshell-autosuggest--prefix ()
  (let ((prefix
         (string-trim-left
          (buffer-substring-no-properties
           (save-excursion
             (eshell-bol))
           (save-excursion (end-of-line) (point))))))
    (if (not (string-empty-p prefix))
        prefix
      'stop)))

(defun company-eshell-autosuggest (command &optional arg &rest ignored)
  (interactive (list 'interactive))
  (cl-case command
    (interactive (company-begin-backend 'company-eshell))
    (prefix (and (eq major-mode 'eshell-mode)
                 (company-eshell-autosuggest--prefix)))
    (candidates (company-eshell-autosuggest-candidates arg))))
    
(add-hook 'eshell-mode-hook #'company-mode) ; Not needed if using global-company-mode

(defun setup-eshell-autosuggest ()
  (with-eval-after-load 'company
    (setq-local company-backends '(company-eshell-autosuggest))
    (setq-local company-frontends '(company-preview-frontend))))
#+END_SRC
***** Company Emoji
#+BEGIN_SRC emacs-lisp
(use-package company-emoji
  :after company
  :config
  (set-fontset-font t 'symbol (font-spec :family "Apple Color Emoji") nil 'prepend)
  (setq company-emoji-insert-unicode nil)
  (add-hook! (org-mode markdown-mode git-commit-mode)
    (setq-local company-backends (append '(company-emoji) company-backends))))

(use-package emoji-cheat-sheet-plus
  :bind ("C-c e" . emoji-cheat-sheet-plus-insert)
  :config
  (add-hook! (org-mode markdown-mode git-commit-mode) '(emoji-cheat-sheet-plus-display-mode)))
#+END_SRC
***** Company Web
#+BEGIN_SRC emacs-lisp
(use-package company-web
  :after company
  :config
  (with-eval-after-load 'web-mode
    (add-λ 'web-mode-hook
      (setq-local company-backends (append '(company-web-html) company-backends))))
  (with-eval-after-load 'html-mode
    (add-λ 'html-mode-hook
      (setq-local company-backends (append '(company-web-html) company-backends))))
  (with-eval-after-load 'slim-mode
    (add-λ 'slim-mode-hook
      (setq-local company-backends (append '(company-web-slim) company-backends))))
  (with-eval-after-load 'jade-mode
    (add-λ 'jade-mode-hook
      (setq-local company-backends (append '(company-web-jade) company-backends)))))
#+END_SRC
***** Auc-tex
#+BEGIN_SRC emacs-lisp
(use-package company-auctex
  :after latex-mode
 )
#+END_SRC
***** Company math
#+BEGIN_SRC emacs-lisp
(use-package company-math
  :after company
  :config
  ;; Add backends for math characters
  (add-to-list 'company-backends #'company-math-symbols-unicode)
  (add-to-list 'company-backends #'company-math-symbols-latex))
#+END_SRC
** Session & Project Management
*** Projectile
#+BEGIN_SRC emacs-lisp
  (use-package projectile
    :init
    ;; save projectile-known-projects-file in cache folder
    (setq projectile-known-projects-file
       (concat cmacs-cache-dir "projectile-bookmarks.eld"))
    (setq projectile-cache-file
       (concat cmacs-cache-dir "projectile.cache"))
    (setq projectile-enable-caching t)
    :config
    (projectile-global-mode t))

#+END_SRC
*** Perspectives
Yet another attempt to manage buffers/workspaces
#+BEGIN_SRC emacs-lisp 
  (use-package perspective
    :init
    ;; (when (not (fboundp 'make-variable-frame-local))
    ;; (defun make-variable-frame-local (variable) variable))
    (persp-mode))

    (use-package persp-projectile
      :general
      (cpm-leader1 "pv" 'hydra-persp/body)
      :config
      (require 'persp-projectile)
      (defhydra hydra-persp (:columns 4
                             :color blue)
        "Perspective"
        ("a" persp-add-buffer "Add Buffer")
        ("i" persp-import "Import")
        ("c" persp-kill "Close")
        ("n" persp-next "Next")
        ("p" persp-prev "Prev")
        ("k" persp-remove-buffer "Kill Buffer")
        ("r" persp-rename "Rename")
        ("A" persp-set-buffer "Set Buffer")
        ("s" persp-switch "Switch")
        ("C-x" persp-switch-last "Switch Last")
        ("b" persp-switch-to-buffer "Switch to Buffer")
        ("P" projectile-persp-switch-project "Switch Project")
        ("q" nil "Quit")))

    ;; (defun helm-persp-projectile-switch-project ()
    ;; (interactive)
    ;; (persp-switch (let ((temp-charset "1234567890abcdefghijklmnopqrstuvwxyz")
    ;;                     (random-string ""))
    ;;                 (dotimes (i 6 random-string)
    ;;                   (setq random-string
    ;;                         (concat
    ;;                          random-string
    ;;                          (char-to-string (elt temp-charset (random (length temp-charset)))))
    ;;                         ))
    ;;                 ))
    ;; (helm-projectile-switch-project)
    ;; (persp-rename (projectile-project-name)))
#+END_SRC
*** Eyebrowse Workspace & Window Management
Easy workspace creation and switching
#+BEGIN_SRC emacs-lisp
(use-package eyebrowse
  :config 
  (general-define-key :states '(insert normal) :keymaps 'eyebrowse-mode-map 
    "M-1" 'eyebrowse-switch-to-window-config-1
    "M-2" 'eyebrowse-switch-to-window-config-2
    "M-3" 'eyebrowse-switch-to-window-config-3
    "M-4" 'eyebrowse-switch-to-window-config-4)
  (setq eyebrowse-new-workspace t)
  (eyebrowse-mode t))  
#+END_SRC

** Version Control
 Magit is a great interface for git projects. It's much more pleasant to use than
 the standard git interface on the command line. I've set up some easy
 keybindings to access magit and related packages.

*** Magit
 #+BEGIN_SRC emacs-lisp
   (use-package magit
     :commands 
     (magit-blame-mode
      magit-commit
      magit-diff
      magit-log
      magit-status)
     :init
     (add-hook 'git-commit-mode-hook 'turn-on-flyspell)
     (setq vc-follow-symlinks t)
     :config
     ;; make magit go fullscreen
     ;; (setq magit-display-buffer-function #'magit-display-buffer-fullframe-status-v1)
     (setq magit-diff-refine-hunk 'all)
     (global-git-commit-mode t) ; use emacs as editor for git commits
     (setq magit-push-always-verify nil)
       )
 #+END_SRC

*** Evil Magit
 Evil bindings for magit
 #+BEGIN_SRC emacs-lisp
   (use-package evil-magit
     :after magit
     :config
     ;; (with-eval-after-load 'magit (require 'evil-magit))
     )

 #+END_SRC

*** Git timemachine
 #+BEGIN_SRC emacs-lisp
 (use-package git-timemachine            ; Go back in Git time
   :commands git-timemachine
 )
 #+END_SRC
 
*** Gited
Give git projects branches the dired treatment
#+BEGIN_SRC emacs-lisp
(use-package gited
  :commands (gited-list gited-list-branches))
#+END_SRC
 
*** Git gutter
Git gutter is great for giving visual feedback on changes, but it doesn't play
well with org-mode using org-indent. So I don't use it globally. 
 #+BEGIN_SRC emacs-lisp
   (use-package git-gutter-fringe
     :diminish git-gutter-mode
     :after git-gutter
     :init
     (add-hook! (markdown-mode prog-mode conf-mode) 'git-gutter-mode)
     (setq git-gutter:disabled-modes '(org-mode asm-mode image-mode)
           git-gutter:update-interval 2
           git-gutter:window-width 2)
     :config
     ;; subtle diff indicators in the fringe
     ;; places the git gutter outside the margins.
     (setq-default fringes-outside-margins t)
     ;; thin fringe bitmaps
     (define-fringe-bitmap 'git-gutter-fr:added
     [224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224]
     nil nil 'center)
     (define-fringe-bitmap 'git-gutter-fr:modified
     [224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224]
     nil nil 'center)
     (define-fringe-bitmap 'git-gutter-fr:deleted
     [0 0 0 0 0 0 0 0 0 0 0 0 0 128 192 224 240 248]
     nil nil 'center))
       
 #+END_SRC

*** Quick commits
 #+BEGIN_SRC emacs-lisp
   (defun quick-commit ()
   "make a quick commit from the mini-buffer"
   (interactive)
   (evil-ex '"!Git add % && Git commit -m '" ))
 #+END_SRC
 
** Programming
*** DISABLED Aggressive indent
#+begin_src emacs-lisp
(use-package aggressive-indent
  :config
  (global-aggressive-indent-mode 1)) 
#+end_src

*** Alignment
[[https://github.com/edkolev/evil-lion][This package]] provides gl and gL align operators: gl MOTION CHAR and right-align gL MOTION CHAR
#+BEGIN_SRC emacs-lisp
(use-package evil-lion
  :defer 10
  :config
  (evil-lion-mode))
#+END_SRC
*** Rainbow delimiters
[[https://github.com/Fanael/rainbow-delimiters][Useful package]] that will highlight delimiters such as parentheses, brackets or braces according to their depth. Each successive level is highlighted in a different color. This makes it easy to spot matching delimiters, orient yourself in the code, and tell which statements are at a given depth.
   #+BEGIN_SRC emacs-lisp
   (use-package rainbow-delimiters 
     :commands rainbow-delimiters-mode
     :init
     (add-hook 'prog-mode-hook 'rainbow-delimiters-mode))
   #+END_SRC
*** Rainbow identifiers
[[https://github.com/Fanael/rainbow-identifiers][Rainbow identifiers mode]] is an Emacs minor mode providing highlighting of identifiers based on their names. Each identifier gets a color based on a hash of its name.
#+BEGIN_SRC emacs-lisp
(use-package rainbow-identifiers
  :commands rainbow-identifiers-mode
  :init
  (add-hook 'prog-mode-hook 'rainbow-identifiers-mode))
#+END_SRC
*** Rainbow mode
[[https://github.com/emacsmirror/rainbow-mode][Colorize color names]] in buffers 
#+BEGIN_SRC emacs-lisp
(use-package rainbow-mode
  :commands rainbow-mode)
#+END_SRC 
*** Electric Pair (Autopair)
#+BEGIN_SRC emacs-lisp
(use-package electric-pair
  :ensure nil
  :commands electric-pair-mode
  :init
  (add-hook 'prog-mode-hook 'electric-pair-mode)
  (add-hook 'org-mode-hook 'electric-pair-mode)
  (add-hook 'markdown-mode-hook 'electric-pair-mode)
)
#+END_SRC
*** Languages
**** Elisp
#+BEGIN_SRC emacs-lisp 
(use-package elisp-slime-nav
  :commands elisp-slime-nav-mode
  :config
  (add-hook! (emacs-lisp-mode ielm-mode) '(elisp-slime-nav-mode)))

(use-package eldoc
  :diminish eldoc-mode
  :commands eldoc-mode)
  (add-hook 'emacs-lisp-mode-hook (lambda ()
              (setq show-trailing-whitespace t)
              (prettify-symbols-mode)
              (eldoc-mode)
              (yas-minor-mode)
              (company-mode)
              (rainbow-delimiters-mode)))
              
#+END_SRC
**** Haskell
#+BEGIN_SRC emacs-lisp
  (use-package haskell-mode
    :commands haskell-mode)
#+END_SRC
**** Html
#+BEGIN_SRC emacs-lisp
(use-package web-mode
  :commands (web-mode)
  :mode ("\\.html$" . web-mode)
  :config
  (setq web-mode-enable-auto-pairing t
        web-mode-enable-auto-expanding t
        web-mode-enable-css-colorization t
        web-mode-enable-auto-closing t
        web-mode-enable-auto-quoting t)) 
#+END_SRC
**** Lua
#+BEGIN_SRC emacs-lisp
(use-package lua-mode
  :commands lua-mode
  :init
  (dolist (pattern '("\\.lua\\'"))
  (add-to-list 'auto-mode-alist (cons pattern 'lua-mode))))
#+END_SRC
**** PHP
#+BEGIN_SRC emacs-lisp
(use-package php-mode
  :commands php-mode
  :init
  (dolist (pattern '("\\.php\\'"))
  (add-to-list 'auto-mode-alist (cons pattern 'php-mode))))
#+END_SRC
**** Shell script mode
#+BEGIN_SRC emacs-lisp
  (use-package sh-script
    :commands sh-script-mode
    :init
    (progn
      ;; Use sh-mode when opening `.zsh' files, and when opening Prezto runcoms.
      (dolist (pattern '("\\.zsh\\'"
                         "zlogin\\'"
                         "zlogout\\'"
                         "zpreztorc\\'"
                         "zprofile\\'"
                         "zshenv\\'"
                         "zshrc\\'"))
        (add-to-list 'auto-mode-alist (cons pattern 'sh-mode)))))

    (defun spacemacs//setup-shell ()
        (when (and buffer-file-name
                   (string-match-p "\\.zsh\\'" buffer-file-name))
          (sh-set-shell "zsh")))
      (add-hook 'sh-mode-hook 'spacemacs//setup-shell)
#+END_SRC
**** Yaml
#+BEGIN_SRC emacs-lisp
  (use-package yaml-mode
    :commands yaml-mode
    :config
    (add-to-list 'auto-mode-alist '("\\.yml$" . yaml-mode))
    (add-to-list 'auto-mode-alist '("\\.yaml$" . yaml-mode))
    (add-hook 'yaml-mode-hook (lambda () (run-hooks 'prog-mode-hook)))
  )
#+END_SRC
**** Vim
#+BEGIN_SRC emacs-lisp
(use-package vimrc-mode
  :commands vimrc-mode)
#+END_SRC
*** Macrostep
Interactive [[https://github.com/joddie/macrostep][macro expander]] for emacs
#+BEGIN_SRC emacs-lisp
(use-package macrostep
  :commands macrostep-expand
) 
#+END_SRC
** Research & Writing
*** Helm-Bibtex
Great for managing citations and notes
#+begin_src emacs-lisp
  (use-package helm-bibtex
    :commands helm-bibtex
    :config
    ;; Set insert citekey with markdown citekeys for org-mode
    (setq bibtex-completion-format-citation-functions
          '((org-mode    . bibtex-completion-format-citation-pandoc-citeproc)
          (latex-mode    . bibtex-completion-format-citation-cite)
          (markdown-mode . bibtex-completion-format-citation-pandoc-citeproc)
          (default       . bibtex-completion-format-citation-default)))
    (setq bibtex-completion-display-formats
          '((t . "${author:36} ${title:*} ${year:4} ${=has-pdf=:1}${=has-note=:1} ${=type=:7}")))
    ;; Set default action for helm-bibtex as inserting citation
    (helm-delete-action-from-source "Insert citation" helm-source-bibtex)
    (helm-add-action-to-source "Insert citation" 'helm-bibtex-insert-citation helm-source-bibtex 0)
    (setq bibtex-completion-pdf-symbol "⌘")
    (setq bibtex-completion-notes-symbol "✎")
    (setq bibtex-completion-notes-template-one-file
   "* ${author} (${date}): ${title} 
  :PROPERTIES:
  :INTERLEAVE_PDF: ${file}
  :Custom_ID: ${=key=}
  :END: 
  [[pdfview:${file}][file link]]
       ")
    (setq bibtex-completion-bibliography "/Users/roambot/Dropbox/Work/Master.bib" 
          bibtex-completion-library-path "/Users/roambot/Dropbox/Work/MasterLib/"
          bibtex-completion-pdf-field nil
          bibtex-completion-notes-path "/Users/Roambot/Dropbox/org-files/articles.org"
          ;; bibtex-completion-additional-search-fields '(keywords)
          bibtex-completion-notes-extension ".org"
          helm-bibtex-full-frame nil) 

  ;; Set global shortcut for calling helm-bibtex
  )
#+end_src
*** Markdown mode
**** Markdown settings
#+begin_src emacs-lisp
  (use-package markdown-mode
    :defer t
    :mode (("\\.markdown\\'" . markdown-mode)
           ("\\.md\\'"       . markdown-mode))
    :init
    ;; markdown hooks
    (add-hook 'markdown-mode-hook
          '(lambda ()
             (turn-on-auto-fill) (centered-cursor-mode) (set-fill-column 78) (flyspell-mode 1) (pandoc-mode) (hl-todo-mode)))
    (setq markdown-command "pandoc -s -N --smart --bibliography=/Users/Roambot/Dropbox/Work/Master.bib"
            markdown-enable-math t
            markdown-nested-imenu-heading-index t
            markdown-open-command "/Users/Roambot/bin/scripts/mark.sh"
            )
       ;; add keybindings to hook
     :config
     ;; remove strikout comment face
     (set-face-attribute 'markdown-comment-face nil 
     :weight 'bold :strike-through nil)
     ;; keybindings
     (map! (:map markdown-mode-map
          [remap find-file-at-point] #'markdown-follow-thing-at-point
          "s-*"      #'markdown-insert-list-item
          "s-b"      #'markdown-insert-bold
          "s-i"      #'markdown-insert-italic
          ;; "s-`"      #'+markdown/insert-del
          :m "gj"    #'markdown-next-visible-heading
          :m "gk"    #'markdown-previous-visible-heading
          ;; Assumes you have a markdown renderer plugin in chrome
          :n "M-r"   #'browse-url-of-file
          ;; TODO: Make context sensitive
          :m "]h"    #'markdown-next-visible-heading
          :m "[h"    #'markdown-previous-visible-heading
          :m "[p"    #'markdown-promote
          :m "]p"    #'markdown-demote
          :m "[l"    #'markdown-next-link
          :m "]l"    #'markdown-previous-link
          :i "M--"   #'markdown-insert-hr
          :n "TAB"   #'markdown-cycle
          :nie "M-h" #'markdown-promote
          :nie "M-j" #'markdown-move-down
          :nie "M-k" #'markdown-move-up
          :nie "M-l" #'markdown-demote

          (:localleader
            :nv "o" #'markdown-open
            :nv "b" #'markdown-preview
            (:prefix "i"
              :nv "t" #'markdown-toc-generate-toc
              :nv "i" #'markdown-insert-image
              :nv "l" #'markdown-insert-link)))))

#+end_src
**** Pandoc
Pandoc mode for markdown conversion
#+BEGIN_SRC emacs-lisp
  (use-package pandoc-mode
    :commands (run-pandoc pandoc-convert-to-pdf)
    :config
    (progn
      (defun run-pandoc ()
        "Start pandoc for the buffer and open the menu"
        (interactive)
        (pandoc-mode)
        (pandoc-main-hydra/body))
      (add-hook 'pandoc-mode-hook 'pandoc-load-default-settings)

      (defun cpm/pandoc-convert-to-pdf ()
        "convert to pdf"
        (interactive)
        (evil-ex "!pandoc -s -N -V mainfont=Optima --pdf-engine=xelatex --bibliography=/Users/Roambot/Dropbox/Work/Master.bib --template=/Users/Roambot/.pandoc/pandoc-templates/default.latex -o '%.pdf' '%'"))

      (defun pandoc-pdf-open ()
        "Open created PDF file"  
        (interactive)
        (find-file-other-window (concat (file-name-sans-extension buffer-file-name) ".pdf")))
        )
    :init
    (progn
      (setq pandoc-data-dir (concat cmacs-etc-dir "pandoc-mode/"))
      ;; help pandoc find xelatex
      (setenv "PATH" (concat (getenv "PATH") ":/Library/TeX/texbin"))))
#+END_SRC
*** Distraction free mode
This simulates programs like writeroom that provide a distraction-free
mode of writing. 
#+BEGIN_SRC emacs-lisp
(use-package writeroom-mode
  :commands (writeroom-mode)
  :config
  (setq writeroom-fullscreen-effect 'maximized)
  (setq writeroom-width 85))
    (defun distraction-free ()
    "distraction free writing"
      (interactive)
      (git-gutter-mode 0) 
      (linum-mode 0) 
      (nlinum-mode 0) 
      (centered-cursor-mode)
      (writeroom-mode)
      )

#+END_SRC
*** Deft Notes
#+BEGIN_SRC emacs-lisp
  (use-package deft
    :commands (deft deft-find-file cpm/deft)
    :init
    (progn
      ;; start in insert mode
      (add-to-list 'evil-insert-state-modes 'deft-mode)
      (setq deft-extensions '("org" "md" "txt")
            deft-directory "~/Dropbox/org-files"
            deft-text-mode 'org-mode
            deft-use-filter-string-for-filename t ;; use filter string as filename
            deft-org-mode-title-prefix t ;; add #+TITLE prefix
            deft-recursive t  ;; search recursively in folders
            deft-use-filename-as-title t)
    :config
    ;; Make sure titles have no spaces: from [[http://pragmaticemacs.com/category/deft/][pragmaticemacs]]
    ;;advise deft-new-file-named to replace spaces in file names with -
    (defun bjm-deft-strip-spaces (args)
    "Replace spaces with - in the string contained in the first element of the list args. Used to advise deft's file naming function."
    (list (replace-regexp-in-string " " "-" (car args)))
    )
    (advice-add 'deft-new-file-named :filter-args #'bjm-deft-strip-spaces)

  ;;function to run deft in specified directory
  (defun any-deft (dir)
    "Run deft in directory DIR"
    (setq deft-directory dir)
    (switch-to-buffer "*Deft*")
    (kill-this-buffer)
    (require 'org)
    (deft)
    )
  (defun big-notes ()
    "Goto main notes with deft"
    (interactive)
    (any-deft "~/Dropbox/Notes")
    (kill-this-buffer)
    (any-deft "~/Dropbox/Notes")
  )
  (defun research-notes ()
    "Goto research notes"
    (interactive)
    (any-deft "~/Dropbox/org-files/Wiki"))))
#+END_SRC
*** Interleave
[[https://github.com/rudolfochrist/interleave][Interleave]] your reading notes with the PDF.
#+BEGIN_SRC emacs-lisp
(use-package interleave
  :commands interleave)
#+END_SRC
*** Lorem ipsum
Make arbitrary blocks or sentences of text.
#+BEGIN_SRC emacs-lisp
  (use-package lorem-ipsum
    :config 
    (lorem-ipsum-use-default-bindings)
    )

#+END_SRC
*** Palimpsest mode
#+BEGIN_SRC emacs-lisp
  (use-package palimpsest
    :diminish palimpsest-mode
    :init 
    (add-hook 'markdown-mode-hook 'palimpsest-mode)
    (add-hook 'org-mode-hook 'palimpsest-mode))
#+END_SRC
*** LaTeX

#+BEGIN_SRC emacs-lisp
;; Basic settings
(use-package auctex
  :mode ("\\.tex\\'" . latex-mode)
  :commands (latex-mode LaTeX-mode plain-tex-mode)
  :init
  (progn
    (add-hook 'LaTeX-mode-hook #'LaTeX-preview-setup)
    (add-hook 'LaTeX-mode-hook #'flyspell-mode)
    (add-hook 'LaTeX-mode-hook #'turn-on-reftex)
    (setq-default TeX-engine 'xetex)
    (setq TeX-auto-save t
          TeX-parse-self t
          TeX-save-query nil
          TeX-PDF-mode t)
    (setq-default TeX-master nil)))

(use-package preview
  :ensure nil
  :after auctex
  :commands LaTeX-preview-setup
  :init
  (progn
    (setq-default preview-scale 1.4
      preview-scale-function '(lambda () (* (/ 10.0 (preview-document-pt)) preview-scale)))))

(use-package reftex
  :commands turn-on-reftex
  :init
  (progn
    (setq reftex-plug-into-AUCTeX t)))

(use-package bibtex
  :mode ("\\.bib" . bibtex-mode)
  :init
  (progn
    (setq bibtex-align-at-equal-sign t)
    (add-hook 'bibtex-mode-hook (lambda () (set-fill-column 120)))))


;; Auto-fill for LaTeX
(defun schnouki/latex-auto-fill ()
  "Turn on auto-fill for LaTeX mode."
  (turn-on-auto-fill)
  (set-fill-column 80)
  (setq default-justification 'left))
(add-hook 'LaTeX-mode-hook #'schnouki/latex-auto-fill)

;; Compilation command
(add-hook 'LaTeX-mode-hook (lambda () (setq compile-command "latexmk -pdflatex=xelatex -f -pdf %f")))

;; Prevent ispell from verifying some LaTeX commands
;; http://stat.genopole.cnrs.fr/dw/~jchiquet/fr/latex/emacslatex
(defvar schnouki/ispell-tex-skip-alists
      '("cite" "nocite"
  "includegraphics"
  "author" "affil"
  "ref" "eqref" "pageref"
  "label"))
(setq ispell-tex-skip-alists
      (list
       (append (car ispell-tex-skip-alists)
         (mapcar #'(lambda (cmd) (list (concat "\\\\" cmd) 'ispell-tex-arg-end)) schnouki/ispell-tex-skip-alists))
       (cadr ispell-tex-skip-alists)))

;; Indentation with align-current in LaTeX environments
(defvar schnouki/LaTeX-align-environments '("tabular" "tabular*"))
(add-hook 'LaTeX-mode-hook
    (lambda ()
      (require 'align)
      (setq LaTeX-indent-environment-list
      ;; For each item in the list...
      (mapcar (lambda (item)
          ;; The car is an environment
          (let ((env (car item)))
            ;; If this environment is in our list...
            (if (member env schnouki/LaTeX-align-environments)
          ;; ...then replace this item with a correct one
          (list env 'align-current)
        ;; else leave it alone
        item)))
        LaTeX-indent-environment-list))))

;; Use dvipdfmx to convert DVI files to PDF in AUCTeX
(eval-after-load 'tex
  '(add-to-list 'TeX-command-list
                '("DVI to PDF" "dvipdfmx %d" TeX-run-command t t) t))

;; SyncTeX (http://www.emacswiki.org/emacs/AUCTeX#toc19)
(defun synctex/un-urlify (fname-or-url)
  "A trivial function that replaces a prefix of file:/// with just /."
  (if (string= (substring fname-or-url 0 8) "file:///")
      (substring fname-or-url 7)
    fname-or-url))

#+END_SRC
*** Doc View Mode
#+begin_src emacs-lisp
  (use-package doc-view
      :defer t
      :init
      (fset 'doc-prev "\C-xo\C-x[\C-xo")
      (fset 'doc-next "\C-xo\C-x]\C-xo")
      (global-set-key (kbd "M-[") 'doc-prev)
      (global-set-key (kbd "M-]") 'doc-next)
      (evil-set-initial-state 'doc-view-mode 'normal)
      (evil-define-key 'normal doc-view-mode-map
        "/"  'spacemacs/doc-view-search-new-query
        "?"  'spacemacs/doc-view-search-new-query-backward
        "gg" 'doc-view-first-page
        "f"  'doc-view-autofit-mode
        "G"  'doc-view-last-page
        "gt" 'doc-view-goto-page
        "h"  'doc-view-previous-page
        "j"  'doc-view-next-line-or-next-page
        "k"  'doc-view-previous-line-or-previous-page
        "K"  'doc-view-kill-proc-and-buffer
        "l"  'doc-view-next-page
        "n"  'doc-view-search
        "N"  'doc-view-search-backward
        "-"  'doc-view-shrink
        "+"  'doc-view-enlarge
        (kbd "C-d") 'doc-view-scroll-up-or-next-page
        (kbd "C-k") 'doc-view-kill-proc
        (kbd "C-u") 'doc-view-scroll-down-or-previous-page)
      :config
      (progn
        (defun spacemacs/doc-view-search-new-query ()
          "Initiate a new query."
          (interactive)
          (doc-view-search 'newquery))

        (defun spacemacs/doc-view-search-new-query-backward ()
          "Initiate a new query."
          (interactive)
          (doc-view-search 'newquery t))

  (defcustom doc-view-autofit-timer-start 1.0
  "Initial value (seconds) for the timer that delays the fitting when
  `doc-view-autofit-fit' is called (Which is when a window
  configuration change occurs and a document needs to be fitted)."
  :type 'number
  :group 'doc-view)

  (defcustom doc-view-autofit-timer-inc 0.02
  "Value to increase (seconds) the timer (see `doc-view-autofit-timer-start')
  by, if there is another window configuration change occuring, before
  it runs out."
  :type 'number
  :group 'doc-view)

  (defcustom doc-view-autofit-default-fit 'width
  "The fitting type initially used when mode is enabled.
  Valid values are: width, height, page."
  :type 'symbol
  :group 'doc-view)

  (defvar doc-view-autofit-mode-map
  (let ((map (make-sparse-keymap)))
      (define-key map (kbd "C-c W") 'doc-view-autofit-width)
      (define-key map (kbd "C-c H") 'doc-view-autofit-height)
      (define-key map (kbd "C-c P") 'doc-view-autofit-page)
      map)
  "Keymap used by `doc-view-autofit-mode'.")

  (defun doc-view-autofit-set (type)
  "Set autofitting to TYPE for current buffer."
  (when doc-view-autofit-mode
      (setq doc-view-autofit-type type)
      (doc-view-autofit-fit)))

  (defun doc-view-autofit-width ()
  "Set autofitting to width for current buffer."
  (interactive) (doc-view-autofit-set 'width))

  (defun doc-view-autofit-height ()
  "Set autofitting to height for current buffer."
  (interactive) (doc-view-autofit-set 'height))

  (defun doc-view-autofit-page ()
  "Set autofitting to page for current buffer."
  (interactive) (doc-view-autofit-set 'page))

  (defun doc-view-autofit-fit ()
  "Fits the document in the selected window's buffer
  delayed with a timer, so multiple calls in succession
  don't cause as much overhead."
  (lexical-let
      ((window (selected-window)))
      (if (equal doc-view-autofit-timer nil)
          (setq doc-view-autofit-timer
              (run-with-timer
              doc-view-autofit-timer-start nil
              (lambda ()
                  (if (window-live-p window)
                      (save-selected-window
                      (select-window window)
                      (cancel-timer doc-view-autofit-timer)
                      (setq doc-view-autofit-timer nil)
                      (cond
                          ((equal 'width doc-view-autofit-type)
                          (doc-view-fit-width-to-window))
                          ((equal 'height doc-view-autofit-type)
                          (doc-view-fit-height-to-window))
                          ((equal 'page doc-view-autofit-type)
                          (doc-view-fit-page-to-window))))))))
      (timer-inc-time doc-view-autofit-timer doc-view-autofit-timer-inc))))

  (define-minor-mode doc-view-autofit-mode
  "Minor mode for automatic (timer based) fitting in DocView."
  :lighter " AFit" :keymap doc-view-autofit-mode-map :group 'doc-view
  (when doc-view-autofit-mode
      (set (make-local-variable 'doc-view-autofit-type)
          doc-view-autofit-default-fit)
      (set (make-local-variable 'doc-view-autofit-timer) nil)
      (add-hook 'window-configuration-change-hook
              'doc-view-autofit-fit nil t)
      (doc-view-autofit-fit))
  (when (not doc-view-autofit-mode)
      (remove-hook 'window-configuration-change-hook
                  'doc-view-autofit-fit t)
      (when doc-view-autofit-timer
      (cancel-timer doc-view-autofit-timer)
      (setq doc-view-autofit-timer nil))
      (setq doc-view-autofit-type nil)))

  (add-hook 'doc-view-mode-hook 'doc-view-autofit-mode)
  ;; reload when file changes
  (add-hook 'doc-view-mode-hook 'auto-revert-mode)
  ;; continuous scroll mode
  (setq doc-view-continuous t)
  ))
#+end_src
*** PDF-Tools
Better than doc-view, but doesn't render well on retina screens :(
#+BEGIN_SRC emacs-lisp 
    (use-package pdf-tools
      :mode (("\\.pdf$" . pdf-view-mode))
      :config
      (progn
        (pdf-tools-install)
        (evil-set-initial-state 'pdf-view-mode 'normal)
        (evil-set-initial-state 'pdf-outline-buffer-mode 'normal)
        (evil-define-key 'normal pdf-view-mode-map
            ;; Navigation
            "j"  'pdf-view-next-line-or-next-page
            "k"  'pdf-view-previous-line-or-previous-page
            "l"  'pdf-view-next-page 
            "h"  'pdf-view-previous-page
            "J"  'image-forward-hscroll
            "K"  'image-backward-hscroll
            "gg"  'pdf-view-first-page
            "G"  'pdf-view-last-page
            "gt"  'pdf-view-goto-page
            "gl"  'pdf-view-goto-label
            "u" 'pdf-view-scroll-down-or-previous-page
            "d" 'pdf-view-scroll-up-or-next-page
            "-"  'pdf-view-shrink
            "+"  'pdf-view-enlarge
            "="  'pdf-view-fit-page-to-window
            (kbd "C-u") 'pdf-view-scroll-down-or-previous-page
            (kbd "C-d") 'pdf-view-scroll-up-or-next-page
            (kbd "``")  'pdf-history-backward
            ;; Search
            "/" 'isearch-forward
            "?" 'isearch-backward
            ;; Actions
            "r"   'pdf-view-revert-buffer
            "o"   'pdf-links-action-perform
            "O"   'pdf-outline
            )
        (evil-define-key 'insert pdf-view-mode-map
            "y" 'pdf-view-kill-ring-save )

  ))      

#+END_SRC
**** Org PDF View
 For annotation and jumping to file
#+BEGIN_SRC emacs-lisp
  (use-package org-pdfview
    ;; :after org
    :commands (org-pdfview-open)
    :init
    (add-to-list 'org-file-apps 
               '("\\.pdf\\'" . (lambda (file link)
                                       (org-pdfview-open link))))
  ;;   (add-to-list 'org-file-apps '("\\.pdf\\'" . org-pdfview-open))
  ;;   (add-to-list 'org-file-apps '("\\.pdf::\\([[:digit:]]+\\)\\'" . org-pdfview-open))
   )
#+END_SRC
**** Extract annotations
#+BEGIN_SRC emacs-lisp
  (use-package pdf-tools-org 
    :ensure nil
    :commands (pdf-tools-org-export-to-org pdf-tools-org-import-from-org)
    :init
    ;; (add-to-list 'load-path "/Users/Roambot/.emacs.d/pdf-tools-org/")
)
      ;; Extracting annotations using pdf-tools
      ;; modified from https://github.com/politza/pdf-tools/pull/133 
      ;; taken from http://matt.hackinghistory.ca/2015/11/11/note-taking-with-pdf-tools/

      (defun mwp/pdf-multi-extract (sources)
      "Helper function to print highlighted text from a list of pdf's, with one org header per pdf, 
      and links back to page of highlight."
      (let (
            (output ""))
        (dolist (thispdf sources)
          (setq output (concat output (pdf-annot-markups-as-org-text thispdf nil level ))))
        (princ output))
      )

      (defun cpm/pdf-summary-extract (sources)
      "Helper function to print underlined text from a list of pdf's, with one org header per pdf, 
      and links back to page of highlight."
      (let (
            (output ""))
        (dolist (thispdf sources)
          (setq output (concat output (pdf-annot-summary-as-org-text thispdf nil level ))))
        (princ output))
      )

      ;; this is stolen from https://github.com/pinguim06/pdf-tools/commit/22629c746878f4e554d4e530306f3433d594a654
      (defun pdf-annot-edges-to-region (edges)
      "Attempt to get 4-entry region \(LEFT TOP RIGHT BOTTOM\) from several edges.
      We need this to import annotations and to get marked-up text, because annotations
      are referenced by its edges, but functions for these tasks need region."

      (let ((left0 (nth 0 (car edges)))
            (top0 (nth 1 (car edges)))
            (bottom0 (nth 3 (car edges)))
            (top1 (nth 1 (car (last edges))))
            (right1 (nth 2 (car (last edges))))
            (bottom1 (nth 3 (car (last edges))))
            (n (safe-length edges)))
        ;; we try to guess the line height to move
        ;; the region away from the boundary and
        ;; avoid double lines
        (list left0
              (+ top0 (/ (- bottom0 top0) 2))
              right1
              (- bottom1 (/ (- bottom1 top1) 2 )))))

      (defun pdf-annot-markups-as-org-text (pdfpath &optional title level)
      "Acquire highligh annotations as text, and return as org-heading"

      (interactive "fPath to PDF: ")  
      (let* ((outputstring "") ;; the text to be returned
              (title (or title (replace-regexp-in-string "-" " " (file-name-base pdfpath ))))
              (level (or level (1+ (org-current-level)))) ;; I guess if we're not in an org-buffer this will fail
              (levelstring (make-string level ?*)) ;; set headline to proper level
              (annots (sort (pdf-info-getannots nil pdfpath)  ;; get and sort all annots
                            'pdf-annot-compare-annotations)))
        ;; create the header
        (setq outputstring (concat levelstring " Quotes From " title "\n\n")) ;; create heading

        ;; extract text
        (mapc
          (lambda (annot) ;; traverse all annotations
            (if (eq 'highlight (assoc-default 'type annot))
                (let* ((page (assoc-default 'page annot))
                      ;; use pdf-annot-edges-to-region to get correct boundaries of annotation
                      (real-edges (pdf-annot-edges-to-region
                                    (pdf-annot-get annot 'markup-edges)))
                      (text (or (assoc-default 'subject annot) (assoc-default 'content annot)
                                (replace-regexp-in-string "\n" " " (pdf-info-gettext page real-edges nil pdfpath))))

                      (height (nth 1 real-edges)) ;; distance down the page
                      ;; use pdfview link directly to page number
                      (linktext (concat "[[pdfview:" pdfpath "::" (number-to-string page) 
                                        "++" (number-to-string height) "][" title  "]]" )))
                  (setq outputstring (concat outputstring text " ("
                                            linktext ", " (number-to-string page) ")\n\n"))
                  ))

            (if (eq 'text (assoc-default 'type annot))
                (let* ((page (assoc-default 'page annot))
                      ;; use pdf-annot-edges-to-region to get correct boundaries of annotation
                      (real-edges (pdf-annot-edges-to-region
                                    (pdf-annot-get annot 'markup-edges)))
                      (text (or (assoc-default 'subject annot) (assoc-default 'content annot)
                                (replace-regexp-in-string "\n" " " (pdf-info-gettext page real-edges nil pdfpath))))

                      (height (nth 1 real-edges)) ;; distance down the page
                      ;; use pdfview link directly to page number
                      (linktext (concat "[[pdfview:" pdfpath "::" (number-to-string page) 
                                        "++" (number-to-string height) "][" title  "]]" )))
                  (setq outputstring (concat outputstring text " ("
                                            linktext ", " (number-to-string page) ")\n\n"))
                  ))

              (if (eq 'underline (assoc-default 'type annot))
                  (let* ((page (assoc-default 'page annot))
                        ;; use pdf-annot-edges-to-region to get correct boundaries of highlight
                        (real-edges (pdf-annot-edges-to-region
                                      (pdf-annot-get annot 'markup-edges)))
                        (text (or (assoc-default 'subject annot) (assoc-default 'content annot)
                                  (replace-regexp-in-string "\n" " " (pdf-info-gettext page real-edges nil pdfpath))))

                        (height (nth 1 real-edges)) ;; distance down the page
                        ;; use pdfview link directly to page number
                        (linktext (concat "[[pdfview:" pdfpath "::" (number-to-string page) 
                                          "++" (number-to-string height) "][" title  "]]" )))
                    (setq outputstring (concat outputstring text " ("
                                              linktext ", " (number-to-string page) ")\n\n"))
                    ))
                  )
          annots)
        outputstring ;; return the header
        )
      )

      (defun pdf-annot-summary-as-org-text (pdfpath &optional title level)
      "Acquire underlined annotations as text, and return as org-heading"

      (interactive "fPath to PDF: ")  
      (let* ((outputstring "") ;; the text to be returned
              (title (or title (replace-regexp-in-string "-" " " (file-name-base pdfpath ))))
              (level (or level (1+ (org-current-level)))) ;; I guess if we're not in an org-buffer this will fail
              (levelstring (make-string level ?*)) ;; set headline to proper level
              (annots (sort (pdf-info-getannots nil pdfpath)  ;; get and sort all annots
                            'pdf-annot-compare-annotations)))
        ;; create the header
        (setq outputstring (concat levelstring " Summary from " title "\n\n")) ;; create heading

        ;; extract text
        (mapc
          (lambda (annot) ;; traverse all annotations
              (if (eq 'underline (assoc-default 'type annot))
                  (let* ((page (assoc-default 'page annot))
                        ;; use pdf-annot-edges-to-region to get correct boundaries of annotation
                        (real-edges (pdf-annot-edges-to-region
                                      (pdf-annot-get annot 'markup-edges)))
                        (text (or (assoc-default 'subject annot) (assoc-default 'content annot)
                                  (replace-regexp-in-string "\n" " " (pdf-info-gettext page real-edges nil pdfpath))))

                        (height (nth 1 real-edges)) ;; distance down the page
                        ;; use pdfview link directly to page number
                        (linktext (concat "[[pdfview:" pdfpath "::" (number-to-string page) 
                                          "++" (number-to-string height) "][" title  "]]" )))
                    (setq outputstring (concat outputstring text " ("
                                              linktext ", " (number-to-string page) ")\n\n"))
                    ))
                  )
          annots)
        outputstring ;; return the header
        )
      )

#+END_SRC
*** Zotero
Interface with Zotero.
#+BEGIN_SRC emacs-lisp
  (use-package zotxt
    :commands (org-zotxt-mode zotxt-easy-key-mode)
    :diminish (org-zoxt zotxt org-zotxt-mode)
    :config
    ;; (setq org-zotxt-default-search-method 'everything)
    ;; (setq zotxt-default-bibliography-style "mkbehr-short")
    ;; Activate org-zotxt-mode in org-mode buffers
    (add-hook 'org-mode-hook (lambda () (org-zotxt-mode 1)))
    ;; Activate in markdown
    (add-hook 'markdown-mode-hook (lambda () (zotxt-easykey-mode 0))))

#+END_SRC
** Private
#+BEGIN_SRC emacs-lisp
(let ((private (expand-file-name "private.el" cmacs-cache-dir))) 
  (if (file-exists-p private)
	  (load-file private)))
#+END_SRC
** Miscellaneous Packages
*** Restart emacs
#+BEGIN_SRC emacs-lisp
(use-package restart-emacs
  :commands restart-emacs)
#+END_SRC
*** Autorevert
Auto-revert buffers of changed files
#+BEGIN_SRC emacs-lisp
  (use-package autorevert                 
    :defer 10
    :ensure nil
    :init
    (global-auto-revert-mode 1)
    :config
    (progn 
      (setq auto-revert-verbose nil ; Shut up, please!
            revert-without-query '(".*") ;; disable revert query
            ;; Revert Dired buffers, too
            global-auto-revert-non-file-buffers t)))
#+END_SRC
*** Helpful (Documentation)
[[http://www.wilfred.me.uk/blog/2017/08/30/helpful-adding-contextual-help-to-emacs/][Contextual help]] for emacs
#+BEGIN_SRC emacs-lisp
(use-package helpful
  :demand t
  :config (evil-set-initial-state 'helpful-mode 'motion)
  :general (("C-h f" 'helpful-callable)
            ("C-h k" 'helpful-key)
            ("C-h v" 'helpful-variable))
  :commands (helpful-function))
#+END_SRC
*** EmacsMirror Epkg
A [[https://github.com/emacscollective/epkg][helpful package]] to search [[https://emacsmirror.net][emacsmirror]] for packages
#+BEGIN_SRC emacs-lisp
(use-package epkg
  :commands (epkg-list-packages epkg-list-matching-packages
  epkg-list-keyworded-packages)
  :config
  (evil-set-initial-state 'epkg-list-mode 'motion)
  (setq epkg-repository (concat cmacs-cache-dir "epkg-repository")))
#+END_SRC
** Post Initialization
*** Run Post Init Hook

#+BEGIN_SRC emacs-lisp
(run-hooks 'cmacs-post-init-hook)
#+END_SRC
*** Persistent Scratch
Make the content of the scratch buffer persist between settings
#+BEGIN_SRC emacs-lisp
  (use-package persistent-scratch
    :init
    (setq persistent-scratch-backup-directory (concat cmacs-cache-dir "scratch-backups"))
    (setq persistent-scratch-save-file (concat cmacs-cache-dir "persistent-scratch"))
    (setq persistent-scratch-autosave-mode 1)
    (setq persistent-scratch-autosave-interval 60)
    :config
    (ignore-errors (persistent-scratch-setup-default)))
#+END_SRC
*** Server
Start server
#+BEGIN_SRC emacs-lisp
  (use-package server
   :defer 5
   :config
    (if (display-graphic-p)
        (unless (or (daemonp) (server-running-p))
           (message "Starting server..")
           (server-start)))
    )
#+END_SRC
*** Page Breaks
Dashboard depends on this. 
#+BEGIN_SRC emacs-lisp
(use-package page-break-lines
  :diminish "")
#+END_SRC
*** Dashboard
Startup with a [[https://github.com/rakanalh/emacs-dashboard][dashboard]] listing recent files, bookmarks, and projects.
#+BEGIN_SRC emacs-lisp
  (use-package dashboard
    :demand t
    :config
    (setq dashboard-items '((agenda . 5)
                            (recents  . 5)
                            (bookmarks . 5)
                            (projects . 5)
                            (totd . 1)))
      ;; tip of the day
      (defun totd()
      (let* ((commands (loop for s being the symbols
      when (commandp s) collect s))
      (command (nth (random (length commands)) commands)))
      (insert
      (format "** Tip of the day: ** \nCommand: %s\n\n%s\n\nInvoke with:\n\n"
      (symbol-value 'command)
      (documentation command)))
      (where-is command t)))
      (defun dashboard-insert-totd (list-size) (totd)) (add-to-list
      'dashboard-item-generators '(totd . dashboard-insert-totd))

      (setq dashboard-startup-banner (concat cmacs-etc-dir "icons/128x128.png"))
      ;; Set the title
      ;; (setq dashboard-banner-logo-title "The past is a foreign country. They do things differently there. -- L.P. Hartly, The Go-Between")
      (setq dashboard-banner-logo-title (message "★ Emacs initialized in %.2fs ★" (float-time (time-subtract (current-time) my-init-el-start-time))))
      (dashboard-setup-startup-hook)
      (map! (:map dashboard-mode-map
        :ni     "TAB" 'widget-forward
        :ni     "C-i" 'widget-forward
        :ni     "backtab" 'widget-backward
        :ni     "RET" 'widget-button-press
        :ni     "down-mouse-1" 'widget-button-click
        :ni     "g" #'dashboard-insert-startupify-lists
        :ni     "a" (dashboard-insert-shortcut "a" "Agenda for today:")
        :ni     "r" (dashboard-insert-shortcut "r" "Recent Files:")
        :ni     "m" (dashboard-insert-shortcut "m" "Bookmarks:")
        :ni     "p" (dashboard-insert-shortcut "p" "Projects:"))))

#+END_SRC

