#+TITLE: Emacs Literate Configuration
#+AUTHOR: Colin McLear
#+PROPERTY: header-args :tangle yes
#+COLUMNS: %35ITEM %15NAME %35DEPENDS %15TAGS %TODO
#+TODO: FIXME TESTING | DISABLED 
#+STARTUP: overview

This is my emacs configuration file. I use [[http://orgmode.org][org-mode]] to organize it and then
"tangle" the file using [[http://orgmode.org/worg/org-contrib/babel/][org-babel]]. You can find a helpful discussion of this
method [[http://stackoverflow.com/questions/17416738/emacs-initialization-as-org-file-how-can-i-get-the-right-version-of-org-mode][here]].

I use emacs for all my academic work. The configuration tends in that
direction. It also uses [[http://www.vim.org][vim]] keybindings. I used vim (or [[https://neovim.io][neovim]]) previously. I
think vim's modal editing is the best way to use a text-editor. If you like
vim bindings but don't tend to want to think about configuring emacs, I
strongly recommend [[http://spacemacs.org][spacemacs]] or [[https://github.com/hlissner/doom-emacs][doom-emacs]] as a way of managing your
configuration. For a more traditional emacs feel there are also the
configurations of [[https://github.com/purcell/emacs.d][purcell]] and [[https://github.com/bbatsov/prelude][batsov (prelude)]] and [[https://github.com/caisah/emacs.dz][many others]]. For a
minimally sane setup you might also look at some [[https://github.com/hrs/sensible-defaults.el][sensible defaults]]. This file
is also influenced by the [[https://github.com/gilbertw1/bmacs][bmacs]] configuration of Bryan Gilbert (see also his
[[https://github.com/gilbertw1/emacs-literate-starter][literate starter kit]]) and [[https://github.com/novoid/dot-emacs][Karl Voit's]] config. Use this along with my emacs
[[https://github.com/mclear-tools/dotemacs/blob/master/init.el][init file]].

* Table of Contents                                                             :TOC_2_gh:
- [[#personal-information][Personal Information]]
- [[#directory-variables][Directory Variables]]
- [[#security][Security]]
- [[#emacs-initialization][Emacs Initialization]]
  - [[#garbage-collection][Garbage Collection]]
  - [[#byte-compilation-warnings][Byte Compilation Warnings]]
  - [[#package-settings][Package Settings]]
  - [[#use-package-settings][Use-Package Settings]]
  - [[#manually-set-load-path][Manually Set Load Path]]
  - [[#initialize-package-management][Initialize Package Management]]
  - [[#paradox-package-management][Paradox Package Management]]
  - [[#quelpa][Quelpa]]
- [[#useful-libraries][Useful Libraries]]
- [[#functions--macros][Functions & Macros]]
  - [[#useful-functions][Useful Functions]]
  - [[#doom-macros][DOOM! Macros]]
  - [[#other-macros][Other Macros]]
- [[#emacs-settings][Emacs Settings]]
  - [[#system-defaults][System Defaults]]
  - [[#backups][Backups]]
  - [[#auto-save][Auto Save]]
  - [[#custom-file][Custom file]]
  - [[#desktop-save][Desktop save]]
  - [[#macosx][Mac/OSX]]
  - [[#time-and-date-stamps][Time and Date Stamps]]
  - [[#location][Location]]
- [[#core-packages][Core Packages]]
  - [[#modal-editing][Modal Editing]]
  - [[#appearance--ui][Appearance & UI]]
  - [[#completion][Completion]]
  - [[#navigation][Navigation]]
  - [[#programming][Programming]]
  - [[#session--project-management][Session & Project Management]]
  - [[#search][Search]]
  - [[#shell][Shell]]
  - [[#version-control][Version Control]]
- [[#org-mode][Org Mode]]
  - [[#settings][Settings]]
  - [[#org-archive][Org Archive]]
  - [[#org-refile][Org Refile]]
  - [[#open-files-in-default-application][Open Files In Default Application]]
  - [[#org-agenda][Org-Agenda]]
  - [[#org-capture][Org Capture]]
  - [[#org-template-expansions][Org Template Expansions]]
  - [[#org-bullets][Org Bullets]]
  - [[#org-prettify-source-blocks][Org Prettify Source Blocks]]
  - [[#org-goto][Org-Goto]]
  - [[#org-reveal][Org-Reveal]]
  - [[#org-organization-gtd][Org Organization (GTD)]]
  - [[#org-functions][Org Functions]]
  - [[#org-rifle][Org Rifle]]
  - [[#org-download][Org-Download]]
  - [[#org-pomodoro][Org Pomodoro]]
  - [[#org-indirect-buffer][Org Indirect Buffer]]
  - [[#org-numbers-overlay][Org Numbers Overlay]]
  - [[#org-export][Org Export]]
  - [[#org-miscellaneous-packages][Org Miscellaneous Packages]]
  - [[#org-keybindings][Org Keybindings]]
- [[#research--writing][Research & Writing]]
  - [[#deft][Deft]]
  - [[#zetteldeft][Zetteldeft]]
  - [[#spelling][Spelling]]
  - [[#abbrev][Abbrev]]
  - [[#helm-bibtex][Helm-Bibtex]]
  - [[#markdown-mode][Markdown mode]]
  - [[#writeroom-distraction-free-mode][Writeroom (Distraction free mode)]]
  - [[#interleave][Interleave]]
  - [[#lorem-ipsum][Lorem ipsum]]
  - [[#palimpsest-mode][Palimpsest mode]]
  - [[#latex][LaTeX]]
  - [[#pdf-tools][PDF-Tools]]
  - [[#org-pdf-view][Org PDF View]]
  - [[#extract-annotations][Extract annotations]]
  - [[#remember][Remember]]
- [[#miscellaneous-packages][Miscellaneous Packages]]
  - [[#restart-emacs][Restart emacs]]
  - [[#autorevert][Autorevert]]
  - [[#url--request][URL & Request]]
- [[#private][Private]]
- [[#post-initialization][Post-Initialization]]
  - [[#server][Server]]
  - [[#page-breaks][Page Breaks]]
  - [[#dashboard][Dashboard]]
  - [[#startup-time][Startup time]]
- [[#test][Test]]
  - [[#ligatures][Ligatures]]
  - [[#typography][Typography]]

* Personal Information
Let's set some variables with basic user information.

#+BEGIN_SRC emacs-lisp

(setq user-full-name "Colin McLear"
      user-mail-address "mclear@fastmail.com")
      
#+END_SRC

* Directory Variables

 We're going to define a number of directories that are used throughout this
 configuration to store different types of files.

 #+BEGIN_SRC emacs-lisp
   (eval-and-compile
     (defvar cpm-emacs-dir (expand-file-name user-emacs-directory)
       "The path to the emacs.d directory.")

     (defvar cpm-local-dir (concat cpm-emacs-dir ".local/")
       "Root directory for local Emacs files. Use this as permanent
     storage for files that are safe to share across systems (if
     this config is symlinked across several computers).")

     (defvar cpm-temp-dir (concat cpm-local-dir "/temp/")
       "Directory for non-essential file storage. Used by
     `cpm-etc-dir' and `cpm-cache-dir'.")

     (defvar cpm-etc-dir (concat cpm-temp-dir "/etc/")
       "Directory for non-volatile storage. These are not deleted or
     tampored with by emacs functions. Use this for dependencies
     like servers or config files that are stable (i.e. it should be
     unlikely that you need to delete them if something goes
     wrong).")

     (defvar cpm-cache-dir (concat cpm-temp-dir "/cache/")
       "Directory for volatile storage. Use this for transient files
     that are generated on the fly like caches and temporary files.
     Anything that may need to be cleared if there are problems.")

     (defvar cpm-elisp-dir (concat cpm-local-dir "/elisp/")
       "Where personal elisp packages and scripts are stored.")


     (dolist (dir (list cpm-local-dir cpm-etc-dir cpm-cache-dir cpm-elisp-dir))
       (unless (file-directory-p dir)
     (make-directory dir t))))
 #+END_SRC

* Security 
Properly verify outgoing ssl connections.

#+BEGIN_SRC emacs-lisp
(setq gnutls-verify-error t
      tls-checktrust gnutls-verify-error
      tls-program (list "gnutls-cli --x509cafile %t -p %p %h"
                        ;; compatibility fallbacks
                        "gnutls-cli -p %p %h"
                        "openssl s_client -connect %h:%p -no_ssl2 -no_ssl3 -ign_eof")
      nsm-settings-file (expand-file-name "network-security.data" cpm-cache-dir))
#+END_SRC
 
* Emacs Initialization
** Garbage Collection 
We increase the gc-cons-threshold to a very high number to decrease the load
and compile time. We'll lower this value significantly after initialization
has completed. We don't want to keep this value too high or it will result in
long GC pauses during normal usage.

#+BEGIN_SRC emacs-lisp 
(defun cpm/config-setup-hook ()
  (eval-and-compile
  (setq gc-cons-threshold most-positive-fixnum
        gc-cons-percentage 0.6)))

(defun cpm/config-exit-hook ()
  (setq gc-cons-threshold 80000
      gc-cons-percentage 0.1))

(add-hook 'before-init-hook #'cpm/config-setup-hook)
(add-hook 'after-init-hook  #'cpm/config-exit-hook)

#+END_SRC
** Byte Compilation Warnings
Disable certain byte compiler warnings to cut down on the noise. This is a
personal choice and can be removed if you would like to see any and all byte
compiler warnings.

#+BEGIN_SRC emacs-lisp
(setq byte-compile-warnings '(not free-vars unresolved noruntime lexical make-local))
#+END_SRC
** Package Settings
We're going to set the =load-path= ourselves and avoid calling
=(package-initilize)= (for performance reasons) so we need to set
=package--init-file-ensured= to true to tell =package.el= to not automatically
call it on our behalf. Additionally we're setting =package-enable-at-startup= to
nil so that packages will not automatically be loaded for us since =use-package=
will be handling that.

#+BEGIN_SRC emacs-lisp
  (eval-and-compile
    (setq load-prefer-newer t
          package-user-dir (concat cpm-local-dir "/elpa/") 
          package--init-file-ensured t
          package-enable-at-startup nil)

    (unless (file-directory-p package-user-dir)
      (make-directory package-user-dir t)))
#+END_SRC

** Use-Package Settings
I used to tell =use-package= to always defer loading packages unless explicitly
told otherwise. This speeds up initialization significantly as many packages
are only loaded later when they are explicitly used. But it can also [[https://github.com/jwiegley/use-package#loading-packages-in-sequence][cause
problems]]. I've since revised all my defer settings. I explicitly
defer/demand, and put a lot of loading of packages off until after about 10
secs of idle. The latter means package loading stays out of my way if I'm
doing, e.g., a quick restart-and-check of something in emacs. But I still
like always-defer, as it seems to shave around .4 secs off load time. 

#+BEGIN_SRC emacs-lisp
  (setq use-package-always-defer nil
        use-package-verbose t)
#+END_SRC


** Manually Set Load Path
We're going to set the load path ourselves so that we don't have to call
=package-initialize= at runtime and incur a large performance hit. This
load-path will actually be faster than the one created by =package-initialize=
because it appends the elpa packages to the end of the load path. Otherwise
any time a builtin package was required it would have to search all of third
party paths first.

#+BEGIN_SRC emacs-lisp
  (eval-and-compile
    (setq load-path (append load-path (directory-files package-user-dir t "^[^.]" t))))
#+END_SRC

** Initialize Package Management
Next we are going to require =package.el= and add our additional package
archives, 'melpa' and 'org'. Afterwards we need to initialize our packages and
then ensure that =use-package= is installed, which we promptly install if it's
missing. Finally we load =use-package= and tell it to always install any missing
packages.

Note that this entire block is wrapped in =eval-when-compile=. The effect of
this is to perform all of the package initialization during compilation so
that when byte compiled, all of this time consuming code is skipped. This can
be done because the result of byte compiling =use-package= statements results in
the macro being fully expanded at which point =use-package= isn't actually
required any longer.

Since the code is automatically compiled during runtime, if the configuration
hasn't already been previously compiled manually then all of the package
initialization will still take place at startup.

#+BEGIN_SRC emacs-lisp
  (eval-when-compile
    (require 'package)

    (unless (assoc-default "melpa" package-archives)
      (add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/") t))
    (unless (assoc-default "gnu" package-archives)
      (add-to-list 'package-archives '("gnu" . "https://elpa.gnu.org/packages/") t))
    (unless (assoc-default "org" package-archives)
      (add-to-list 'package-archives '("org" . "https://orgmode.org/elpa/") t))
    ;; https://github.com/emacs-china/emacswiki-elpa
    (unless (assoc-default "emacswiki" package-archives)
      (add-to-list 'package-archives '("emacswiki" . "https://mirrors.tuna.tsinghua.edu.cn/elpa/emacswiki/") t))


    (package-initialize)
    (unless (package-installed-p 'use-package)
      (package-refresh-contents)
      (package-install 'use-package))
    (require 'use-package)
    (setq use-package-always-ensure t))
#+END_SRC

** Paradox Package Management
#+BEGIN_SRC emacs-lisp
(use-package paradox
  :commands (paradox-list-packages paradox-upgrade-packages)
  :config
  (add-to-list 'evil-emacs-state-modes 'paradox-menu-mode)
  (setq paradox-execute-asynchronously nil
         ;; Show all possible counts
        paradox-display-download-count t
        paradox-display-star-count t
        ;; Don't star automatically
        paradox-automatically-star nil))
#+END_SRC

** TESTING Quelpa
Get emacs packages from [[https://github.com/quelpa/quelpa#installation][anywhere]] and use with [[https://github.com/quelpa/quelpa-use-package][use-package]]
#+BEGIN_SRC emacs-lisp
  (use-package quelpa
    :ensure t
    :commands quelpa
    :init
    ;; disable checking Melpa
    (setq quelpa-update-melpa-p nil)
    ;; don't use Melpa at all
    (setq quelpa-checkout-melpa-p nil)
    ;; quelpa dir settings
    (setq quelpa-dir (concat cpm-local-dir "quelpa")))

  (use-package quelpa-use-package
    :ensure t
    :defer 5
    :config
    ;; advince for maybe installing with quelpa
    (setq quelpa-use-package-inhibit-loading-quelpa t)
    (quelpa-use-package-activate-advice))


#+END_SRC


* Useful Libraries

[[https://github.com/jwiegley/emacs-async][async]], [[https://github.com/magnars/s.el][s]], [[https://github.com/magnars/dash.el][dash]], and [[http://elpa.gnu.org/packages/cl-lib.html][cl-lib]] are libraries for asynchronous processing,
string manipulation, list manipulation and backward compatibility
respectively. The git package is also a library.

#+BEGIN_SRC emacs-lisp
  (use-package async   :defer 10)
  (use-package dash    :defer 10)
  (use-package s       :defer 10)
  (use-package f       :defer 10)
  (use-package subr-x  :defer 10 :ensure nil)
  ; lots of packages depend on these libraries
  (use-package cl-lib  :demand t :ensure nil)
  (use-package cl      :demand t :ensure nil)
#+END_SRC

* Functions & Macros
** Useful Functions 
Various useful functions and macros I've written or pilfered from others. 
*** Archive All Done Tasks
Useful function for archiving done tasks. From [[https://stackoverflow.com/a/27043756][stack overflow]].
#+BEGIN_SRC emacs-lisp
(defun cpm/org-archive-done-tasks ()
  (interactive)
  (org-map-entries
   (lambda ()
     (org-archive-subtree)
     (setq org-map-continue-from (outline-previous-heading)))
   "/DONE" 'agenda))
#+END_SRC
*** Blank Buffer New Frame
Make a blank buffer when opening a new frame. From
https://stackoverflow.com/a/25792276. I added a call to persp-mode since I
only ever want new frames to use new perspectives
#+BEGIN_SRC emacs-lisp
(defun cpm/new-buffer-new-frame ()
  "Create a new frame with a new empty buffer & turn on persp-mode."
  (interactive)
  (persp-mode 1)
  (let ((buffer (generate-new-buffer "untitled")))
    (set-buffer-major-mode buffer)
    (display-buffer buffer '(display-buffer-pop-up-frame . nil))))
#+END_SRC
*** Built-in Functions
These are useful built-in functions, but you have to enable them
#+BEGIN_SRC emacs-lisp
  (put 'erase-buffer 'disabled nil)
  (put 'downcase-region 'disabled nil)
  (put 'upcase-region 'disabled nil)
  (put 'narrow-to-region 'disabled nil)
  (put 'dired-find-alternate-file 'disabled nil)
#+END_SRC
*** Call an emacs instance
Call an emacs instance for testing
#+BEGIN_SRC emacs-lisp
  (defun cpm/call-emacs ()
    (interactive)
    (start-process "Emacs" nil
                   (executable-find "/Applications/Emacs.app/Contents/MacOS/Emacs")))
#+END_SRC
*** Clipboard to/from Buffer
#+BEGIN_SRC emacs-lisp
  ;; http://stackoverflow.com/a/10216338/4869
  (defun cpm/copy-whole-buffer-to-clipboard ()
    "Copy entire buffer to clipboard"
    (interactive)
    (clipboard-kill-ring-save (point-min) (point-max)))

  (defun cpm/copy-clipboard-to-whole-buffer ()
    "Copy clipboard and replace buffer"
    (interactive)
    (delete-region (point-min) (point-max))
    (clipboard-yank)
    (deactivate-mark))
#+END_SRC
*** Commit Config
From [[https://www.reddit.com/r/emacs/comments/9vi3pr/magit_found_a_simple_way_to_force_me_to_keep/][reddit]]
#+BEGIN_SRC emacs-lisp
(defun cpm/tangle-commit-load ()
  (interactive)
  (save-excursion
    (widen)
    (save-buffer)
    (org-babel-tangle)
    (magit-stage-modified)
    (magit-commit-create)
    (load-file user-init-file)
    (delete-other-windows)))
#+END_SRC
*** Config functions
Useful functions for calling config files
#+BEGIN_SRC emacs-lisp
  (defun goto-init.el ()
    "Open init.el file"
    (interactive)
    (find-file "~/.emacs.d/init.el"))
  (defun goto-custom.el ()
    "Open custom.el file"
    (interactive)
    (find-file "~/.emacs.d/custom.el"))
  (defun goto-config.org ()
    "Open config.org file"
    (interactive)
    (find-file "~/.emacs.d/config.org"))
  (defun cpm/compile-dotemacs ()
    "Byte compile all files in the .emacs.d base directory"
    (interactive)
    (byte-recompile-directory cpm-emacs-dir 0 t))
  (defun load-config ()
    "Load config "
    (interactive)
    (cpm/tangle-emacs-config)
    (load-file "~/.emacs.d/init.el"))
  (defun goto-dotfiles.org ()
    "Open dotfiles.org file"
    (interactive)
    (find-file "~/dotfiles/dotfiles.org"))
  (defun goto-emacs-dir ()
    "Open dotfiles.org file"
    (interactive)
    (require 'ranger)
     (find-file "~/.emacs.d"))
  (defun goto-org-files ()
    "Open directory with org files"
    (interactive)
    (require 'ranger)
    (find-file org-directory))
  (defun goto-pandoc-config ()
    "open pandoc metadata file"
    (interactive)
    (find-file "~/.pandoc/metadata.yml"))


#+END_SRC
*** Copy formatted org-mode text to rtf
Via the always resourceful [[http://kitchingroup.cheme.cmu.edu/blog/2016/06/16/Copy-formatted-org-mode-text-from-Emacs-to-other-applications/][John Kitchin]].
#+BEGIN_SRC emacs-lisp
  (defun formatted-copy ()
  "Export region to HTML, and copy it to the clipboard."
  (interactive)
  (save-window-excursion
    (let* ((buf (org-export-to-buffer 'html "*Formatted Copy*" nil nil t t))
           (html (with-current-buffer buf (buffer-string))))
      (with-current-buffer buf
        (shell-command-on-region
         (point-min)
         (point-max)
         "textutil -stdin -format html -convert rtf -stdout | pbcopy")) 
      (kill-buffer buf))))

(global-set-key (kbd "H-w") 'formatted-copy)

#+END_SRC
*** Crux
A collection of ridiculously useful extensions. Indeed.
#+BEGIN_SRC emacs-lisp
(use-package crux :defer 10)
#+END_SRC
*** FIXME Cycle Through Useful Buffers
From a [[http://ergoemacs.org/emacs/elisp_next_prev_user_buffer.html][useful post]] by Xah. 
#+BEGIN_SRC emacs-lisp
(defun cpm/user-buffer-q ()
  "Return t if current buffer is a user buffer, else nil.
Typically, if buffer name starts with *, it's not considered a user buffer.
This function is used by buffer switching command and close buffer command, so that next buffer shown is a user buffer.
You can override this function to get your idea of “user buffer”.
version 2016-06-18"
  (interactive)
  (if (string-equal "*" (substring (buffer-name) 0 1))
      nil
    (if (string-equal major-mode "dired-mode")
        nil
      t
      )))

(defun cpm/next-user-buffer ()
  "Switch to the next user buffer.
“user buffer” is determined by `cpm/user-buffer-q'.
URL `http://ergoemacs.org/emacs/elisp_next_prev_user_buffer.html'
Version 2016-06-19"
  (interactive)
  (next-buffer)
  (let ((i 0))
    (while (< i 20)
      (if (not (cpm/user-buffer-q))
          (progn (next-buffer)
                 (setq i (1+ i)))
        (progn (setq i 100))))))

(defun cpm/previous-user-buffer ()
  "Switch to the previous user buffer.
“user buffer” is determined by `cpm/user-buffer-q'.
URL `http://ergoemacs.org/emacs/elisp_next_prev_user_buffer.html'
Version 2016-06-19"
  (interactive)
  (previous-buffer)
  (let ((i 0))
    (while (< i 20)
      (if (not (cpm/user-buffer-q))
          (progn (previous-buffer)
                 (setq i (1+ i)))
        (progn (setq i 100))))))
#+END_SRC
*** Delete Current File
#+BEGIN_SRC emacs-lisp
  ;; from magnars
  (defun cpm/delete-current-buffer-file ()
    "Removes file connected to current buffer and kills buffer."
    (interactive)
    (let ((filename (buffer-file-name))
          (buffer (current-buffer))
          (name (buffer-name)))
      (if (not (and filename (file-exists-p filename)))
          (ido-kill-buffer)
        (when (yes-or-no-p "Are you sure you want to delete this file? ")
          (delete-file filename t)
          (kill-buffer buffer)
          (message "File '%s' successfully removed" filename)))))
#+END_SRC
*** Delete Dotemacs Byte Files
#+BEGIN_SRC emacs-lisp
(defun cpm/delete-byte-compiled-files ()
  (interactive)
  (shell-command-to-string "trash ~/.emacs.d/*.elc"))
#+END_SRC
*** Duplicate file
Duplicate a file in dired or deer
#+BEGIN_SRC emacs-lisp
(defun cpm/duplicate-file ()
  (interactive)
  (dired-do-copy-regexp "\\(.*\\)\\.\\(.*\\)" "\\1 (copy).\\2"))
#+END_SRC
*** Escape all the Things!!
From a [[https://juanjoalvarez.net/en/detail/2014/sep/19/vim-emacsevil-chaotic-migration-guide/][great vim migration guide]] by Juanjo Álvarez (original code from [[https://github.com/davvil/.emacs.d/blob/master/init.el][davvil]]). 
#+BEGIN_SRC emacs-lisp
;; esc quits
(defun minibuffer-keyboard-quit ()
  "Abort recursive edit.
In Delete Selection mode, if the mark is active, just deactivate it;
then it takes a second \\[keyboard-quit] to abort the minibuffer."
  (interactive)
  (if (and delete-selection-mode transient-mark-mode mark-active)
      (setq deactivate-mark  t)
    (when (get-buffer "*Completions*") (delete-windows-on "*Completions*"))
    (abort-recursive-edit)))
(with-eval-after-load 'evil
(define-key evil-normal-state-map [escape] 'keyboard-quit)
(define-key evil-visual-state-map [escape] 'keyboard-quit)
(define-key minibuffer-local-map [escape] 'minibuffer-keyboard-quit)
(define-key minibuffer-local-ns-map [escape] 'minibuffer-keyboard-quit)
(define-key minibuffer-local-completion-map [escape] 'minibuffer-keyboard-quit)
(define-key minibuffer-local-must-match-map [escape] 'minibuffer-keyboard-quit)
(define-key minibuffer-local-isearch-map [escape] 'minibuffer-keyboard-quit)
(global-set-key [escape] 'evil-exit-emacs-state))
#+END_SRC
*** Eval emacs buffer until error
#+BEGIN_SRC emacs-lisp
  (defun cpm/eval-buffer-until-error ()
  "Evaluate emacs buffer until error occured."
  (interactive)
  (goto-char (point-min))
  (while t (eval (read (current-buffer)))))
#+END_SRC
*** Fill/Unfill Paragraphs
Artur Malabarba has a [[http://endlessparentheses.com/fill-and-unfill-paragraphs-with-a-single-key.html][useful discussion]] of how to fill/unfill
paragraphs with the same command.
#+BEGIN_SRC emacs-lisp
(defun cpm/fill-or-unfill ()
  "Like `fill-paragraph', but unfill if used twice."
  (interactive)
  (let ((fill-column
         (if (eq last-command 'cpm/fill-or-unfill)
             (progn (setq this-command nil)
                    (point-max))
           fill-column)))
    (call-interactively #'fill-paragraph)))

(global-set-key [remap fill-paragraph]
                #'cpm/fill-or-unfill)
                
;;; Stefan Monnier <foo at acm.org>. It is the opposite of fill-paragraph    
(defun unfill-paragraph (&optional region)
  "Takes a multi-line paragraph and makes it into a single line of text."
  (interactive (progn (barf-if-buffer-read-only) '(t)))
  (let ((fill-column (point-max))
        ;; This would override `fill-column' if it's an integer.
        (emacs-lisp-docstring-fill-column t))
    (fill-paragraph nil region)))
#+END_SRC
*** Goto journal 
#+BEGIN_SRC emacs-lisp
  (defun cpm/goto-journal ()
    (interactive)
    (find-file "/Users/Roambot/Dropbox/org-files/journal.org"))
#+END_SRC
*** Insert Seconds (Epoch) Time Stamp
#+BEGIN_SRC emacs-lisp
(defun cpm/insert-seconds-epoch ()
  (interactive)
  (insert (format-time-string "%s"))) ; the integer number of seconds since the epoch
(global-set-key (kbd "C-c t") 'cpm/insert-seconds-epoch)
#+END_SRC

*** Jump in buffer
I got the inspiration for this from the [[https://github.com/syl20bnr/spacemacs/blob/5f26b82e1abdde81cdf7cd17ba06f64db2343667/layers/%2Bdistribution/spacemacs-base/funcs.el][spacemacs config]]. Useful for
navigating in tagged buffers.
#+BEGIN_SRC emacs-lisp
(defun cpm/jump-in-buffer ()
  (interactive)
    (cond
     ((eq major-mode 'org-mode)
      (call-interactively 'counsel-org-goto))
     (t
      (call-interactively 'helm-semantic-or-imenu))))
      
;; resume last jump
(defun cpm/resume-last-jump ()
  (interactive)
    (cond
     ((eq major-mode 'org-mode)
      (call-interactively 'ivy-resume))
     (t
      (call-interactively 'helm-resume))))
#+END_SRC

*** Jump to sexp
#+BEGIN_SRC emacs-lisp
(defun cpm/forward-or-backward-sexp (&optional arg)
  "Go to the matching parenthesis character if one is adjacent to point."
  (interactive "^p")
  (cond ((looking-at "\\s(") (forward-sexp arg))
        ((looking-back "\\s)" 1) (backward-sexp arg))
        ;; Now, try to succeed from inside of a bracket
        ((looking-at "\\s)") (forward-char) (backward-sexp arg))
        ((looking-back "\\s(" 1) (backward-char) (forward-sexp arg))))
#+END_SRC

*** Kill current buffer
=(kill-this-buffer)= is unreliable when not invoked from the menubar. So here's a
wrapper on =(kill-buffer)= to kill the current buffer. This is sometimes better than
=(evil-delete-buffer)= since it keeps the window.
#+begin_src emacs-lisp
  (defun cpm/kill-this-buffer ()
    (interactive)
    (kill-buffer))
#+end_src
*** Make move
#+BEGIN_SRC emacs-lisp
(defun cpm/make-move ()
  "move files to project web directory"
   (interactive)
   (evil-ex "!make move"))
#+END_SRC
*** Make parent directory
 Create a directory – or a hierarchy of them – while finding a file in a
 nonexistent directory. From [[http://mbork.pl/2016-07-25_Making_directories_on_the_fly][mbork]]. 
#+BEGIN_SRC emacs-lisp
  (defun make-parent-directory ()
    "Make sure the directory of `buffer-file-name' exists."
    (make-directory (file-name-directory buffer-file-name) t))

  (add-hook 'find-file-not-found-functions #'make-parent-directory)
#+END_SRC
*** Move File
#+BEGIN_SRC emacs-lisp
(defun cpm/move-file ()
  "Write this file to a new location, and delete the old one."
  (interactive)
  (let ((old-location (buffer-file-name)))
    (call-interactively #'write-file)
    (when old-location
      (delete-file old-location))))
#+END_SRC
*** Narrow or Widen
Narrow a region, or if narrowed, widen. Courtesy of the ever
resourceful [[http://endlessparentheses.com/emacs-narrow-or-widen-dwim.html][Artur Malabarba]].
#+BEGIN_SRC emacs-lisp
(defun cpm/narrow-or-widen-dwim (p)
  "Widen if buffer is narrowed, narrow-dwim otherwise.
Dwim means: region, org-src-block, org-subtree, or
defun, whichever applies first. Narrowing to
org-src-block actually calls `org-edit-src-code'.

With prefix P, don't widen, just narrow even if buffer
is already narrowed."
  (interactive "P")
  (declare (interactive-only))
  (cond ((and (buffer-narrowed-p) (not p)) (widen))
        ((region-active-p)
         (narrow-to-region (region-beginning)
                           (region-end)))
        ((derived-mode-p 'org-mode)
         ;; `org-edit-src-code' is not a real narrowing
         ;; command. Remove this first conditional if
         ;; you don't want it.
         (cond ((ignore-errors (org-edit-src-code) t)
                (delete-other-windows))
               ((ignore-errors (org-narrow-to-block) t))
               (t (org-narrow-to-subtree))))
        ((derived-mode-p 'latex-mode)
         (LaTeX-narrow-to-environment))
        (t (narrow-to-defun))))


#+END_SRC
*** New Git Project
Courtesy of a helpful [[https://www.reddit.com/r/emacs/comments/70ke5w/help_fix_my_workflow_to_create_a_new_gitmanaged/][reddit post]]
#+BEGIN_SRC emacs-lisp
(defun cpm/git-new-project ()
  "Initializes a new git repo and adds it to projectile's known projects."
  (interactive)
  (let ((project-dir (expand-file-name
                      (read-directory-name "New project root:"))))
    (magit-init project-dir)
    (projectile-add-known-project project-dir)
    (setq default-directory project-dir)))
#+END_SRC
*** Open projects directory
#+BEGIN_SRC emacs-lisp
  (defun cpm/goto-projects ()
      "Open projects dir"
      (interactive)
      (find-file "~/Dropbox/Work/projects"))

#+END_SRC
*** Open in iTerm
#+begin_src emacs-lisp
(defun open-dir-in-iterm ()
  "Open the current directory of the buffer in iTerm."
  (interactive)
  (let* ((iterm-app-path "/Applications/iTerm.app")
         (iterm-brew-path "/opt/homebrew-cask/Caskroom/iterm2/2.1.4/iTerm.app")
         (iterm-path (if (file-directory-p iterm-app-path)
                         iterm-app-path
                       iterm-brew-path)))
    (shell-command (concat "open -a " iterm-path " ."))))
    (global-set-key (kbd "C-x t") 'open-dir-in-iterm)

;; Not going to use these commands
(put 'ns-print-buffer 'disabled t)
(put 'suspend-frame 'disabled t)

#+end_src
*** Org Tree to File
Send an org tree to its own file. Inspiration from [[https://superuser.com/a/659823][this]] superuser answer.
#+begin_src emacs-lisp
(defun cpm/subtree-to-new-file ()
  (interactive)
  "Move an org subtree to a new file"
  (org-copy-subtree nil t)
  (find-file-other-window  
    (read-file-name "Move subtree to file:" "$HOME"))
(org-paste-subtree))
#+end_src
*** Org wrap in block template
A helpful function I found [[http://pragmaticemacs.com/emacs/wrap-text-in-an-org-mode-block/][here]] for wrapping text in a block template. 
#+begin_src emacs-lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; function to wrap blocks of text in org templates                       ;;
;; e.g. latex or src etc                                                  ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun org-block-wrap ()
  "Make a template at point."
  (interactive)
  (if (org-at-table-p)
      (call-interactively 'org-table-rotate-recalc-marks)
    (let* ((choices '(
                      ("a" . "ASCII")
                      ("c" . "COMMENT")
                      ("C" . "CENTER")
                      ("e" . "EXAMPLE")
                      ("E" . "SRC emacs-lisp")
                      ("h" . "HTML")
                      ("l" . "LaTeX")
                      ("n" . "NOTES")
                      ("q" . "QUOTE")
                      ("s" . "SRC")
                      ("v" . "VERSE")
                      ))
           (key
            (key-description
             (vector
              (read-key
               (concat (propertize "Template type: " 'face 'minibuffer-prompt)
                       (mapconcat (lambda (choice)
                                    (concat (propertize (car choice) 'face 'font-lock-type-face)
                                            ": "
                                            (cdr choice)))
                                  choices
                                  ", ")))))))
      (let ((result (assoc key choices)))
        (when result
          (let ((choice (cdr result)))
            (cond
             ((region-active-p)
              (let ((start (region-beginning))
                    (end (region-end)))
                (goto-char end)
                (insert "#+END_" choice "\n")
                (goto-char start)
                (insert "#+BEGIN_" choice "\n")))
             (t
              (insert "#+BEGIN_" choice "\n")
              (save-excursion (insert "#+END_" choice))))))))))

#+end_src
*** Pandoc conversion from clipboard
#+BEGIN_SRC emacs-lisp
  (defun cpm/org-to-markdown ()
    "convert clipboard contents from org to markdown and paste"
    (interactive)
    (kill-new (shell-command-to-string "pbpaste | pandoc --atx-headers -f org -t markdown"))
    (yank))

  (defun cpm/markdown-to-org ()
    "convert clipboard contents from markdown to org and paste"
    (interactive)
    (kill-new (shell-command-to-string "pbpaste | pandoc -f markdown -t org"))
    (yank))

  (defun cpm/tex-to-org ()
    "convert clipboard contents from markdown to org and paste"
    (interactive)
    (kill-new (shell-command-to-string "pbpaste | pandoc -f latex -t org"))
    (yank))
    
  (defun cpm/org-to-tex ()
   "convert clipboard contents from org to tex and paste"
   (interactive)
   (kill-new (shell-command-to-string "pbpaste | pandoc -f org -t latex"))
   (yank))

  (defun cpm/tex-to-markdown ()
    "convert clipboard contents from markdown to org and paste"
    (interactive)
    (kill-new (shell-command-to-string "pbpaste | pandoc -f latex -t markdown --atx-headers"))
    (yank))
    
  (defun cpm/markdown-to-tex ()
    "convert clipboard contents from markdown to org and paste"
    (interactive)
    (kill-new (shell-command-to-string "pbpaste | pandoc -f markdown -t latex"))
    (yank))

  (defun cpm/cite-to-org ()
    "convert clipboard contents from markdown to org with citations and paste"
    (interactive)
    (kill-new (shell-command-to-string "pbpaste | pandoc --bibliography=/Users/Roambot/Dropbox/Work/Master.bib -s -t markdown-native_divs-raw_html-citations | pandoc -f markdown -t org"))
    (yank))

  (defun cpm/cite-to-markdown ()
    "convert clipboard contents to markdown with citations and paste"
    (interactive)
    (kill-new (shell-command-to-string "pbpaste | pandoc --bibliography=/Users/Roambot/Dropbox/Work/bibfile.bib -s -t markdown-native_divs-raw_html-citations --atx-headers"))
    (yank))


#+END_SRC
*** Projectile Find File Other Window
Find a file in a project and open in a vertical split
#+BEGIN_SRC emacs-lisp
  (defun cpm/helm-projectile-find-file-other-window ()
   "Find a file in a project and open in a vertical split"
   (interactive)
   (cpm/split-window-right-and-focus)
   (helm-projectile-find-file))

#+END_SRC
*** Resume last search
#+BEGIN_SRC emacs-lisp
  (defun cpm/last-search-buffer ()
        "open last helm-ag or hgrep buffer."
        (interactive)
        (cond ((get-buffer "*helm ag results*")
               (switch-to-buffer-other-window "*helm ag results*"))
              ((get-buffer "*helm-ag*")
               (helm-resume "*helm-ag*"))
              ((get-buffer "*hgrep*")
               (switch-to-buffer-other-window "*hgrep*"))
              ((get-buffer "*helm occur*")
               (helm-resume "*helm occur*"))
              (t
               (message "No previous search buffer found"))))
#+END_SRC
*** Reveal in Finder
#+BEGIN_SRC emacs-lisp
(defun cpm/browse-file-directory ()
  "Open the current file's directory however the OS would."
  (interactive)
  (if default-directory
      (browse-url-of-file (expand-file-name default-directory))
    (error "No `default-directory' to open")))
#+END_SRC
*** Reveal to PDF
#+BEGIN_SRC emacs-lisp
  (defun cpm/reveal-to-pdf ()
    "print reveal.js slides to pdf"
    (interactive)
    (async-shell-command "phantomjs ~/bin/print-pdf.js 'file:///Users/roambot/Dropbox/Work/projects/phil105/phil105-classplan.html?print-pdf'")
    (delete-windows-on "*Async Shell Command*" t))
#+END_SRC
*** Rotate windows
#+BEGIN_SRC emacs-lisp
;; from magnars modified by ffevotte for dedicated windows support
(defun cpm/rotate-windows (count)
  "Rotate your windows.
Dedicated windows are left untouched. Giving a negative prefix
argument takes the kindows rotate backwards."
  (interactive "p")
  (let* ((non-dedicated-windows (remove-if 'window-dedicated-p (window-list)))
         (num-windows (length non-dedicated-windows))
         (i 0)
         (step (+ num-windows count)))
    (cond ((not (> num-windows 1))
           (message "You can't rotate a single window!"))
          (t
           (dotimes (counter (- num-windows 1))
             (let* ((next-i (% (+ step i) num-windows))

                    (w1 (elt non-dedicated-windows i))
                    (w2 (elt non-dedicated-windows next-i))

                    (b1 (window-buffer w1))
                    (b2 (window-buffer w2))

                    (s1 (window-start w1))
                    (s2 (window-start w2)))
               (set-window-buffer w1 b2)
               (set-window-buffer w2 b1)
               (set-window-start w1 s2)
               (set-window-start w2 s1)
               (setq i next-i)))))))

(defun cpm/rotate-windows-backward (count)
  "Rotate your windows backward."
  (interactive "p")
  (rotate-windows (* -1 count)))
#+END_SRC
*** Search directories with ag
#+BEGIN_SRC emacs-lisp
(defun cpm/helm-files-do-ag (&optional dir)
  "Search in files with `ag' using a default input."
    (interactive)
    (helm-do-ag dir))
        
(defun cpm/helm-files-search-current-directory ()
  "search in files with `ag' in current buffer's directory"
    (interactive)
    (helm-do-ag (file-name-directory buffer-file-name)))
#+END_SRC
*** Show Filename of Buffer
#+BEGIN_SRC emacs-lisp
  ;; http://camdez.com/blog/2013/11/14/emacs-show-buffer-file-name/
  (defun cpm/show-and-copy-buffer-filename ()
    "Show the full path to the current file in the minibuffer."
    (interactive)
    (let ((file-name (buffer-file-name)))
      (if file-name
          (progn
            (message file-name)
            (kill-new file-name))
        (error "Buffer not visiting a file"))))
#+END_SRC
*** Show Next Spelling Error
Go to the next spelling error using flyspell and ispell. From the [[https://www.emacswiki.org/emacs/FlySpell#toc3][Wiki]]. 
#+BEGIN_SRC emacs-lisp
(defun cpm/flyspell-ispell-goto-next-error ()
  "Custom function to spell check next highlighted word"
  (interactive)
  (flyspell-goto-next-error)
  (ispell-word)
  )
#+END_SRC
*** Smart Yanking
Courtesy of [[http://mbork.pl/2018-07-02_Smart_yanking][Marcin Borkowski]]
#+BEGIN_SRC emacs-lisp
(defun has-space-at-boundary-p (string)
  "Check whether STRING has any whitespace on the boundary.
Return 'left, 'right, 'both or nil."
  (let ((result nil))
    (when (string-match-p "^[[:space:]]+" string)
      (setq result 'left))
    (when (string-match-p "[[:space:]]+$" string)
      (if (eq result 'left)
	  (setq result 'both)
	(setq result 'right)))
    result))

(defun is-there-space-around-point-p ()
  "Check whether there is whitespace around point.
Return 'left, 'right, 'both or nil."
  (let ((result nil))
    (when (< (save-excursion
               (skip-chars-backward "[:space:]"))
             0)
      (setq result 'left))
    (when (> (save-excursion
               (skip-chars-forward "[:space:]"))
             0)
      (if (eq result 'left)
	  (setq result 'both)
	(setq result 'right)))
    result))

(defun set-point-before-yanking (string)
  "Put point in the appropriate place before yanking STRING."
  (let ((space-in-yanked-string (has-space-at-boundary-p string))
	(space-at-point (is-there-space-around-point-p)))
    (cond ((and (eq space-in-yanked-string 'left)
		(eq space-at-point 'left))
	   (skip-chars-backward "[:space:]"))
	  ((and (eq space-in-yanked-string 'right)
		(eq space-at-point 'right))
	   (skip-chars-forward "[:space:]")))))

(defun set-point-before-yanking-if-in-text-mode (string)
  "Invoke `set-point-before-yanking' in text modes."
  (when (derived-mode-p 'text-mode)
    (set-point-before-yanking string)))

(advice-add
 'insert-for-yank
 :before
 #'set-point-before-yanking-if-in-text-mode)
#+END_SRC
*** Sticky Buffer/Window
Stick/Lock buffer to window, courtesy of [[https://gist.github.com/ShingoFukuyama/8797743][ShingoFukuyama]].
#+BEGIN_SRC emacs-lisp
;; http://lists.gnu.org/archive/html/help-gnu-emacs/2007-05/msg00975.html

(defvar sticky-buffer-previous-header-line-format)
(define-minor-mode sticky-buffer-mode
  "Make the current window always display this buffer."
  nil " sticky" nil
  (if sticky-buffer-mode
      (progn
        (set (make-local-variable 'sticky-buffer-previous-header-line-format)
             header-line-format)
        (set-window-dedicated-p (selected-window) sticky-buffer-mode))
    (set-window-dedicated-p (selected-window) sticky-buffer-mode)
    (setq header-line-format sticky-buffer-previous-header-line-format)))
#+END_SRC
*** Swap windows
Swap buffers in windows and leave the cursor in the original window.
Courtesy of Mike Zamansky's [[http://cestlaz.github.io/posts/using-emacs-36-touch-of-elisp/#.WX5Wg0czpcx][video]].
#+BEGIN_SRC emacs-lisp
(defun cpm/window-exchange ()
"Swap buffer windows and leave focus in original window"
(interactive)
(ace-swap-window)
(aw-flip-window)
)
#+END_SRC 
*** Switch to previous buffer
#+BEGIN_SRC emacs-lisp
  (defun switch-to-previous-buffer ()
    (interactive)
    (switch-to-buffer (other-buffer (current-buffer) 1)))
#+END_SRC
*** Tangle file on save
#+BEGIN_SRC emacs-lisp
  (defun cpm/tangle-emacs-config ()
    "If the current file is in '~/.emacs.d/', the code blocks are tangled"
    (interactive)
    (when (equal (file-name-directory (directory-file-name buffer-file-name))
                 (concat (getenv "HOME") "/.emacs.d/"))
      (org-babel-tangle)
      (message "%s tangled" buffer-file-name)))

  ;; (add-hook 'after-save-hook #'cpm/tangle-emacs-config)
#+END_SRC
*** Toggle Window Split
Move from a horizontal to a vertical split and vice versa
#+BEGIN_SRC emacs-lisp
(defun cpm/toggle-window-split ()
  (interactive)
  (if (= (count-windows) 2)
      (let* ((this-win-buffer (window-buffer))
         (next-win-buffer (window-buffer (next-window)))
         (this-win-edges (window-edges (selected-window)))
         (next-win-edges (window-edges (next-window)))
         (this-win-2nd (not (and (<= (car this-win-edges)
                     (car next-win-edges))
                     (<= (cadr this-win-edges)
                     (cadr next-win-edges)))))
         (splitter
          (if (= (car this-win-edges)
             (car (window-edges (next-window))))
          'split-window-horizontally
        'split-window-vertically)))
    (delete-other-windows)
    (let ((first-win (selected-window)))
      (funcall splitter)
      (if this-win-2nd (other-window 1))
      (set-window-buffer (selected-window) this-win-buffer)
      (set-window-buffer (next-window) next-win-buffer)
      (select-window first-win)
      (if this-win-2nd (other-window 1))))))

#+END_SRC
*** Toggle Markup Display
Toggle the display of markup in markdown and org modes
#+BEGIN_SRC emacs-lisp
  (defun cpm/toggle-display-markup ()
    (interactive)
      (if (eq major-mode 'org-mode)
          (org-toggle-link-display)
          (if markdown-hide-markup
          (markdown-toggle-markup-hiding 0)
          (markdown-toggle-markup-hiding))))
#+END_SRC
*** Search TODO Markers
Make an equivalent of vim's quickfix buffer using [[git:~/.emacs.d/config.org::master@{2018-02-18}::3795][helm-ag]] and [[git:~/.emacs.d/config.org::master@{2018-02-18}::2947][highlight-todo]]
#+BEGIN_SRC emacs-lisp
(defun cpm/search-file-todo-markers ()
    "Search for any TODO markers as specified in hl-todo-keyword-faces.

Note that this uses the word boundary \\b to avoid matching these
within other words, but this means that non-word keywords such as
???, which is in the list by default, will not be matched."
    (interactive)
    (require 'projectile)

    (let* ((grouped (funcall #'regexp-opt (--map (car it) hl-todo-keyword-faces)))
           (unescaped (s-replace-all '(("\\(" . "(") ("\\)" . ")") ("\\|" . "|"))
                                     grouped))
           (bounded (concat "\\b" unescaped "\\b"))
           (helm-follow-mode-persistent t))
      (helm-do-ag-this-file bounded)))

(defun cpm/search-todo-markers ()
    "Search for any TODO markers as specified in hl-todo-keyword-faces.

Note that this uses the word boundary \\b to avoid matching these
within other words, but this means that non-word keywords such as
???, which is in the list by default, will not be matched."
    (interactive)
    (require 'projectile)

    (let* ((grouped (funcall #'regexp-opt (--map (car it) hl-todo-keyword-faces)))
           (unescaped (s-replace-all '(("\\(" . "(") ("\\)" . ")") ("\\|" . "|"))
                                     grouped))
           (bounded (concat "\\b" unescaped "\\b"))
           (helm-follow-mode-persistent t))
      (helm-do-ag (projectile-project-root) nil bounded)))
#+END_SRC
*** Yaml Wrap Region
Wrap a visual region in =---= for a yaml block
#+begin_src emacs-lisp
(defun cpm/yaml-wrap ()
  "wrap region in --- for yaml block"
(interactive)
(let ((start (region-beginning))
      (end (region-end)))
  (goto-char end)
  (insert "---" "\n")
  (goto-char start)
  (insert "---" "\n")))
#+end_src
** DOOM! Macros

A set of fantastic macros written by [[https://github.com/hlissner][hlissner]]. There won't be much
documentation around these because the comments for each macro does a great
job explaining their function. For more information you can also look at the
[[https://github.com/hlissner/doom-emacs/wiki][wiki]] and the [[https://github.com/hlissner/doom-emacs/wiki/Modules#macros][entry on macros]] in particular.
*** after!

#+BEGIN_SRC emacs-lisp
(defmacro after! (feature &rest forms)
  "A smart wrapper around `with-eval-after-load'. Supresses warnings during
compilation."
  (declare (indent defun) (debug t))
  `(,(if (or (not (bound-and-true-p byte-compile-current-file))
             (if (symbolp feature)
                 (require feature nil :no-error)
               (load feature :no-message :no-error)))
         #'progn
       #'with-no-warnings)
    (with-eval-after-load ',feature ,@forms)))
#+END_SRC
*** map!

 #+BEGIN_SRC emacs-lisp
 (eval-and-compile
   (defun cmacs-enlist (exp)
     "Return EXP wrapped in a list, or as-is if already a list."
     (if (listp exp) exp (list exp)))

   (defun doom-unquote (exp)
     "Return EXP unquoted."
     (while (memq (car-safe exp) '(quote function))
       (setq exp (cadr exp)))
     exp)

   (defvar cmacs-evil-state-alist
     '((?n . normal)
       (?v . visual)
       (?i . insert)
       (?e . emacs)
       (?o . operator)
       (?m . motion)
       (?r . replace))
     "A list of cons cells that map a letter to a evil state symbol.")

   ;; Register keywords for proper indentation (see `map!')
   (put ':after        'lisp-indent-function 'defun)
   (put ':desc         'lisp-indent-function 'defun)
   (put ':leader       'lisp-indent-function 'defun)
   (put ':local        'lisp-indent-function 'defun)
   (put ':localleader  'lisp-indent-function 'defun)
   (put ':map          'lisp-indent-function 'defun)
   (put ':map*         'lisp-indent-function 'defun)
   (put ':mode         'lisp-indent-function 'defun)
   (put ':prefix       'lisp-indent-function 'defun)
   (put ':textobj      'lisp-indent-function 'defun)
   (put ':unless       'lisp-indent-function 'defun)
   (put ':when         'lisp-indent-function 'defun)

 ;; specials
   (defvar cmacs--keymaps nil)
   (defvar cmacs--prefix  nil)
   (defvar cmacs--defer   nil)
   (defvar cmacs--local   nil)

 (defun cmacs--keybind-register (key desc &optional modes)
   "Register a description for KEY with `which-key' in MODES.

   KEYS should be a string in kbd format.
   DESC should be a string describing what KEY does.
   MODES should be a list of major mode symbols."
   (if modes
       (dolist (mode modes)
         (which-key-add-major-mode-key-based-replacements mode key desc))
     (which-key-add-key-based-replacements key desc)))

 (defun cmacs--keyword-to-states (keyword)
   "Convert a KEYWORD into a list of evil state symbols.

 For example, :nvi will map to (list 'normal 'visual 'insert). See
 `cmacs-evil-state-alist' to customize this."
   (cl-loop for l across (substring (symbol-name keyword) 1)
            if (cdr (assq l cmacs-evil-state-alist))
              collect it
            else
              do (error "not a valid state: %s" l)))

 (defmacro map! (&rest rest)
   "A nightmare of a key-binding macro that will use `evil-define-key*',
 `define-key', `local-set-key' and `global-set-key' depending on context and
 plist key flags (and whether evil is loaded or not). It was designed to make
 binding multiple keys more concise, like in vim.

 If evil isn't loaded, it will ignore evil-specific bindings.

 States
     :n  normal
     :v  visual
     :i  insert
     :e  emacs
     :o  operator
     :m  motion
     :r  replace

     These can be combined (order doesn't matter), e.g. :nvi will apply to
     normal, visual and insert mode. The state resets after the following
     key=>def pair.

     If states are omitted the keybind will be global.

     This can be customized with `cmacs-evil-state-alist'.

     :textobj is a special state that takes a key and two commands, one for the
     inner binding, another for the outer.

 Flags
     (:mode [MODE(s)] [...])    inner keybinds are applied to major MODE(s)
     (:map [KEYMAP(s)] [...])   inner keybinds are applied to KEYMAP(S)
     (:map* [KEYMAP(s)] [...])  same as :map, but deferred
     (:prefix [PREFIX] [...])   assign prefix to all inner keybindings
     (:after [FEATURE] [...])   apply keybinds when [FEATURE] loads
     (:local [...])             make bindings buffer local; incompatible with keymaps!

 Conditional keybinds
     (:when [CONDITION] [...])
     (:unless [CONDITION] [...])

 Example
     (map! :map magit-mode-map
           :m \"C-r\" 'do-something           ; assign C-r in motion state
           :nv \"q\" 'magit-mode-quit-window  ; assign to 'q' in normal and visual states
           \"C-x C-r\" 'a-global-keybind

           (:when IS-MAC
            :n \"M-s\" 'some-fn
            :i \"M-o\" (lambda (interactive) (message \"Hi\"))))"
   (let ((cmacs--keymaps cmacs--keymaps)
         (cmacs--prefix  cmacs--prefix)
         (cmacs--defer   cmacs--defer)
         (cmacs--local   cmacs--local)
         key def states forms desc modes)
     (while rest
       (setq key (pop rest))
       (cond
	;; it's a sub expr
	((listp key)
         (push (macroexpand `(map! ,@key)) forms))

	;; it's a flag
	((keywordp key)
         (cond ((eq key :leader)
		(push 'cmacs-leader-key rest)
		(setq key :prefix
                      desc "<leader>"))
               ((eq key :localleader)
		(push 'cmacs-localleader-key rest)
		(setq key :prefix
                      desc "<localleader>")))
         (pcase key
           (:when    (push `(if ,(pop rest)       ,(macroexpand `(map! ,@rest))) forms) (setq rest '()))
           (:unless  (push `(if (not ,(pop rest)) ,(macroexpand `(map! ,@rest))) forms) (setq rest '()))
           (:after   (push `(after! ,(pop rest)   ,(macroexpand `(map! ,@rest))) forms) (setq rest '()))
           (:desc    (setq desc (pop rest)))
           (:map*    (setq cmacs--defer t) (push :map rest))
           (:map
             (setq cmacs--keymaps (cmacs-enlist (pop rest))))
           (:mode
             (setq modes (cmacs-enlist (pop rest)))
             (unless cmacs--keymaps
               (setq cmacs--keymaps
                     (cl-loop for m in modes
                              collect (intern (format "%s-map" (symbol-name m)))))))
           (:textobj
             (let* ((key (pop rest))
                    (inner (pop rest))
                    (outer (pop rest)))
               (push (macroexpand `(map! (:map evil-inner-text-objects-map ,key ,inner)
                                         (:map evil-outer-text-objects-map ,key ,outer)))
                     forms)))
           (:prefix
             (let ((def (pop rest)))
               (setq cmacs--prefix `(vconcat ,cmacs--prefix (kbd ,def)))
               (when desc
                 (push `(cmacs--keybind-register ,(key-description (eval cmacs--prefix))
                                                 ,desc ',modes)
                       forms)
                 (setq desc nil))))
           (:local
            (setq cmacs--local t))
           (_ ; might be a state cmacs--prefix
            (setq states (cmacs--keyword-to-states key)))))

	;; It's a key-def pair
	((or (stringp key)
             (characterp key)
             (vectorp key)
             (symbolp key))
         (unwind-protect
             (catch 'skip
               (when (symbolp key)
                 (setq key `(kbd ,key)))
               (when (stringp key)
                 (setq key (kbd key)))
               (when cmacs--prefix
                 (setq key (append cmacs--prefix (list key))))
               (unless (> (length rest) 0)
                 (user-error "map! has no definition for %s key" key))
               (setq def (pop rest))
               (when desc
                 (push `(cmacs--keybind-register ,(key-description (eval key))
                                               ,desc ',modes)
                       forms))
               (cond ((and cmacs--local cmacs--keymaps)
                      (push `(lwarn 'cmacs-map :warning
                                    "Can't local bind '%s' key to a keymap; skipped"
                                    ,key)
                            forms)
                      (throw 'skip 'local))
                     ((and cmacs--keymaps states)
                      (dolist (keymap cmacs--keymaps)
			(push `(,(if cmacs--defer 'evil-define-key 'evil-define-key*)
				',states ,keymap ,key ,def)
                              forms)))
                     (states
                      (dolist (state states)
			(push `(define-key
                                 ,(intern (format "evil-%s-state-%smap" state (if cmacs--local "local-" "")))
                                 ,key ,def)
                              forms)))
                     (cmacs--keymaps
                      (dolist (keymap cmacs--keymaps)
			(push `(define-key ,keymap ,key ,def) forms)))
                     (t
                      (push `(,(if cmacs--local 'local-set-key 'global-set-key) ,key ,def)
                            forms))))
           (setq states '()
                 cmacs--local nil
                 desc nil)))

	(t (user-error "Invalid key %s" key))))
     `(progn ,@(nreverse forms)))))
 #+END_SRC
*** add-hook!
 A macro that makes adding hooks easy

 #+BEGIN_SRC emacs-lisp
 (eval-and-compile
   (defun cmacs--resolve-hook-forms (hooks)
     (cl-loop with quoted-p = (eq (car-safe hooks) 'quote)
              for hook in (cmacs-enlist (doom-unquote hooks))
              if (eq (car-safe hook) 'quote)
               collect (cadr hook)
              else if quoted-p
               collect hook
              else collect (intern (format "%s-hook" (symbol-name hook)))))

   (defvar cmacs--transient-counter 0)
   (defmacro add-transient-hook! (hook &rest forms)
     "Attaches transient forms to a HOOK.

   HOOK can be a quoted hook or a sharp-quoted function (which will be advised).

   These forms will be evaluated once when that function/hook is first invoked,
   then it detaches itself."
     (declare (indent 1))
     (let ((append (eq (car forms) :after))
           (fn (intern (format "cmacs-transient-hook-%s" (cl-incf cmacs--transient-counter)))))
       `(when ,hook
          (fset ',fn
		(lambda (&rest _)
                  ,@forms
                  (cond ((functionp ,hook) (advice-remove ,hook #',fn))
			((symbolp ,hook)   (remove-hook ,hook #',fn)))
                  (unintern ',fn nil)))
          (cond ((functionp ,hook)
                 (advice-add ,hook ,(if append :after :before) #',fn))
		((symbolp ,hook)
                 (add-hook ,hook #',fn ,append)))))))

 (defmacro add-hook! (&rest args)
   "A convenience macro for `add-hook'. Takes, in order:

   1. Optional properties :local and/or :append, which will make the hook
      buffer-local or append to the list of hooks (respectively),
   2. The hooks: either an unquoted major mode, an unquoted list of major-modes,
      a quoted hook variable or a quoted list of hook variables. If unquoted, the
      hooks will be resolved by appending -hook to each symbol.
   3. A function, list of functions, or body forms to be wrapped in a lambda.

 Examples:
     (add-hook! 'some-mode-hook 'enable-something)
     (add-hook! some-mode '(enable-something and-another))
     (add-hook! '(one-mode-hook second-mode-hook) 'enable-something)
     (add-hook! (one-mode second-mode) 'enable-something)
     (add-hook! :append (one-mode second-mode) 'enable-something)
     (add-hook! :local (one-mode second-mode) 'enable-something)
     (add-hook! (one-mode second-mode) (setq v 5) (setq a 2))
     (add-hook! :append :local (one-mode second-mode) (setq v 5) (setq a 2))

 Body forms can access the hook's arguments through the let-bound variable
 `args'."
   (declare (indent defun) (debug t))
   (let ((hook-fn 'add-hook)
         append-p local-p)
     (while (keywordp (car args))
       (pcase (pop args)
         (:append (setq append-p t))
         (:local  (setq local-p t))
         (:remove (setq hook-fn 'remove-hook))))
     (let ((hooks (cmacs--resolve-hook-forms (pop args)))
           (funcs
            (let ((val (car args)))
              (if (memq (car-safe val) '(quote function))
                  (if (cdr-safe (cadr val))
                      (cadr val)
                    (list (cadr val)))
		(list args))))
           forms)
       (dolist (fn funcs)
         (setq fn (if (symbolp fn)
                      `(function ,fn)
                    `(lambda (&rest _) ,@args)))
         (dolist (hook hooks)
           (push (cond ((eq hook-fn 'remove-hook)
			`(remove-hook ',hook ,fn ,local-p))
                       (t
			`(add-hook ',hook ,fn ,append-p ,local-p)))
                 forms)))
       `(progn ,@(nreverse forms)))))

 (defmacro remove-hook! (&rest args)
   "Convenience macro for `remove-hook'. Takes the same arguments as
 `add-hook!'."
   `(add-hook! :remove ,@args))
 #+END_SRC
*** quiet!
 A simple macro that prevents code from making any noise

 #+BEGIN_SRC emacs-lisp
 (defmacro quiet! (&rest forms)
   "Run FORMS without making any noise."
   `(if nil
	(progn ,@forms)
      (fset 'doom--old-write-region-fn (symbol-function 'write-region))
      (cl-letf ((standard-output (lambda (&rest _)))
		((symbol-function 'load-file) (lambda (file) (load file nil t)))
		((symbol-function 'message) (lambda (&rest _)))
		((symbol-function 'write-region)
                 (lambda (start end filename &optional append visit lockname mustbenew)
                   (unless visit (setq visit 'no-message))
                   (doom--old-write-region-fn
                    start end filename append visit lockname mustbenew)))
		(inhibit-message t)
		(save-silently t))
	,@forms)))
 #+END_SRC
*** def-memoized!
 Creates a memoized function

 #+BEGIN_SRC emacs-lisp
 (defvar doom-memoized-table (make-hash-table :test 'equal :size 10)
   "A lookup table containing memoized functions. The keys are argument lists,
 and the value is the function's return value.")

 (defun doom-memoize (name)
   "Memoizes an existing function. NAME is a symbol."
   (let ((func (symbol-function name)))
     (put name 'function-documentation
          (concat (documentation func) " (memoized)"))
     (fset name
           `(lambda (&rest args)
              (let ((key (cons ',name args)))
		(or (gethash key doom-memoized-table)
                    (puthash key (apply ',func args)
                             doom-memoized-table)))))))

 (defmacro def-memoized! (name arglist &rest body)
   "Create a memoize'd function. NAME, ARGLIST, DOCSTRING and BODY
 have the same meaning as in `defun'."
   (declare (indent defun) (doc-string 3))
   `(,(if (bound-and-true-p byte-compile-current-file)
          'with-no-warnings
	'progn)
      (defun ,name ,arglist ,@body)
      (doom-memoize ',name)))


 #+END_SRC
*** λ!

 #+BEGIN_SRC emacs-lisp
 (defmacro λ! (&rest body)
   "A shortcut for inline interactive lambdas."
   (declare (doc-string 1))
   `(lambda () (interactive) ,@body))

 #+END_SRC

** Other Macros
#+BEGIN_SRC emacs-lisp

(defmacro find-file-in! (path &optional project-p)
  "Returns an interactive function for searching files"
  `(lambda () (interactive)
     (let ((default-directory ,path))
       (call-interactively
        ',(if project-p
              (command-remapping 'projectile-find-file)
            (command-remapping 'find-file))))))
#+END_SRC
* Emacs Settings
** System Defaults
Let's use sane defaults. Sources for this section include [[https://github.com/magnars/.emacs.d/blob/master/settings/sane-defaults.el][Magnars Sveen]] and [[http://pages.sachachua.com/.emacs.d/Sacha.html][Sacha Chua]].
*** Apropos Everything
apropos commands perform more extensive searches than default
#+BEGIN_SRC emacs-lisp
(setq apropos-do-all t)
#+END_SRC
*** Clipboard
#+BEGIN_SRC emacs-lisp
; Merge system's and Emacs' clipboard
(setq select-enable-clipboard t)
;; Save whatever’s in the current (system) clipboard before
;; replacing it with the Emacs’ text.
(setq save-interprogram-paste-before-kill t)
;; Copy/Paste functions 
;; https://github.com/dakrone/eos/blob/master/eos-core.org#mac-osx
(defun copy-from-osx ()
    "Handle copy/paste intelligently on osx."
    (let ((pbpaste (purecopy "/usr/bin/pbpaste")))
      (if (and (eq system-type 'darwin)
               (file-exists-p pbpaste))
          (let ((tramp-mode nil)
                (default-directory "~"))
            (shell-command-to-string pbpaste)))))

  (defun paste-to-osx (text &optional push)
    (let ((process-connection-type nil))
      (let ((proc (start-process "pbcopy" "*Messages*" "/usr/bin/pbcopy")))
        (process-send-string proc text)
        (process-send-eof proc))))
  (setq interprogram-cut-function 'paste-to-osx
        interprogram-paste-function 'copy-from-osx)
#+END_SRC
*** Cursor Movement
Per [[https://emacs.stackexchange.com/a/28746/11934][this]] post on stack overflow
#+BEGIN_SRC emacs-lisp
(setq auto-window-vscroll nil)
#+END_SRC
*** Disable Welcome Screen

#+BEGIN_SRC emacs-lisp
; Disable start-up screen
(setq-default inhibit-startup-screen t)                         
(setq inhibit-splash-screen t)
(setq inhibit-startup-message t)
(setq initial-scratch-message "")
;; And bury the scratch buffer, don't kill it
(defadvice kill-buffer (around kill-buffer-around-advice activate)
  (let ((buffer-to-kill (ad-get-arg 0)))
    (if (equal buffer-to-kill "*scratch*")
        (bury-buffer)
      ad-do-it)))
#+END_SRC
*** Environment Path
Make sure emacs correctly sets up your PATH.
#+BEGIN_SRC emacs-lisp
  (defvar cpm-local-bin (concat (getenv "HOME") "/bin") "Local execs.")
  (defvar usr-local-bin "/usr/local/bin")
  (defvar usr-local-sbin "/usr/local/sbin")
  (setenv "PATH" (concat usr-local-bin ":" usr-local-sbin ":" (getenv "PATH") ":" cpm-local-bin))
  (setq exec-path (append exec-path (list cpm-local-bin usr-local-sbin usr-local-bin)))
#+END_SRC 
*** File Endings
Make all files [[http://stackoverflow.com/questions/729692/why-should-text-files-end-with-a-newline][POSIX compliant for newlines]]
#+BEGIN_SRC emacs-lisp
;; Make sure your text files end in a newline
(setq require-final-newline t)
#+END_SRC
*** Give buffers unique names
#+BEGIN_SRC emacs-lisp
  (setq uniquify-buffer-name-style 'forward)
#+END_SRC
*** Help Buffers
#+BEGIN_SRC emacs-lisp
;; Keep focus while navigating help buffers
(setq help-window-select 't)
#+END_SRC
*** Large Files
Warn only for files over 100MB
#+BEGIN_SRC emacs-lisp
(setq large-file-warning-threshold 100000000)
#+END_SRC
*** DISABLED Paragraphs
CLOSED: [2018-08-14 Tue 12:11]
From the [[https://www.emacswiki.org/emacs/FillParagraph][Emacs Wiki]] on fill paragraph.
#+BEGIN_SRC emacs-lisp
;; The original value is "\f\\|[      ]*$", so we add the bullets (-), (+), and (*).
    ;; There is no need for "^" as the regexp is matched at the beginning of line.
    (setq paragraph-start "\f\\|[ \t]*$\\|[ \t]*[-+*] ")
#+END_SRC
*** Pretty symbols
#+BEGIN_SRC emacs-lisp
(setq prettify-symbols-unprettify-at-point t)
(global-prettify-symbols-mode +1)
#+END_SRC
*** Startup Echo Message
#+BEGIN_SRC emacs-lisp
  ;; Change the echo message
(defun display-startup-echo-area-message ()
  (message ""))
#+END_SRC
*** Scratch startup mode 
Useful to get a faster Emacs load time because it avoids autoloads of
elisp modes or other minor modes. I start it in org-mode though because that
seems to ease loading when launching org projects. 
#+BEGIN_SRC emacs-lisp
  (setq initial-major-mode 'org-mode)
#+END_SRC
*** Text Settings
General Text settings and hooks
**** Sentence endings
#+BEGIN_SRC emacs-lisp
;; Single space between sentences is more widespread than double
(setq-default sentence-end-double-space nil)
#+END_SRC
**** Subwords and CamelCase
#+BEGIN_SRC emacs-lisp
; Iterate through CamelCase words
(global-subword-mode 1)                           
#+END_SRC
**** Only use spaces
#+BEGIN_SRC emacs-lisp
(setq-default indent-tabs-mode nil)
(setq-default tab-width 4)
(setq-default indicate-empty-lines nil)
#+END_SRC
**** Line wrap
#+BEGIN_SRC emacs-lisp
(setq-default fill-column 85)
(global-visual-line-mode)
(setq line-move-visual t) ;; move via visual lines
(global-visual-fill-column-mode)
#+END_SRC
**** Visual replace
This is the [[https://github.com/benma/visual-regexp.el][good old search and replace]] as opposed to the fancy alternatives
such as [[https://github.com/victorhge/iedit][iedit]] and [[https://github.com/magnars/multiple-cursors.el][multiple cursors]]. You search for a word in the
buffer/region, type in the replacement and confirm each one by pressing =y= or =n=
or just press =!= to apply this to everything.

#+BEGIN_SRC emacs-lisp
(use-package visual-regexp
  :commands (vr/query-replace)
  :config
  (use-package visual-regexp-steroids
    :commands (vr/select-query-replace)))
#+END_SRC
**** Show Matching Brackets
Show matching brackets, parenthesis, etc.
#+BEGIN_SRC emacs-lisp
(show-paren-mode t)
(setq show-paren-delay 0) 
#+END_SRC
*** Turn off the blinking cursor
#+BEGIN_SRC emacs-lisp
(blink-cursor-mode 0)
#+END_SRC
*** UTF-8 please
#+BEGIN_SRC emacs-lisp
  (setq locale-coding-system 'utf-8) 
  (set-terminal-coding-system 'utf-8) 
  (set-keyboard-coding-system 'utf-8) 
  (set-selection-coding-system 'utf-8)
  (prefer-coding-system 'utf-8) 
#+END_SRC
*** Warnings
No bells and no visible "bell" either!
#+BEGIN_SRC emacs-lisp
  (setq visible-bell nil) ;; The default
  (setq ring-bell-function 'ignore)
  ;; Silence warnings generated by a function's being redefine by =defadvice=.
  (setq ad-redefinition-action 'accept)
#+END_SRC
*** Yes or No
#+BEGIN_SRC emacs-lisp
  (defalias 'yes-or-no-p 'y-or-n-p)
#+END_SRC

** Backups
#+BEGIN_SRC emacs-lisp
  (let ((backup-dir (concat cpm-cache-dir "backup")))
    ;; Move backup file to `~/.emacs.d/.cache/backup'
    (setq backup-directory-alist `(("." . ,backup-dir)))
    ;; Makesure backup directory exist
    (when (not (file-exists-p backup-dir))
      (make-directory backup-dir t)))

  (setq make-backup-files t               ; backup of a file the first time it is saved.
        backup-by-copying t               ; don't clobber symlinks
        version-control t                 ; version numbers for backup files
        delete-old-versions t             ; delete excess backup files silently
        delete-by-moving-to-trash t
        kept-old-versions 6               ; oldest versions to keep when a new numbered backup is made
        kept-new-versions 6               ; newest versions to keep when a new numbered backup is made
        )
  (setq vc-make-backup-files t) ;;  backup versioned files, which Emacs does not do by default


#+END_SRC
*** Backup Walker
Traverse backups with [[https://github.com/lewang/backup-walker][backup-walker]]
#+BEGIN_SRC emacs-lisp
(use-package backup-walker
  :commands backup-walker-start)
#+END_SRC
** Auto Save
I make sure Emacs auto-saves often but the result is that it messes up my file tree. So, let's ask Emacs to store its backups in the cache directory.

#+BEGIN_SRC emacs-lisp
(setq auto-save-list-file-prefix
      (concat cpm-cache-dir "auto-save-list/.saves-"))


(setq auto-save-default t               ; auto-save every buffer that visits a file
      auto-save-timeout 20              ; number of seconds idle time before auto-save (default: 30)
      auto-save-interval 200            ; number of keystrokes between auto-saves (default: 300)
      auto-save-visited-file-name nil
      delete-auto-save-files t
      create-lockfiles nil)
#+END_SRC
*** Full Auto Save
I also make emacs just outright save all buffers. 
#+BEGIN_SRC emacs-lisp
  (defun full-auto-save ()
    (interactive)
    (save-excursion
      (dolist (buf (buffer-list))
        (set-buffer buf)
        (if (and (buffer-file-name) (buffer-modified-p))
            (basic-save-buffer)))))
  (add-hook 'auto-save-hook 'full-auto-save)
#+END_SRC
** Custom file 
Set up the customize file to its own [[file:$HOME/.emacs.d/custom.el][separate file]], instead of saving
customize settings in [[file:init.el][init.el]].

#+begin_src emacs-lisp
(setq custom-file (expand-file-name "custom.el" user-emacs-directory))
(when (file-exists-p custom-file)
  (load custom-file))
#+end_src
** Desktop save
Save your frame/window/buffer config
#+BEGIN_SRC emacs-lisp
  (setq desktop-dirname             (concat cpm-cache-dir "desktops")
        desktop-base-file-name      "emacs.desktop"
        desktop-base-lock-name      "lock"
        desktop-path                (list desktop-dirname)
        desktop-save                'ask-if-new
        desktop-files-not-to-save   (concat "^$" ".*magit$")
        desktop-restore-eager 4
        desktop-load-locked-desktop t)

  (when (not (file-exists-p desktop-dirname))
  (make-directory desktop-dirname t))
  
  (setq desktop-buffers-not-to-save
          (concat "\\("
                  "^nn\\.a[0-9]+\\|\\.log\\|(ftp)\\|^tags\\|^TAGS"
                  "\\|\\.emacs.*\\|\\.diary\\|\\.newsrc-dribble\\|\\.bbdb"
	          "\\)$"))

  (desktop-save-mode 0)

  (defun cpm/my-desktop ()
    "Load the desktop and enable autosaving"
    (interactive)
    (let ((desktop-load-locked-desktop "ask"))
      (desktop-read)
      (desktop-save-mode 1)))

  (defun cpm/save-desktop-save-buffers-kill-emacs ()
    "Save buffers and current desktop every time when quitting emacs."
    (interactive)
    (desktop-save-in-desktop-dir)
    (save-buffers-kill-emacs))
#+END_SRC
** Mac/OSX
There is some configuration to do when running Emacs on OS X (hence the
"darwin" system-type check).

First we can define some general system checks
#+BEGIN_SRC emacs-lisp
(setq IS-LINUX (eq system-type 'gnu/linux)
      IS-MAC (eq system-type 'darwin))
#+END_SRC


#+begin_src emacs-lisp
    (when IS-MAC
      ;; make fonts look better with anti-aliasing
      (setq mac-allow-anti-aliasing t)
      ;; delete files by moving them to the trash
      (setq delete-by-moving-to-trash t)
      (setq trash-directory "~/.Trash")

      ;; Don't make new frames when opening a new file with Emacs
      (setq ns-pop-up-frames nil)

      ;; fullscreen (disable for non-space full screen)
      (setq ns-use-native-fullscreen t)

      ;; disable emacs-mac smooth scrolling because it is seriously janky
      (setq mac-mouse-wheel-smooth-scroll nil)

      ;; Set modifier keys
      (setq mac-option-modifier 'meta) ;; Bind meta to ALT
      (setq mac-command-modifier 'super) ;; Bind apple/command to super if you want
      (setq mac-function-modifier 'hyper) ;; Bind function key to hyper if you want 
      (setq mac-right-option-modifier 'none) ;; unbind right key for accented input

      ;; Make forward delete work 
      (global-set-key (kbd "<H-backspace>") 'delete-forward-char)

      ;; Keybindings
      (global-set-key (kbd "s-q") 'save-buffers-kill-terminal)
      (global-set-key (kbd "s-v") 'yank)
      (global-set-key (kbd "s-c") 'evil-yank)
      (global-set-key (kbd "s-a") 'mark-whole-buffer)
      (global-set-key (kbd "s-x") 'kill-region)
      (global-set-key (kbd "s-w") 'delete-window)
      (global-set-key (kbd "s-W") 'delete-frame)
      (global-set-key (kbd "s-n") 'make-frame)
      (global-set-key (kbd "s-N") 'nameframe-create-frame)
      (global-set-key (kbd "s-z") 'undo-tree-undo)
      (global-set-key (kbd "s-s")
                      (lambda ()
                        (interactive)
                        (call-interactively (key-binding "\C-x\C-s"))))
      (global-set-key (kbd "s-Z") 'undo-tree-redo)
      (global-set-key (kbd "C-s-f") 'toggle-frame-fullscreen)
      ;; Emacs sometimes registers C-s-f as this weird keycode
      (global-set-key (kbd "<C-s-268632070>") 'toggle-frame-fullscreen)
  )


      ;; -- This is for TextExpander
      ;; (setq ns-alternate-modifier 'alt)
      ;; (define-key global-map [(alt ?v)] 'scroll-down)
      ;; (define-key global-map [(meta ?v)] 'yank)
#+end_src
** Time and Date Stamps
*** Emacs buffer timestamp settings
#+BEGIN_SRC emacs-lisp
  (setq 
    time-stamp-active t          ; do enable time-stamps
    time-stamp-line-limit -10     ; check first 10 buffer lines for Time-stamp: 
    time-stamp-format "Last modified on %04y-%02m%02d-%02H:%02M:%02S") ; date format
  (add-hook 'write-file-hooks 'time-stamp) ; update when saving
#+END_SRC
*** Insert time or date
The code below sets the correct value for system-time-locale, and binds
keys for insert-date/long and insert-date/short. Courtesy of [[https://ebzzry.github.io/emacs-hacks-2.html#desktop][emacs-hacks]].
#+BEGIN_SRC emacs-lisp
  (defun format-date (format)
  (let ((system-time-locale "en_US.UTF-8"))
    (insert (format-time-string format))))

(defun insert-date ()
  (interactive)
  (format-date "%A, %B %d %Y"))

(defun insert-date-and-time ()
  (interactive)
  (format-date "%m-%d-%Y %H:%M:%S"))
#+END_SRC
** DISABLED Location
CLOSED: [2019-01-02 Wed 11:21]
(I only need this if I'm using [[https://github.com/guidoschmidt/circadian.el][circadian]], which I'm not)
Make Emacs watch and respond to changes in [[https://github.com/purcell/osx-location][geographical location]] on OS X
#+BEGIN_SRC emacs-lisp
(use-package osx-location
  :if (eq system-type 'darwin)
  :defer 10
  :commands osx-location-watch
  :config
  (osx-location-watch)
  (add-hook 'osx-location-changed-hook
               (lambda ()
                 (setq calendar-latitude osx-location-latitude
                       calendar-longitude osx-location-longitude
                       calendar-location-name (format "%s, %s" osx-location-latitude osx-location-longitude)))))
#+END_SRC

* Core Packages
** Modal Editing
*** General  (Evil)
A [[https://github.com/noctuid/general.el][convenient way]] to bind keys. Compatible with evil. For helpful
discussion of setting up evil with general see [[https://sam217pa.github.io/2016/09/02/how-to-build-your-own-spacemacs/][this post]].
#+BEGIN_SRC emacs-lisp
  (use-package general
    :demand t
    :config
    (general-override-mode)
    )
#+END_SRC

*** Vim Emulation
I'm coming from vim, and want modal keybidings in emacs. There are other, less
radical ways of getting modal editing in emacs. For example, [[https://github.com/mrkkrp/modalka][modalka]] is a nice
package for modal editing (see also [[https://github.com/Kungsgeten/ryo-modal][ryo-modal]]). But nothing beats full vim
keybindings. And that is what [[https://bitbucket.org/lyro/evil/wiki/Home][evil]] is for.
Install, automatically load, and enable evil. It's like vim, but better!
**** Evil Mode
#+BEGIN_SRC emacs-lisp
  (use-package evil
    :demand t
    :init 
    (setq evil-want-integration t
          evil-want-keybinding nil)
    :config
    (progn
    ;; Cursor shape and color
      (defcustom dotemacs-evil/emacs-cursor
      "red"
      "The color of the cursor when in Emacs state."
      :type 'color
      :group 'dotemacs-evil)

      (defcustom dotemacs-evil/emacs-insert-mode
      nil
      "If non-nil, insert mode will act as Emacs state."
      :type 'boolean
      :group 'dotemacs-evil)

      ;; move over visual lines like normal lines
      (general-define-key :states '(motion normal)
             "j"   #'evil-next-visual-line
             "k"   #'evil-previous-visual-line)

      (setq evil-search-module 'evil-search)
      (setq evil-magic 'very-magic)
      ;; (setq evil-want-C-i-jump nil)
      ;; Set colors for cursor states
      (setq evil-emacs-state-cursor '("SkyBlue2" box))
      (setq evil-normal-state-cursor '("DarkGoldenrod2" box))
      (setq evil-visual-state-cursor '("gray" box)) 
      (setq evil-insert-state-cursor '("chartreuse3" (bar . 2)))
      (setq evil-replace-state-cursor '("red" hbar))
      (setq evil-motion-state-cursor  '("plum3" box))
      (setq evil-operator-state-cursor '("red" hollow))
      ;; (setq evil-visual-state-tag "VISUAL")
      ;use insert in commits automatically 
      (add-hook 'git-commit-mode-hook 'evil-insert-state)
      (evil-set-initial-state 'messages-buffer-mode 'normal)
      (evil-set-initial-state 'magit-log-edit-mode 'insert)
      ;; evil-normal-state is preferred, so revert when idle
      (run-with-idle-timer 60 t 'evil-normal-state)
      ;; don't echo evil state
      (setq evil-echo-state nil)
      ;; don't move cursor back when exiting insert state
      (setq evil-move-cursor-back nil)
      ;; evil everywhere
      (evil-mode 1))) 
#+END_SRC
**** Evil Related Packages & Settings
There are some other useful setup packages for evil
***** TESTING Evil Collection
A collection of keybindings for evil
#+BEGIN_SRC emacs-lisp
  (use-package evil-collection
    :ensure t
    :after evil
    :config
    (evil-collection-init)
    (setq evil-collection-mode-list t))
#+END_SRC

***** Evil indent
#+BEGIN_SRC emacs-lisp
(use-package evil-indent-textobject :commands (evil-indent))
#+END_SRC
***** Change Cursor In Terminal
#+begin_src emacs-lisp
(defun my-send-string-to-terminal (string)
  (unless (display-graphic-p) (send-string-to-terminal string)))

(defun my-evil-terminal-cursor-change ()
  (when (string= (getenv "TERM_PROGRAM") "iTerm.app")
    (add-hook 'evil-insert-state-entry-hook (lambda () (my-send-string-to-terminal "\e]50;CursorShape=1\x7")))
    (add-hook 'evil-insert-state-exit-hook  (lambda () (my-send-string-to-terminal "\e]50;CursorShape=0\x7"))))
  (when (and (getenv "TMUX") (string= (getenv "TERM_PROGRAM") "iTerm.app"))
    (add-hook 'evil-insert-state-entry-hook (lambda () (my-send-string-to-terminal "\ePtmux;\e\e]50;CursorShape=1\x7\e\\")))
    (add-hook 'evil-insert-state-exit-hook  (lambda () (my-send-string-to-terminal "\ePtmux;\e\e]50;CursorShape=0\x7\e\\")))))

(add-hook 'after-make-frame-functions (lambda (frame) (my-evil-terminal-cursor-change)))
(my-evil-terminal-cursor-change)
#+end_src
***** Evil Surround Commands Like Vim-Surround
#+begin_src emacs-lisp
  (use-package evil-surround
    ;; :commands (evil-surround-region evil-surround-change evil-surround-delete)
    ;; :hook ((LaTeX-mode org-mode markdown-mode prog-mode) . evil-surround-mode)
    :general
    (:states '(visual)
    "s" 'evil-surround-region
    "S" 'evil-substitute)
    ;; :config (global-evil-surround-mode 1)
    :init
    (global-evil-surround-mode 1)
    )

  ;; (use-package embrace 
  ;;   :disabled t
  ;;   :after evil-surround
  ;;   :demand t)
    ;; :hook ((LaTeX-mode . embrace-LaTeX-mode-hook)
    ;;        (org-mode . embrace-org-mode-hook)
    ;;        (org-mode . embrace-markdown-mode-hook)
    ;;        (markdown-mode . embrace-markdown-mode-hook)))

  (use-package evil-embrace
   :after evil-surround
   :demand t
   :init
   (evil-embrace-enable-evil-surround-integration)
   :config
   (setq evil-embrace-show-help-p nil)
   (add-hook 'org-mode-hook 'embrace-org-mode-hook)
   (defun embrace-markdown-mode-hook ()
   (dolist (lst '((?* "*" . "*")  
                  (?\ "\\" . "\\")
                  (?$ "$" . "$")
                  (?/ "/" . "/")))
    (embrace-add-pair (car lst) (cadr lst) (cddr lst))))
    (add-hook 'markdown-mode-hook 'embrace-markdown-mode-hook)
    )
#+end_src 

***** Commenting 
#+begin_src emacs-lisp
  (use-package evil-commentary
    :commands (evil-commentary evil-commentary-line)
    ;; :diminish evil-commentary-mode
    :config
    (evil-commentary-mode))
#+end_src
***** Graphical undo
#+begin_src emacs-lisp
  (use-package undo-tree
    :commands (undo-tree-undo undo-tree-redo undo-tree-visualize)
    :init
    (global-undo-tree-mode)
    (setq undo-tree-visualizer-timestamps t)
    (setq undo-tree-visualizer-diff t)
    ;; supposedly causes errors in undo read
    ;; see https://emacs.stackexchange.com/a/34214/11934
    (setq undo-tree-enable-undo-in-region nil)
    ;; stop littering - set undo directory 
    (let ((undo-dir (concat cpm-cache-dir "undo")))
      (setq undo-tree-history-directory-alist `(("." . ,undo-dir)))
      (unless (file-directory-p undo-dir)
        (make-directory undo-dir t)))
    (setq undo-tree-auto-save-history nil))
#+end_src
***** Evil Multiedit
A version of multiple cursors for use with evil. Courtesy of [[https://github.com/hlissner/evil-multiedit][hlissner]]. 
#+BEGIN_SRC emacs-lisp
(use-package evil-multiedit
 :ensure t
 :after evil-visualstar
 :config
 ;; Default keybindings
 ;; Highlights all matches of the selection in the buffer.
(define-key evil-visual-state-map "R" 'evil-multiedit-match-all)

;; Match the word under cursor (i.e. make it an edit region). Consecutive presses will
;; incrementally add the next unmatched match.
(define-key evil-normal-state-map (kbd "M-d") 'evil-multiedit-match-and-next)
;; Match selected region.
(define-key evil-visual-state-map (kbd "M-d") 'evil-multiedit-and-next)
;; Insert marker at point
(define-key evil-insert-state-map (kbd "M-d") 'evil-multiedit-toggle-marker-here)

;; Same as M-d but in reverse.
(define-key evil-normal-state-map (kbd "M-D") 'evil-multiedit-match-and-prev)
(define-key evil-visual-state-map (kbd "M-D") 'evil-multiedit-and-prev)

;; OPTIONAL: If you prefer to grab symbols rather than words, use
;; `evil-multiedit-match-symbol-and-next` (or prev).

;; Restore the last group of multiedit regions.
(define-key evil-visual-state-map (kbd "C-M-D") 'evil-multiedit-restore)

;; RET will toggle the region under the cursor
(define-key evil-multiedit-state-map (kbd "RET") 'evil-multiedit-toggle-or-restrict-region)

;; ...and in visual mode, RET will disable all fields outside the selected region
(define-key evil-motion-state-map (kbd "RET") 'evil-multiedit-toggle-or-restrict-region)

;; For moving between edit regions
(define-key evil-multiedit-state-map (kbd "C-n") 'evil-multiedit-next)
(define-key evil-multiedit-state-map (kbd "C-p") 'evil-multiedit-prev)
(define-key evil-multiedit-insert-state-map (kbd "C-n") 'evil-multiedit-next)
(define-key evil-multiedit-insert-state-map (kbd "C-p") 'evil-multiedit-prev)

;; Ex command that allows you to invoke evil-multiedit with a regular expression, e.g.
(evil-ex-define-cmd "ie[dit]" 'evil-multiedit-ex-match)
)
#+END_SRC
***** Evil Multiple Cursors
[[https://github.com/gabesoft/evil-mc][Multiple cursors]] implementation for evil-mode
#+BEGIN_SRC emacs-lisp
  (use-package evil-mc
    :ensure t
    :commands (evil-mc-make-all-cursors evil-mc-make-and-goto-next-match))
#+END_SRC
***** Evil Numbers
Increment an decrement numbers 
#+BEGIN_SRC emacs-lisp
  (use-package evil-numbers
    :commands (evil-numbers/inc-at-pt evil-numbers/dec-at-pt)
    :init
    (general-define-key
      :states '(normal visual insert emacs)
      "H-s" 'evil-numbers/inc-at-pt
      "H-a" 'evil-numbers/dec-at-pt))
#+END_SRC
***** Evil Visualstar
From bling: https://github.com/bling/evil-visualstar
#+BEGIN_SRC emacs-lisp
(use-package evil-visualstar
  :commands (evil-visualstar/begin-search-forward evil-visualstar/begin-search-backward))
#+END_SRC

** Appearance & UI
Various settings to make Emacs (mostly the GUI version) look better or
make interaction smoother. 
   
*** Appearance
**** Font
 A good fixed-width or monospaced font is important. [[http://levien.com/type/myfonts/inconsolata.html][Inconsolata]] is a nice
 monospaced font. I've used a version, [[https://github.com/MihailJP/Inconsolata-LGC][Inconsolata-LGC]], that also has
 bold and italic fonts. However, I'm currently using [[https://github.com/i-tu/Hasklig/issues/84][hasklig]], which is a fork of
 [[https://github.com/adobe-fonts/source-code-pro][Source Code Pro]] with ligatures added.
 
 To install a font on OS X, you can use Homebrew with [[http://caskroom.io/][Homebrew Cask]].

 #+begin_src sh :tangle no

 # You may need to run these two lines if you haven't set up Homebrew
 # Cask and its fonts formula.
 brew install caskroom/cask/brew-cask
 brew tap caskroom/fonts
 brew cask install font-inconsolata-lgc

 #+END_SRC

 Here I set the variable values, including a variable font face for themes
 that use that for headings, such as [[*Solarized][solarized]]. The settings are called below. 

 #+BEGIN_SRC emacs-lisp
 (defvar cpm-font (font-spec :family "Hasklug Nerd Font" :size 13))
 (defvar cpm-vari-font (font-spec :family "Avenir"))
 (defvar cpm-unicode-font (font-spec :family "STIXGeneral"))
 #+END_SRC
 
 Here we tell emacs to use the fonts set in the variables above. 
 #+BEGIN_SRC emacs-lisp
 (set-face-attribute 'default nil :font cpm-font)
 (set-face-attribute 'variable-pitch nil :font cpm-vari-font)
 (set-fontset-font t 'unicode cpm-unicode-font nil 'prepend)
 #+END_SRC
**** Frame Title 
 Show the filepath in the frame title (disabled due to text color issues).
 #+BEGIN_SRC emacs-lisp
   (setq frame-title-format '('nil))
     ;; (setq-default frame-title-format
     ;;           '((buffer-file-name "%f" "%b")))
 #+END_SRC
**** Frame Defaults
 I like the frame either centered and approximately 2/3 of a 13inch
 laptop screen or maximized.
#+BEGIN_SRC emacs-lisp
(if (display-graphic-p)
  (progn
  ;; start frame of emacs maximized
  (add-to-list 'initial-frame-alist '(fullscreen . maximized))

  ;; new frames
  (setq default-frame-alist
            '(
              (top . 25)
              (left . 275)
              (width . 106) ;; chars
              (height . 60) ;; lines
              ))))
#+END_SRC
**** Titlebar color
This Emacs package provides a global minor mode, ns-auto-titlebar-mode which - when enabled - keeps the "ns-appearance" frame parameter correctly set in GUI frames so that it matches the currently-enabled theme, whether it is light or dark.

For this package to work correctly, it is generally necessary that the theme you use sets the frame-background-mode variable appropriately. This can be set manually if necessary, but see the docs for that variable.
#+BEGIN_SRC emacs-lisp
  (use-package ns-auto-titlebar
    :config
    (when (eq system-type 'darwin) (ns-auto-titlebar-mode)))
#+END_SRC
**** Transparent frame titlebar
#+BEGIN_SRC emacs-lisp
  ;; https://github.com/d12frosted/homebrew-emacs-plus/blob/master/Formula/emacs-plus.rb#L98
  ;; https://github.com/d12frosted/homebrew-emacs-plus/issues/55
  ;; https://www.gnu.org/software/emacs/manual/html_node/elisp/Properties-in-Mode.html#Properties-in-Mode
  (when (memq window-system '(mac ns))
    (add-to-list 'default-frame-alist '(ns-appearance . dark))
    (add-to-list 'default-frame-alist '(ns-transparent-titlebar . t)))
#+END_SRC


**** Borderless Frame
#+BEGIN_SRC emacs-lisp
  ;; (setq default-frame-alist '((undecorated . t)))
#+END_SRC

**** Get rid of UI cruft
 Turn off all of the GUI cruft.
 #+BEGIN_SRC emacs-lisp
   ;; Turn off mouse interface early in startup to avoid momentary display
   (when (display-graphic-p)
     (menu-bar-mode -1)
     (tool-bar-mode -1)
     (scroll-bar-mode -1)
     (tooltip-mode -1))
 #+END_SRC
**** No menu bar in terminal
 Ditto for the terminal.
 #+BEGIN_SRC emacs-lisp
   (when (not (display-graphic-p))
     (menu-bar-mode -1))
 #+END_SRC
**** Change Font Size
 #+BEGIN_SRC emacs-lisp
 (when IS-MAC
   (global-set-key (kbd "s-=") 'text-scale-increase)
   (global-set-key (kbd "s--") 'text-scale-decrease)
   (global-set-key (kbd "s-0") 'text-scale-adjust))
 #+END_SRC
**** Native Line Numbers (Emacs 26)
Emacs now has native line number support in the C source code, rather
than the other packages, which utilize elisp hacks, making it /much/
faster.
#+BEGIN_SRC emacs-lisp
  (use-package line-numbers
    :ensure nil
    ;; :hook (markdown-mode prog-mode)
    :commands display-line-numbers-mode
    :init
    (setq-default display-line-numbers-type 'visual)) 
#+END_SRC



**** Highlight numbers
 Highlight numbers in [[https://github.com/Fanael/highlight-numbers][source code]]
 #+BEGIN_SRC emacs-lisp
 (use-package highlight-numbers
   :defer t
   :init
   (add-hook 'prog-mode-hook #'highlight-numbers-mode))
 #+END_SRC
**** Highlight TODOs
 highlight TODO statements in comments 
 #+BEGIN_SRC emacs-lisp
   (use-package hl-todo
     :defer t
     :init
     ;; (add-hook 'org-mode-hook #'hl-todo-mode)
     (add-hook 'prog-mode-hook #'hl-todo-mode)
     (add-hook 'markdown-mode-hook #'hl-todo-mode))
 #+END_SRC
**** All the icons
Like the title says...
 #+BEGIN_SRC emacs-lisp
   (use-package all-the-icons
    :defer 1)
   ;;dependency
   (use-package font-lock+
     :defer 1)
 #+END_SRC
 
**** All the icons dired
[[https://github.com/jtbm37/all-the-icons-dired][Icons]] for dired
#+BEGIN_SRC emacs-lisp
  ;; icons for dired
  (use-package all-the-icons-dired
    :defer t
    :init
    (add-hook 'dired-mode-hook 'all-the-icons-dired-mode))
#+END_SRC 

**** Beacon
 Useful for letting you know where the cursor is
 #+BEGIN_SRC emacs-lisp
 (use-package beacon
   :defer 10
   :config
   (beacon-mode 1)
   (add-to-list 'beacon-dont-blink-major-modes 'eshell-mode))
 #+END_SRC
**** Emoji
Add emoji support. This is useful when working with html.
#+BEGIN_SRC emacs-lisp
  (use-package emojify
   :commands (emojify-mode emojify-apropos-emoji)
   ;; :hook ((prog-mode markdown-mode) . emojify-mode)
   :config
   (setq emojify-emojis-dir (concat cpm-etc-dir "emojis")))

#+END_SRC

**** Theme
***** Toggle OSX Menubar Dark Mode
A dark mode [[https://github.com/sindresorhus/dark-mode][toggle]] for osx menubar. 
#+BEGIN_SRC emacs-lisp
  (defun cpm/osx-toggle-menubar-theme ()
    (interactive)
    (shell-command "dark-mode"))
  (defun cpm/osx-menubar-theme-light ()
    (interactive)
    (shell-command "dark-mode off"))
  (defun cpm/osx-menubar-theme-dark ()
    (interactive)
    (shell-command "dark-mode on"))
#+END_SRC
***** Solarized
 The best low-contrast theme out there.
 #+BEGIN_SRC emacs-lisp
   (use-package solarized-theme
     :if (display-graphic-p)
     :init
       (progn
       (setq org-todo-keyword-faces
            '(("TODO" . (:foreground "orange" :weight bold)) ("STARTED" . "yellow")
              ("WAITING" . (:weight bold))
              ("SUBMITTED-C" . "green") ("SUBMITTED-J" . "green")
              ("ACCEPTED-C" . "silver") ("ACCEPTED-J" . "silver")
              ("REVISE" . (:foreground "violet" :weight bold))))

           ;; don't make the fringe stand out from the background
           (setq solarized-distinct-fringe-background nil)

           ;; change the font for some headings and titles
           (setq solarized-use-variable-pitch t)

           ;; make the modeline high contrast
           (setq solarized-high-contrast-mode-line nil)
           ;; use this setting without hi contrast modeline
           (setq x-underline-at-descent-line t)

           ;; Use bolding
           (setq solarized-use-less-bold nil)

           ;; Use more italics
           (setq solarized-use-more-italic t)

           ;; Use colors for indicators such as git:gutter, flycheck and similar
           (setq solarized-emphasize-indicators t)

           ;; Set to nil of you don't want to change size of org-mode headlines (but keep other size-changes)
           (setq solarized-scale-org-headlines t)

           ;; Theme & menubar toggle
           (setq active-theme 'solarized-dark)
           (defun toggle-dark-light-theme ()
           (interactive)
           (if (eq active-theme 'solarized-light) 
               (progn (setq active-theme 'solarized-dark) 
                      (cpm/osx-menubar-theme-dark)
                      (add-to-list 'default-frame-alist '(ns-appearance . dark))
                      (force-mode-line-update))
               (progn (setq active-theme 'solarized-light) 
                      (cpm/osx-menubar-theme-light)
                      (add-to-list 'default-frame-alist '(ns-appearance . light))
                      (force-mode-line-update)))
           (load-theme active-theme)))
           ;; (powerline-reset)))

            (progn
            (defvar after-load-theme-hook nil
            "Hook run after a color theme is loaded using `load-theme'.")
            (defadvice load-theme (after run-after-load-theme-hook activate)
            "Run `after-load-theme-hook'."
            (run-hooks 'after-load-theme-hook))
            (defun customize-solarized-dark ()
            "Customize solarized theme"
            (if (member 'solarized-dark custom-enabled-themes)
                  (custom-theme-set-faces
                  'solarized-dark
                  ;; make bg darker for higher contrast
                  ;; '(default ((t (:inherit nil :stipple nil :background "#002833" :foreground "#839496" :inverse-video nil :box nil :strike-through nil :overline nil :underline nil :slant normal :weight normal :height 130 :width normal :foundry "nil" :family "Inconsolata LGC"))))
                  '(default ((t (:background "#002833" :foreground "#839496"))))
                  ;; matching fringe
                  '(fringe ((t (:background "#002833" :foreground "#586e75"))))
                  ;; fix modeline underline
                   '(mode-line ((t (:background "#073642" :foreground "#839496" :box (:line-width 1 :color "#073642" :style unspecified) :overline "#073642" :underline "#073642"))))
                  ;; terminal
                  '(term ((t (:background "#002833" :foreground "#839496"))))
                  ;; org faces
                  '(org-block ((t (:foreground "#2E8B57"))))
                  '(org-block-begin-line ((t (:foreground "#74a8a4" :weight bold :slant normal))))
                  '(org-block-end-line ((t (:foreground "#74a8a4" :weight bold :slant normal))))
                  '(org-level-1 ((t (:inherit variable-pitch :foreground "#268bd2" :height 1.5))))
                  '(org-level-2 ((t (:inherit variable-pitch :foreground "medium sea green" :height 1.3))))
                  '(org-level-3 ((t (:inherit variable-pitch :foreground "#cb4b16" :height 1.2))))
                  '(org-level-4 ((t (:inherit variable-pitch :foreground "#6c71c4" :height 1.15))))
                  '(org-level-8 ((t (:inherit variable-pitch :foreground "#9e1e86" :height 1.1))))
                  '(org-quote ((t (:inherit org-block :slant normal :weight normal))))
                  ;; markdown faces
                  '(markdown-comment-face ((t (:weight normal :slant italic :strike-through nil))))
                  '(markdown-header-face-1 ((t (:inherit variable-pitch :foreground "#268bd2" :height 1.75))))
                  '(markdown-header-face-2 ((t (:inherit variable-pitch :foreground "medium sea green" :height 1.45))))
                  '(markdown-header-face-3 ((t (:inherit variable-pitch :foreground "#cb4b16" :height 1.2))))
                  ;; helm faces
                  '(helm-selection ((t (:background "#073642" :foreground "goldenrod1" :underline nil))))
                  '(helm-match ((t (:foreground "#b58900"))))
                  ;; line number highlighting 
                  '(line-number-current-line ((t (:inherit default :foreground "goldenrod1"))))
                  ;; '(nlinum-current-line ((t (:inherit default :foreground "goldenrod1"))))
                  '(linum-highlight-face ((t (:inherit default :foreground "goldenrod1"))))
                   ;; '(nlinum-hl-face ((t (:inherit default :foreground "goldenrod1"))))
                  ;; battery faces
                  '(fancy-battery-charging ((t (:foreground "dark blue" :weight bold))))
                  '(fancy-battery-critical ((t (:foreground "dark red" :weight bold))))
                  '(fancy-battery-discharging ((t (:foreground "dark magenta" :weight bold)))))))

             (add-hook 'after-load-theme-hook 'customize-solarized-dark)

        (defun customize-solarized-light ()
        "Customize solarized theme"
        (if (member 'solarized-light custom-enabled-themes)
              (custom-theme-set-faces
              'solarized-light
              ;; fix modeline underline
              '(mode-line ((t (:background "#eee8d5" :foreground "#657b83" :box (:line-width 1 :color "#fdf6e3" :style unspecified) :overline "#fdf6e3" :underline "#fdf6e3"))))
              ;; org faces
              '(org-block ((t (:foreground "#2E8B57"))))
              '(org-block-begin-line ((t (:foreground "#74a8a4" :weight bold :slant normal))))
              '(org-block-end-line ((t (:foreground "#74a8a4" :weight bold :slant normal))))
              '(org-level-1 ((t (:inherit variable-pitch :foreground "#268bd2" :height 1.3))))
              '(org-level-2 ((t (:inherit variable-pitch :foreground "medium sea green" :height 1.2))))
              '(org-level-3 ((t (:inherit variable-pitch :foreground "#cb4b16" :height 1.15))))
              '(org-level-4 ((t (:inherit variable-pitch :foreground "#6c71c4" :height 1.15))))
              '(org-level-8 ((t (:inherit variable-pitch :foreground "#9e1e86" :height 1.1))))
              '(org-quote ((t (:inherit org-block :slant normal :weight normal))))
              ;; markdown faces
              '(markdown-comment-face ((t (:weight normal :slant italic :strike-through nil))))
              '(markdown-header-face-1 ((t (:inherit variable-pitch :foreground "#268bd2" :height 1.75))))
              '(markdown-header-face-2 ((t (:inherit variable-pitch :foreground "medium sea green" :height 1.45))))
              '(markdown-header-face-3 ((t (:inherit variable-pitch :foreground "#cb4b16" :height 1.2))))

              ;; helm faces
              '(helm-selection ((t (:background "#eee8d5" :foreground "#268bd2" :underline nil :weight bold))))
              '(helm-match ((t (:foreground "#cb4b16" :weight bold))))

              ;; '(helm-selection ((t (:foreground "#f7f438" :background "#64b5ea" :underline nil :weight bold))))
              ;; line size 
              '(set-face-attribute 'linum nil :inherit 'fixed-pitch)
              ;; line highlighting 
              '(linum-highlight-face ((t (:inherit default :foreground "#002b36"))))
              ;; '(nlinum-hl-face ((t (:inherit default :foreground "#002b36"))))
              '(line-number-current-line ((t (:inherit default :foreground "#002b36"))))
              ;; '(nlinum-current-line ((t (:inherit default :foreground "#002b36"))))
              ;; battery faces
              '(fancy-battery-charging ((t (:foreground "dark blue" :weight bold))))
              '(fancy-battery-critical ((t (:foreground "dark red" :weight bold))))
              '(fancy-battery-discharging ((t (:foreground "dark magenta" :weight bold))))))
                  )

             (add-hook 'after-load-theme-hook 'customize-solarized-light))
             (load-theme 'solarized-dark t))
 #+END_SRC

***** Gruvbox
 This is a great general-purpose theme. Use it in terminal.

 #+BEGIN_SRC emacs-lisp
 (use-package gruvbox-theme
   :if (not (display-graphic-p))
   :init
   (load-theme 'gruvbox t)
   )
 #+END_SRC 
 

***** Other Themes
Make sure that other themes I like are downloaded and available (not
that I use anything other than solarized :)
#+BEGIN_SRC emacs-lisp
  (defvar packages-appearance '(doom-themes nord-theme solarized-theme
    zenburn-theme molokai-theme darktooth-theme gotham-theme
    ample-theme material-theme leuven-theme
    spacemacs-theme gruvbox-theme forest-blue-theme flatland-theme
    afternoon-theme cyberpunk-theme darkmine-theme
    tao-theme darkokai-theme jazz-theme suscolors-theme
    omtose-phellack-theme atom-one-dark-theme nubox
    color-theme-sanityinc-tomorrow alect-themes kaolin-themes)
  "A list of themes to ensure are installed at launch.")

  (defun appearance-packages-installed-p ()
    (loop for p in packages-appearance
          when (not (package-installed-p p)) do (return nil)
          finally (return t)))

  (unless (appearance-packages-installed-p)
    ;; check for new packages (package versions)
    (message "%s" "Emacs is now refreshing its package themes...")
    (package-refresh-contents)
    (message "%s" " done.")
    ;; install the missing packages
    (dolist (p packages-appearance)
      (when (not (package-installed-p p))
        (package-install p))))

  (provide 'packages-appearance)

#+END_SRC



**** Modeline
***** Hide mode line
 Hide mode line. From http://bzg.fr/emacs-hide-mode-line.html

 #+BEGIN_SRC emacs-lisp
 (defvar-local hidden-mode-line-mode nil)
 (defvar-local hide-mode-line nil)
 (define-minor-mode hidden-mode-line-mode
   "Minor mode to hide the mode-line in the current buffer."
   :init-value nil
   :global t
   :variable hidden-mode-line-mode
   :group 'editing-basics
   (if hidden-mode-line-mode
       (setq hide-mode-line mode-line-format
             mode-line-format nil)
     (setq mode-line-format hide-mode-line
           hide-mode-line nil))
   (force-mode-line-update)
   ;; Apparently force-mode-line-update is not always enough to
   ;; redisplay the mode-line
   (redraw-display)
   (when (and (called-interactively-p 'interactive)
              hidden-mode-line-mode)
     (run-with-idle-timer
      0 nil 'message
      (concat "Hidden Mode Line Mode enabled.  "
              "Use M-x hidden-mode-line-mode to make the mode-line appear."))))

 #+END_SRC
 

***** Doom Modeline
#+BEGIN_SRC emacs-lisp
    (use-package doom-modeline
      :hook (after-init . doom-modeline-init)
      :config
      (setq doom-modeline-bar-width 3
            doom-modeline-height 38
            doom-modeline-buffer-file-name-style 'truncate-upto-project
            doom-modeline-major-mode-color-icon t
            doom-modeline-enable-word-count t
            doom-modeline-persp-name nil
            doom-modeline-minor-modes nil)

       ;; Change the evil tag 
       (setq evil-normal-state-tag   (propertize " 🅝" )
             evil-emacs-state-tag    (propertize " 🅔" )
             evil-insert-state-tag   (propertize " 🅘" )
             evil-replace-state-tag  (propertize " 🅡" )
             evil-motion-state-tag   (propertize " 🅜" )
             evil-visual-state-tag   (propertize " 🅥" )
             evil-operator-state-tag (propertize " 🅞" ))

       (doom-modeline-def-segment evil-state
       "The current evil state. Requires `evil-mode' to be enabled."
       (when (bound-and-true-p evil-local-mode)
         (let ((tag (evil-state-property evil-state :tag t)))
           (propertize tag 'face
                  (if (doom-modeline--active)
                      (cond ((eq tag evil-normal-state-tag)   '(:foreground "DarkGoldenrod2"))
                            ((eq tag evil-emacs-state-tag)    '(:foreground "SkyBlue2"))
                            ((eq tag evil-insert-state-tag)   '(:foreground "chartreuse3"))
                            ((eq tag evil-motion-state-tag)   '(:foreground "plum3"))
                            ((eq tag evil-replace-state-tag)  '(:foreground "red"))
                            ((eq tag evil-visual-state-tag)   '(:foreground "gray"))
                            ((eq tag evil-operator-state-tag) '(:foreground "red"))))))))


      ;; window number faces & formatting
      (doom-modeline-def-segment window-number
        (if (bound-and-true-p window-numbering-mode)
            (propertize (format " %s " (window-numbering-get-number-string))
                        'face (if (doom-modeline--active)
                                  'doom-modeline-active-window-number
                                'doom-modeline-inactive-window-number))
       ""))

      ;; workspace number faces & formatting
      (doom-modeline-def-segment workspace-number
        "The current workspace name or number. Requires `eyebrowse-mode' to be
  enabled."
        (if (and (bound-and-true-p eyebrowse-mode)
                 (< 1 (length (eyebrowse--get 'window-configs))))
            (let* ((num (eyebrowse--get 'current-slot))
                   (tag (when num (nth 2 (assoc num (eyebrowse--get 'window-configs)))))
                   (str (if (and tag (< 0 (length tag)))
                            tag
                          (when num (int-to-string num)))))
              (concat 
                (propertize (format " %s " str) 'face (if (doom-modeline--active) 
                                                          '(:foreground "#2aa198") 
                                                          'doom-modeline-inactive-window-number))
                (propertize (format "|" str) 'face '(:foreground "#586e75"))))

          ""))

       ;;
       ;; Mode lines
       ;;
       (doom-modeline-def-modeline 'cpm/my-doom-mode-line
       '(workspace-number window-number bar evil-state buffer-info vcs matches remote-host parrot selection-info)
       '(misc-info input-method buffer-encoding process checker buffer-position " "))

       (defun setup-custom-doom-modeline ()
       (doom-modeline-set-modeline 'cpm/my-doom-mode-line 'default))

       (add-hook 'doom-modeline-mode-hook 'setup-custom-doom-modeline)
       ;; (doom-modeline-def-modeline 'main
       ;;                             '(workspace-number window-number bar evil-state matches " " buffer-info vcs)
       ;;                             '(process buffer-position " " selection-info))

       ;; (doom-modeline-def-modeline 'minimal
       ;;                             '(bar matches " " buffer-info)
       ;;                             '(media-info major-mode))

       ;; (doom-modeline-def-modeline 'special
       ;;                             '(window-number bar evil-state matches " " buffer-info-simple)
       ;;                             '(process))

       ;; (doom-modeline-def-modeline 'project
       ;;                             '(window-number bar buffer-default-directory buffer-position " " selection-info)
       ;;                             '())

       ;; (doom-modeline-def-modeline 'media
       ;;                             '(window-number bar " %b  ")
       ;;                             '(media-info))

       (defface doom-modeline-active-window-number
       '((t (:inherit warning)))
       "Face for active window number segment of the mode-line."
       :group 'doom-modeline)
       (defface doom-modeline-inactive-window-number
       '((t (:inherit mode-line-emphasis)))
       "Face for inactive window number segment of the mode-line."
       :group 'doom-modeline)

      :custom-face
      (doom-modeline-eyebrowse ((t (:inherit highlight))))
      (doom-modeline-bar ((t (:inherit highlight :inverse-video t :background "#268bd2"))))
      (doom-modeline-inactive-bar ((t (:inherit highlight)))))
#+END_SRC
*** Calender Settings
Settings for using org with calander entries, with help from [[https://www.ict4g.net/adolfo/notes/2015/01/04/emacs-caldav.html][Adolfo Villafiorita]]. 
#+BEGIN_SRC emacs-lisp
    (setq diary-file (concat cpm-local-dir "diary-files/diary"))
    (setq diary-location (concat cpm-local-dir "diary-files/"))
    (setq org-agenda-include-diary t)
    (setq diary-display-function 'diary-fancy-display)
    (add-hook 'diary-list-entries-hook 'diary-include-other-diary-files)
    (add-hook 'diary-list-entries-hook 'diary-sort-entries t)

    ; calendars you want to download
    ; each item links to a remote iCal calendar
    (setq calendars
          '(("work" . "https://p61-calendars.icloud.com/published/2/MTAwNDQ1NjExMTAwNDQ1NvqO3jypeWV-KlipO2n5STkuGJF1NzTG9s64U7XcFCDT")
            ("gcal" . "https://p61-calendars.icloud.com/published/2/AAAAAAAAAAAAAAAAAAAAAPkLfBERGnksMQnVd3nx2P4xR3jfU07OcBrCKtHbDzrtZD3XYz-dZDrvl_XI65XcbaccAbCfSNonTpwKbkC-QI8")
            ("family" . "https://p61-calendars.icloud.com/published/2/AAAAAAAAAAAAAAAAAAAAAH_i27rWIsLXpCfLP97efwOETWdrBMrE6rUBhE6yHj98zRBt932T1OFdmI9ZVsOv3dnt9DUvo9wMQUpsf3F4HtQ")
            ))

    (defun cpm--getcal (url file)
      "Download ics file and add it to file"
      (let ((tmpfile (url-file-local-copy url)))
        (icalendar-import-file tmpfile file)
        (kill-buffer (car (last (split-string tmpfile "/"))))))

    (defun cpm/getcals ()
      "Load a set of ics calendars into emacs diary files"
      (interactive)
      (mapcar #'(lambda (x)
                  (let ((file (concat diary-location (car x)))
                        (url (cdr x)))
                    (message (concat "Loading " url " into " file))
                    (find-file file)
                    ;; (flush-lines "^[& ]") ;; if you import ical as non marking
                    (erase-buffer) ;; to avoid duplicating events
                    (cpm--getcal url file)
                    ))
              calendars)
       ;; send everything to a diary file
       (shell-command-to-string "cat work family gcal > diary"))
       
(defun cpm/refresh-ical ()
 "get ical appointments via batch emacs call"
 (interactive)
 (shell-command-to-string "emacs-get-cals.sh")
 (cpm/org-agenda-refresh))
     
#+END_SRC
*** Exchange Calendar
#+BEGIN_SRC emacs-lisp
  ;; add exchange support
  (use-package excorporate
    :ensure t
    :after org
    :disabled t
    :config
       ;; configure excorporate
   ;; allow opening the exchange calendar with 'e' from calendar 
   (evil-define-key 'motion calendar-mode-map "e" #'exco-calendar-show-day)

   (setq-default
    ;; configure email address and office 365 exchange server adddress for exchange web services
    excorporate-configuration
     (quote
      ("cmclear2@unl.edu" . "https://outlook.office365.com/EWS/Exchange.asmx"))
     ;; integrate emacs diary entries into org agenda
     org-agenda-include-diary t
     )
   ;; activate excorporate and request user/password to start connection
   (excorporate)
   ;; enable the diary integration (i.e. write exchange calendar to emacs diary file -> ~/.emacs.d/diary must exist)
   (excorporate-diary-enable)
   (defun cpm/exco-agenda-update-diary ()
     "call excorporate to update the diary for today"
     (exco-diary-diary-advice (calendar-current-date) (calendar-current-date) #'message "diary updated")
     )

   ;; update the diary every time the org agenda is refreshed
   (add-hook 'org-agenda-cleanup-fancy-diary-hook 'cpm/exco-agenda-update-diary))
#+END_SRC

** Completion
*** Company
#+BEGIN_SRC emacs-lisp
  (use-package company
    :ensure t
    :hook ((prog-mode text-mode) . company-mode)
    :custom-face
    ;; Nicer looking faces
    (company-tooltip-common
      ((t (:inherit company-tooltip :weight bold :underline nil))))
    (company-tooltip-common-selection
      ((t (:inherit company-tooltip-selection :weight bold :underline nil))))
    :init
    (setq company-idle-delay 0.45
          company-minimum-prefix-length 3
          company-require-match nil
          company-dabbrev-ignore-case nil
          company-dabbrev-downcase nil)
    :config
    ;; Default backends
    (add-to-list 'company-backends 'company-files)
    ;; key bindings
    (let ((map company-active-map))
     (define-key map (kbd "TAB") 'company-complete-selection)
     (define-key map (kbd "C-/") 'company-search-candidates)
     (define-key map (kbd "C-M-/") 'company-filter-candidates)
     (define-key map (kbd "C-d") 'company-show-doc-buffer)
     (define-key map (kbd "C-j") 'company-select-next)
     (define-key map (kbd "C-k") 'company-select-previous)
     (define-key map (kbd "C-l") 'company-complete-selection))
  )
#+END_SRC

*** Company-Bibtex
#+BEGIN_SRC emacs-lisp
  (use-package company-bibtex
    :ensure t
    :after company
    :config
    (setq company-bibtex-bibliography "~/Dropbox/Work/bibfile.bib")
    (setq company-bibtex-org-citation-regex "-?@")
    (add-to-list 'company-backends 'company-bibtex))
#+END_SRC
*** Yasnippet
A template system for Emacs http://joaotavora.github.com/yasnippet/
#+BEGIN_SRC emacs-lisp
    (use-package yasnippet
      :hook ((prog-mode text-mode) . yas-minor-mode)
      :commands (yas-expand yas-minor-mode)
      :diminish (yas-minor-mode . " Ⓨ")
      :config
      ;; see https://emacs.stackexchange.com/a/30150/11934
      (defun cpm/yas-org-mode-hook ()
        (setq-local yas-buffer-local-condition
                '(not (org-in-src-block-p t))))
      (add-hook 'org-mode-hook #'cpm/yas-org-mode-hook)

      ;; snippet directory
      (setq yas-snippet-dirs '("~/.emacs.d/.local/snippets/cpm-snippets"
                               yasnippet-snippets-dir))
      ;; the official snippet collection https://github.com/AndreaCrotti/yasnippet-snippets
      (use-package yasnippet-snippets :ensure t :after yasnippet :demand t)

      ;; Adding yasnippet support to company
      (with-eval-after-load 'company-mode
      (add-to-list 'company-backends '(company-yasnippet)))
      (yas-reload-all))


#+END_SRC

** Navigation
*** Bookmarks
Use [[https://www.emacswiki.org/emacs/BookmarkPlus][Bookmark Plus]]. Since it is an emacs wiki package you can't get it from
MELPA. The git mirror is [[https://github.com/emacsmirror/bookmark-plus][here]].
#+BEGIN_SRC emacs-lisp
  (use-package bookmark+
    :commands (bmkp-switch-bookmark-file-create bmkp-set-desktop-bookmark)
    :config
    (setq bookmark-default-file (concat cpm-cache-dir "bookmarks"))
    (setq bmkp-last-as-first-bookmark-file (concat cpm-cache-dir "bookmarks"))
  )
#+END_SRC 

*** Dired 
#+BEGIN_SRC emacs-lisp
  (use-package dired
    :ensure nil
    :commands (dired dired-jump dired-jump-other-window)
    :general
    (:keymaps 'dired-mode-map
     :states '(normal motion)
     "l" #'dired-find-file
     "h" #'dired-up-directory
     "q" #'quit-window)
    :config
    (setq insert-directory-program "gls" dired-use-ls-dired t)
    ;; list directories first
    ;; (setq dired-listing-switches "-al --group-directories-first")
    (setq dired-listing-switches "-laGh1v --group-directories-first")
    ;; don't ask about killing buffer visiting file
    (setq dired-clean-confirm-killing-deleted-buffers t)
    ;; stop asking about recurisve actions
    (setq dired-recursive-copies 'always)
    (setq dired-recursive-deletes 'always))
#+END_SRC
**** Dired Extensions
***** TESTING Dired Plus
Add [[https://www.emacswiki.org/emacs/DiredPlus][extra functionality]] to dired. Not quite sure about this one yet. 
#+BEGIN_SRC emacs-lisp
  (use-package dired+
    :ensure t
    :after dired
    :init
    (setq font-lock-maximum-decoration nil)
    (setq diredp-hide-details-initially-flag nil)
    (diredp-toggle-find-file-reuse-dir 1))
#+END_SRC
***** Peep Dired
[[https://github.com/asok/peep-dired][Quicklook-like]] extension for dired 
#+BEGIN_SRC emacs-lisp
  (use-package peep-dired
    :ensure t
    :commands (peep-dired)
    :general
    (:keymaps 'dired-mode-map
     :states '(normal motion)
     "p" #'peep-dired)
    (:keymaps 'peep-dired-mode-map
     :states '(normal)
     "j" #'peep-dired-next-file
     "k" #'peep-dired-prev-file
     "TAB" #'cpm/peep-dired-open)
    :config
    (add-hook 'peep-dired-hook 'evil-normalize-keymaps)
    (setq peep-dired-ignored-extensions '("mkv" "iso" "mp4" "pdf" "gif")
          peep-dired-max-size 5242880))
;; helper function for opening files in full window          
(defun cpm/peep-dired-open ()
"open files from peep-dired & clean-up"
  (interactive)
  (peep-dired-kill-buffers-without-window)
  (dired-find-file)
  (delete-other-windows))
#+END_SRC 

***** Dired Copy Large Files & Directories
Lets you copy huge files and directories without Emacs freezing up and
with convenient progress bar updates. Courtesy of [[https://oremacs.com/2016/02/24/dired-rsync/][Or Emacs]]. 
#+BEGIN_SRC emacs-lisp
;;;###autoload
(defun ora-dired-rsync (dest)
  (interactive
   (list
    (expand-file-name
     (read-file-name
      "Rsync to:"
      (dired-dwim-target-directory)))))
  ;; store all selected files into "files" list
  (let ((files (dired-get-marked-files
                nil current-prefix-arg))
        ;; the rsync command
        (tmtxt/rsync-command
         "rsync -arvz --progress "))
    ;; add all selected file names as arguments
    ;; to the rsync command
    (dolist (file files)
      (setq tmtxt/rsync-command
            (concat tmtxt/rsync-command
                    (shell-quote-argument file)
                    " ")))
    ;; append the destination
    (setq tmtxt/rsync-command
          (concat tmtxt/rsync-command
                  (shell-quote-argument dest)))
    ;; run the async shell command
    (async-shell-command tmtxt/rsync-command "*rsync*")
    ;; finally, switch to that window
    (other-window 1)))
#+END_SRC




*** Helm
[[https://emacs-helm.github.io/helm/][Helm]] is a robust and well-designed completion framework. It can do [[https://tuhdo.github.io/helm-intro.html][quite a lot]].
**** Helm Settings
#+BEGIN_SRC emacs-lisp 
  (use-package helm
    :general
    ("M-x" 'helm-M-x)
    ("C-h i" 'helm-info)
    :diminish (helm-mode . "")
    :commands (helm-mini helm-M-x helm-find-files helm-find)
    :config
    (progn
      ;; Use helm to provide :ls, unless ibuffer is used
      (evil-ex-define-cmd "buffers" 'helm-buffers-list)
      (set-face-attribute 'helm-source-header nil
      :height 180)
      (setq helm-locate-fuzzy-match nil
            helm-locate-command "mdfind -interpret -name %s %s")
      (setq helm-M-x-fuzzy-match t  ;; Use fuzzy match in helm
            helm-apropos-fuzzy-match t
            helm-buffers-fuzzy-matching t
            helm-imenu-fuzzy-match t
            helm-recentf-fuzzy-match t
            helm-adaptive-mode 1 ; learn from selections
            helm-prevent-escaping-from-minibuffer t
            helm-bookmark-show-location t
            helm-ff-file-name-history-use-recentf t
            helm-find-files-sort-directories t
            helm-display-header-line nil
            helm-move-to-line-cycle-in-source t
            helm-always-two-windows t
            helm-split-window-in-side-p nil
            ;; helm-split-window-default-side 'other
            helm-echo-input-in-header-line t)
      (setq helm-boring-buffer-regexp-list
            (quote
             ("\\Minibuf.+\\*"
              "\\` "
              "\\*.+\\*"
              )))
      (setq helm-white-buffer-regexp-list
            (quote
             ("\\*magit:"
              "\\*eshell"
              "\\*ansi-term"
              "\\*Pandoc Output*"
              "\\*compilation*"
              "\\*dashboard*"
              )))
      (helm-autoresize-mode 1)
      (setq helm-autoresize-max-height 40)
      (setq helm-autoresize-min-height 35)
      ;; (define-key helm-map (kbd "C-a") (kbd "RET"))
      ;;; helm vim-bindings in buffer ;;
      (map! (:map helm-map
        "TAB"   'helm-execute-persistent-action ; rebind tab to do persistent action
        "C-i"   'helm-execute-persistent-action ; make TAB works in terminal
        "C-z"   'helm-select-action ; list actions using C-z
        "C-j"   'helm-next-line
        "C-k"   'helm-previous-line
        "C-h"   'helm-next-source
        "C-l"   'helm-previous-source
        "C-S-h" 'describe-key)))
      (helm-mode 1))

  ;; use helm follow mode for search
  (with-eval-after-load 'helm-regexp
  (setq helm-source-occur
        (helm-make-source "Occur" 'helm-source-multi-occur
          :follow 1)))
#+END_SRC
**** Hide Mode Lines in Helm
Hide modelines of other windows while helm is open, again from
https://github.com/hatschipuh/better-helm.

#+BEGIN_SRC emacs-lisp
  (defvar my-helm-bottom-buffers nil
	"List of bottom buffers before helm session.
	Its element is a pair of `buffer-name' and `mode-line-format'.")

  (defun my-helm-bottom-buffers-init ()
	(setq-local mode-line-format (default-value 'mode-line-format))
	(setq my-helm-bottom-buffers
	  (cl-loop for w in (window-list)
		   when (window-at-side-p w 'bottom)
		   collect (with-current-buffer (window-buffer w)
				 (cons (buffer-name) mode-line-format)))))

  (defun my-helm-bottom-buffers-hide-mode-line ()
	(setq-default cursor-in-non-selected-windows nil)
	(mapc (lambda (elt)
		(with-current-buffer (car elt)
		  (setq-local mode-line-format nil)))
	  my-helm-bottom-buffers))

  (defun my-helm-bottom-buffers-show-mode-line ()
	(setq-default cursor-in-non-selected-windows t)
	(when my-helm-bottom-buffers
	  (mapc (lambda (elt)
		  (with-current-buffer (car elt)
		(setq-local mode-line-format (cdr elt))))
		my-helm-bottom-buffers)
	  (setq my-helm-bottom-buffers nil)))

  (defun my-helm-keyboard-quit-advice (orig-func &rest args)
	(my-helm-bottom-buffers-show-mode-line)
	(apply orig-func args))

  (add-hook 'helm-before-initialize-hook #'my-helm-bottom-buffers-init)
  (add-hook 'helm-after-initialize-hook #'my-helm-bottom-buffers-hide-mode-line)
  (add-hook 'helm-exit-minibuffer-hook #'my-helm-bottom-buffers-show-mode-line)
  (add-hook 'helm-cleanup-hook #'my-helm-bottom-buffers-show-mode-line)
  (advice-add 'helm-keyboard-quit :around #'my-helm-keyboard-quit-advice)
#+END_SRC
**** Hide Minibuffer in Helm
Hide minibuffer while helm is active

#+BEGIN_SRC emacs-lisp
  (defun my-helm-hide-minibuffer-maybe ()
	(when (with-helm-buffer helm-echo-input-in-header-line)
	  (let ((ov (make-overlay (point-min) (point-max) nil nil t)))
	(overlay-put ov 'window (selected-window))
	(overlay-put ov 'face (let ((bg-color (face-background 'default nil)))
				`(:background ,bg-color :foreground ,bg-color)))
	(setq-local cursor-type nil))))
  (add-hook 'helm-minibuffer-set-up-hook #'helm-hide-minibuffer-maybe)
#+END_SRC
**** Helm packages
***** Helm ag
#+begin_src emacs-lisp
  (use-package helm-ag  
    ;; :ensure t
    :load-path "~/.emacs.d/.local/elisp/helm-ag/"
    :commands (helm-ag helm-ag-buffers helm-ag-this-file helm-do-ag helm-ag-project-root cpm/helm-files-do-ag cpm/helm-files-search-current-directory)
    :custom
    (helm-follow-mode-persistent t)
    :config
    (setq helm-ag-base-command "rg --no-heading")
    (setq helm-ag-fuzzy-match t))
#+end_src
***** Helm descbinds
#+begin_src emacs-lisp 
(use-package helm-descbinds 
  :commands helm-descbinds
  :config
  (setq helm-descbinds-window-style 'same-window)
  (add-hook 'helm-mode-hook 'helm-descbinds-mode))
#+end_src
***** Helm git list
#+begin_src emacs-lisp
(use-package helm-ls-git :commands helm-ls-git-ls)
#+end_src
***** Helm hunks
#+BEGIN_SRC emacs-lisp
  (use-package helm-hunks :commands helm-hunks)

#+END_SRC
***** Helm swoop
[[https://github.com/ShingoFukuyama/helm-swoop][Search]] on steroids
#+begin_src emacs-lisp
  (use-package helm-swoop
    :commands (helm-swoop-without-pre-input helm-swoop-back-to-last-point helm-multi-swoop helm-multi-swoop-all)
    :load-path "~/.emacs.d/.local/elisp/helm-swoop/"
    :config
    (setq helm-swoop-use-fuzzy-match t)
    (setq helm-swoop-split-with-multiple-windows t))
#+end_src
***** DISABLED Helm flyspell
CLOSED: [2018-04-16 Mon 15:08]

Use helm with flyspell
#+begin_src emacs-lisp 
  (use-package helm-flyspell
    :disabled t
    ;; :if (not noninteractive)
    :commands helm-flyspell-correct
    :after flyspell
    :demand t
    :config
    (general-define-key :keymaps 'flyspell-mode-map
       "C-;" 'helm-flyspell-correct))
#+end_src
***** Helm recent directories
Recent directories
#+begin_src emacs-lisp
(use-package helm-dired-recent-dirs
    :commands helm-dired-recent-dirs-view)
#+end_src
***** Helm files
#+begin_src emacs-lisp 
  (use-package helm-files
    :ensure nil
    :defer t
    :config
    (setq helm-ff-skip-boring-files t)
    (setq helm-idle-delay 0.05)
    (setq helm-input-idle-delay 0.05)
    (setq helm-ff-file-name-history-use-recentf t)
    (setq helm-boring-file-regexp-list
    '("\\.git$" "\\.hg$" "\\.svn$" "\\.CVS$" "\\._darcs$" "\\.la$" "\\.o$" "~$"
      "\\.so$" "\\.a$" "\\.elc$" "\\.fas$" "\\.fasl$" "\\.pyc$" "\\.pyo$")))
#+end_src
***** Helm interface for themes (helm-themes)
#+begin_src emacs-lisp
  (use-package helm-themes
    :commands helm-themes)
  (defadvice helm-themes--load-theme (after helm-themes--load-theme-after activate) (require 'powerline) (powerline-reset)) 
  ;; (ad-unadvise 'helm-themes--load-theme)
#+end_src
***** Helm Projectile
#+BEGIN_SRC emacs-lisp
(use-package helm-projectile
 :commands (helm-projectile-switch-to-buffer
            helm-projectile-find-dir
            helm-projectile-dired-find-dir
            helm-projectile-recentf
            helm-projectile-find-file
            helm-projectile-grep
            helm-projectile
            helm-projectile-switch-project)
 :init
 (setq projectile-switch-project-action 'helm-projectile)
 :config 
 (helm-projectile-on))

#+END_SRC
*** Ivy
Generic completion frontend that's similar to helm but less enormous of a code base. Let's install and enable it.

#+BEGIN_SRC emacs-lisp 
(use-package ivy 
  :diminish ivy-mode
  :general
  (:keymaps 'ivy-minibuffer-map
    "C-j" 'ivy-next-line
    "C-k" 'ivy-previous-line)
  :config
  (setq ivy-use-virtual-buffers t
        ;; number of result lines to display
        ivy-height 10
        ;; no regexp by default
        ivy-initial-inputs-alist nil
        ivy-re-builders-alist
        ;; allow input not in order
        '((t   . ivy--regex-ignore-order))
        ivy-count-format "%d/%d "))
#+END_SRC
*** Counsel
Counsel allows us to utilize ivy by replacing many built-in and common functions
with richer versions. 

#+BEGIN_SRC emacs-lisp 
(use-package counsel-projectile :commands counsel-projectile-bookmark)
(use-package counsel
  :commands (council-org-goto jump-in-buffer counsel-org-tag)
  :config
  (map! (:map counsel-mode-map
         :ni "C-j" #'ivy-next-line
         :ni "C-k" #'ivy-previous-line)))

#+END_SRC
*** Swiper
Swiper is an awesome searching utility with a quick preview. Let's install it and
load it when =swiper= or =swiper-all= is called.

#+BEGIN_SRC emacs-lisp
(use-package swiper
  :commands (swiper swiper-all))
#+END_SRC
*** TESTING Imenu-List
#+BEGIN_SRC emacs-lisp
  (use-package imenu-list
    :ensure t
    :commands (imenu-list-smart-toggle imenu-list-minor-mode)
    :config
    (setq imenu-list-focus-after-activation t
          imenu-list-auto-resize t
          imenu-list-position 'left)
    :custom-face
    (imenu-list-entry-face-0 ((t (:inherit imenu-list-entry-face :foreground "#269bd2"))))
    (imenu-list-entry-face-1 ((t (:inherit imenu-list-entry-face :foreground "medium sea green"))))
    (imenu-list-entry-face-2 ((t (:inherit imenu-list-entry-face :foreground "#cb4b16"))))
    (imenu-list-entry-face-3 ((t (:inherit imenu-list-entry-face :foreground "#b58900")))))
#+END_SRC

*** Historian
Completion [[https://github.com/PythonNut/historian.el][history]]
#+BEGIN_SRC emacs-lisp
(use-package historian
  :defer 5
  :load-path "~/.emacs.d/.local/elisp/historian"
  :config
  (setq historian-save-file (concat cpm-cache-dir ".historian"))
  (historian-mode 1))
#+END_SRC
*** Saveplace
#+BEGIN_SRC emacs-lisp
  (use-package saveplace
    :init
    (save-place-mode 1)
    :config
    (setq save-place-file (concat cpm-cache-dir "saved-places")
    ;; (setq save-place-forget-unreadable-files nil)
  ))
#+END_SRC
*** Ace Window
Ace [[https://github.com/abo-abo/ace-window][window management]]. 
#+BEGIN_SRC emacs-lisp
(use-package ace-window
  :commands (ace-window ace-swap-window aw-flip-window cpm/swap-windows))
#+END_SRC
*** Avy
#+BEGIN_SRC emacs-lisp
(use-package avy
  :commands (avy-goto-char))
#+END_SRC
*** Windows
**** Golden Ratio
Automatic resizing of Emacs windows to the [[https://github.com/roman/golden-ratio.el][golden ratio]]
#+BEGIN_SRC emacs-lisp
  (use-package golden-ratio
    :load-path "~/.emacs.d/.local/elisp/golden-ratio.el/"
    :ensure nil
    ;; :after (:any perspective helm nameframe projectile) 
    ;; :demand t
    :defer 3
    :config
    (setq golden-ratio-exclude-buffer-names '("*Ilist*" "*Deft*"))
    (setq golden-ratio-exclude-buffer-regexp '("Ilist"))
    ;; inhibit in helm windows
    (defun cpm--helm-alive-p ()
    (if (boundp 'helm-alive-p)
        (symbol-value 'helm-alive-p)))
        (add-to-list 'golden-ratio-inhibit-functions 'cpm--helm-alive-p)
    ;;fix for ispell
    (defun cpm--ispell-alive-p ()
      (get-buffer ispell-choices-buffer))
    (add-to-list 'golden-ratio-inhibit-functions 'cpm--ispell-alive-p)
    ;; use golden ratio for the following    
    (setq golden-ratio-extra-commands
          (append golden-ratio-extra-commands
                  '(evil-window-left
                    evil-window-right
                    evil-window-up
                    evil-window-down
                    buf-move-left
                    buf-move-right
                    buf-move-up
                    buf-move-down
                    window-number-select
                    select-window
                    select-window-1
                    select-window-2
                    select-window-3
                    select-window-4
                    select-window-5
                    select-window-6
                    select-window-7
                    select-window-8
                    select-window-9
                    previous-multiframe-window
                    magit-status)))
    (golden-ratio-mode 1))
#+END_SRC
**** Window Numbering
Numbered window shortcuts for Emacs
#+BEGIN_SRC emacs-lisp
   (use-package window-numbering
     :defer 1
     :config
     (defun window-numbering-install-mode-line (&optional position)
     "Do nothing, the display is handled by the powerline.")
     (setq window-numbering-auto-assign-0-to-minibuffer nil)
     
     (window-numbering-mode 1)

  ;; make sure neotree is always 0
   (defun spacemacs//window-numbering-assign ()
     "Custom number assignment for neotree."
     (when (and (boundp 'neo-buffer-name)
                (string= (buffer-name) neo-buffer-name)
                ;; in case there are two neotree windows. Example: when
                ;; invoking a transient state from neotree window, the new
                ;; window will show neotree briefly before displaying the TS,
                ;; causing an error message. the error is eliminated by
                ;; assigning 0 only to the top-left window
                (eq (selected-window) (window-at 0 0)))
       0))

   ;; using lambda to work-around a bug in window-numbering, see
   ;; https://github.com/nschum/window-numbering.el/issues/10
   (setq window-numbering-assign-func
         (lambda () (spacemacs//window-numbering-assign))))
#+END_SRC
**** Unset window keys
A nice tip from [[http://pragmaticemacs.com/emacs/use-your-digits-and-a-personal-key-map-for-super-shortcuts/][Pragmatic emacs]]
#+BEGIN_SRC emacs-lisp
;; unset C- and M- digit keys
(dotimes (n 10)
  (global-unset-key (kbd (format "C-%d" n)))
  (global-unset-key (kbd (format "M-%d" n)))
  )
#+END_SRC
**** Windmove
#+BEGIN_SRC emacs-lisp
(use-package windmove
  :commands (windmove-up windmove-down windmove-left windmove-right)
  :config
  (defun cpm/split-window-right-and-focus ()
  "Split the window horizontally and focus the new window."
  (interactive)
  (split-window-right)
  (windmove-right))
  (defun cpm/split-window-below-and-focus ()
  "Split the window vertically and focus the new window."
  (interactive)
  (split-window-below)
  (windmove-down))
  ;; add edit mode keybindings
  (global-set-key (kbd "<H-up>")     'windmove-up)
  (global-set-key (kbd "<H-down>")   'windmove-down)
  (global-set-key (kbd "<H-left>")   'windmove-left)
  (global-set-key (kbd "<H-right>")  'windmove-right)
  )
#+END_SRC
**** Winner
Winner mode is a [[https://www.emacswiki.org/emacs/WinnerMode][built-in package]] for restoring window configurations
#+BEGIN_SRC emacs-lisp
(use-package winner
 :ensure nil
 :commands (winner-undo winner-redo winner-mode)
 :config
 (winner-mode 1))
#+END_SRC
**** Other window
Move to other window
#+BEGIN_SRC emacs-lisp
(general-define-key :states '(normal motion visual insert)
  "C-o" 'other-window)
#+END_SRC
*** Recent files
#+BEGIN_SRC emacs-lisp
  (use-package recentf
    :commands (helm-recentf)
    :config 
    (setq recentf-save-file (concat cpm-etc-dir "recentf"))
    ;; remove agenda files from list.
    (setq recentf-exclude '("projects.org"
                            "inbox.org"
                            "someday.org"
                            "bookmark")
          recentf-max-saved-items 300
          recentf-max-menu-items 10))
#+END_SRC

 

*** TESTING Treemacs
[[https://github.com/Alexander-Miller/treemacs][Treemacs]] is a file and project explorer 
#+BEGIN_SRC emacs-lisp
  (use-package treemacs
    :ensure t
    :commands treemacs
    :init
    (with-eval-after-load 'winum
      (define-key winum-keymap (kbd "M-0") #'treemacs-select-window))
    :config
    (progn
      (setq treemacs-collapse-dirs              (if (executable-find "python") 3 0)
            treemacs-file-event-delay           5000
            treemacs-follow-after-init          t
            treemacs-follow-recenter-distance   0.1
            treemacs-goto-tag-strategy          'refetch-index
            treemacs-indentation                2
            treemacs-indentation-string         " "
            treemacs-is-never-other-window      nil
            treemacs-no-png-images              nil
            treemacs-project-follow-cleanup     nil
            treemacs-persist-file               (concat cpm-cache-dir "treemacs-persist") 
            treemacs-recenter-after-file-follow nil
            treemacs-recenter-after-tag-follow  nil
            treemacs-show-hidden-files          t
            treemacs-silent-filewatch           nil
            treemacs-silent-refresh             nil
            treemacs-sorting                    'alphabetic-desc
            treemacs-space-between-root-nodes   t
            treemacs-tag-follow-cleanup         t
            treemacs-tag-follow-delay           1.5
            treemacs-width                      35)

      (treemacs-follow-mode t)
      (treemacs-filewatch-mode t)
      (pcase (cons (not (null (executable-find "git")))
                   (not (null (executable-find "python3"))))
        (`(t . t)
         (treemacs-git-mode 'extended))
        (`(t . _)
         (treemacs-git-mode 'simple)))))
    ;; :bind
    ;; (:map global-map
    ;;       ("M-0"       . treemacs-select-window)
    ;;       ("C-x t 1"   . treemacs-delete-other-windows)
    ;;       ("C-x t t"   . treemacs)
    ;;       ("C-x t B"   . treemacs-bookmark)
    ;;       ("C-x t C-t" . treemacs-find-file)
    ;;       ("C-x t M-t" . treemacs-find-tag)))

  (use-package treemacs-evil
    :after treemacs evil
    :ensure t)

  (use-package treemacs-projectile
    :after treemacs projectile
    :ensure t)
#+END_SRC

*** Other UI
**** Centered Cursor Mode
 Keep the cursor centered in the screen
 #+BEGIN_SRC emacs-lisp
     (use-package centered-cursor-mode
       :diminish centered-cursor-mode
       :hook ((markdown-mode org-mode) . centered-cursor-mode)
       :commands (centered-cursor-mode
                  global-centered-cursor-mode)
       :config
       (progn
         (setq ccm-recenter-at-end-of-file t
               ccm-ignored-commands '(mouse-drag-region
                                      mouse-set-point
                                      widget-button-click
                                      scroll-bar-toolkit-scroll
                                      evil-mouse-drag-region))))
 #+END_SRC
 
**** Namespaced Keybindings
I use a lot of keybindings, with <SPC> as my "leader" key.
***** Application Keybindings
#+BEGIN_SRC emacs-lisp
(general-define-key
  :states '(normal motion visual insert emacs)
  :keymaps 'override
  :prefix "SPC"
  :non-normal-prefix "C-SPC"
 
  "a"  '(:ignore t :which-key "Applications") 
  "ac" '(:ignore t :which-key "Cmus")
  "ad" 'dired-jump
  "ae" 'eshell
  "am" 'multi-term
  "ar" 'ranger
  "as" 'sane-term
  "aw" 'wttrin
  )
#+END_SRC
***** Buffer Keybindings
#+BEGIN_SRC emacs-lisp
  (general-define-key
    :states '(normal motion visual insert emacs)
    :keymaps 'override
    :prefix "SPC"
    :non-normal-prefix "C-SPC"

    "b"  '(:ignore t :which-key "Buffers")
    "bb" 'helm-mini
    "bc" 'cpm/copy-whole-buffer-to-clipboard
    "bD" 'kill-buffer-and-window
    "bd" 'cpm/kill-this-buffer
    "be" 'erase-buffer
    ;; "bf" 'cpm/browse-file-directory
    "bf" 'reveal-in-osx-finder
    "bj" 'cpm/jump-in-buffer
    "bk" 'evil-delete-buffer
    "bK" 'crux-kill-other-buffers
    "bn" 'evil-buffer-new
    "bN" 'cpm/new-buffer-new-frame
    "br" 'revert-buffer
    "bR" 'crux-rename-buffer-and-file
    "bt" 'open-dir-in-iterm
    )
#+END_SRC
***** Comment Keybindings
#+BEGIN_SRC emacs-lisp
  (general-define-key
    :states '(normal motion visual insert emacs)
    :keymaps 'override
    :prefix "SPC"
    :non-normal-prefix "C-SPC"

    "c"   '(:ignore t :which-key "Commenting")
    "cb"  '(nil :wk "Block Wrap")
    "cbo" 'org-block-wrap
    "cby" 'cpm/yaml-wrap
    "cc"  'evil-commentary
    "cl"  'evil-commentary-line
    "cy"  'evil-commentary-yank-line
   )
#+END_SRC
***** Config Keybindings
#+BEGIN_SRC emacs-lisp
(general-define-key
  :states '(normal motion visual insert emacs)
  :keymaps 'override
  :prefix "SPC"
  :non-normal-prefix "C-SPC"

  "C"  '(:ignore t :which-key "Config")
  "Cc" 'goto-config.org
  "Cd" 'goto-dotfiles.org
  "CD" 'goto-emacs-dir
  "Ck" 'cpm/compile-dotemacs
  "CK" 'cpm/delete-byte-compiled-files
  "Cl" 'load-config
  "Ci" 'goto-init.el
  "Co" 'goto-org-files
  "Cp" 'goto-pandoc-config
  "Cs" 'goto-custom.el
  )

#+END_SRC
***** File Keybindings
#+BEGIN_SRC emacs-lisp
(general-define-key
  :states '(normal motion visual insert emacs)
  :keymaps 'override
  :prefix "SPC"
  :non-normal-prefix "C-SPC"

    "f"  '(:ignore t :which-key "Files")
    "ff" 'helm-find-files
    "fl" 'helm-locate
    "fo" 'crux-open-with
    "fs" 'save-buffer
    "fr" 'helm-recentf
    "fy" 'cpm/show-and-copy-buffer-filename
    )
#+END_SRC
***** General Keybindings
#+BEGIN_SRC emacs-lisp
  (general-define-key
   :states '(normal motion visual insert emacs)
   :keymaps 'override
   :prefix "SPC"
   :non-normal-prefix "C-SPC"

     "A" 'helm-apropos
     "B" #'cpm/dashboard
     "?" 'helm-descbinds
     "<SPC>" 'helm-M-x
     ;; "d" #'deer
     "d" #'dired-jump
     "D" #'dired-jump-other-window
     ;; "D" #'cpm/deer-split-window
     "E" 'cpm/call-emacs
     "e" 'server-edit
     "G" 'general-describe-keybindings
     "j" 'avy-goto-char
     "k" 'helm-show-kill-ring
     "l" 'cpm/last-search-buffer
     ;; "N" 'research-notes
     "n" 'big-notes
     "r" 'cpm/resume-last-jump
     "S" 'hydra-spelling/body
     ;; "W" 'woman
     "#" 'universal-argument
     "`" 'beacon-blink
     "'" 'shell-pop
     "." 'quick-commit
     ";" 'evil-commentary-line
     "[" 'cpm/previous-user-buffer
     "]" 'cpm/next-user-buffer
     "TAB" 'switch-to-previous-buffer
     )
#+END_SRC
***** Make/Compile Keybindings
#+BEGIN_SRC emacs-lisp
(general-define-key
  :states '(normal motion visual insert emacs)
  :keymaps 'override
  :prefix "SPC"
  :non-normal-prefix "C-SPC"

  "M"   '(:ignore t :which-key "Make/Compile")
  "Mm"  'compile
  "MM"  'multi-compile-run
  "Me"  'compile-goto-error
  "Mk"  'kill-compilation
  "Mr"  'recompile
  "Mv"  'cpm/make-move
)
#+END_SRC
***** Markdown Keybindings
Evil keybindings from [[https://github.com/Somelauw/evil-markdown][Somelauw/evil-markdown]]
#+BEGIN_SRC emacs-lisp
  (use-package evil-markdown
    :ensure nil
    :load-path "~/.emacs.d/.local/elisp/evil-markdown"
    :after markdown-mode)
#+END_SRC
Evil mode markdown commmands
#+BEGIN_SRC emacs-lisp
  (general-define-key
    :states '(normal motion visual)
    :keymaps 'markdown-mode-map
    :prefix "SPC m" 
    :non-normal-prefix "C-SPC m"

    ""    '(nil :which-key "Local Leader")
    "c"  '(:ignore t :which-key "command")
    "h"  '(:ignore t :which-key "insert")
    "i"  '(:ignore t :which-key "lists")
    "x"  '(:ignore t :which-key "text")

    ;; Movement
    "{"   'markdown-backward-paragraph
    "}"   'markdown-forward-paragraph

    ;; Completion, and Cycling
    "]"   'markdown-complete

    ;; Indentation
    ">"   'markdown-indent-region
    "<"   'markdown-exdent-region

    ;; Buffer-wide commands
    "c]"  'markdown-complete-buffer
    "cc"  'multi-compile-run
    "cm"  'markdown-other-window
    "cn"  'markdown-cleanup-list-numbers
    "co"  'markdown-open
    "cp"  'markdown-preview
    "cr"  'markdown-check-refs
    "cv"  'markdown-export-and-preview
    "cw"  'markdown-kill-ring-save

    ;; headings
    "hi"  'markdown-insert-header-dwim
    "hI"  'markdown-insert-header-setext-dwim
    "h1"  'markdown-insert-header-atx-1
    "h2"  'markdown-insert-header-atx-2
    "h3"  'markdown-insert-header-atx-3
    "h4"  'markdown-insert-header-atx-4
    "h5"  'markdown-insert-header-atx-5
    "h6"  'markdown-insert-header-atx-6
    "h!"  'markdown-insert-header-setext-1
    "h@"  'markdown-insert-header-setext-2

    ;; Insertion of common elements
    "-"   'markdown-insert-hr
    "if"  'markdown-insert-footnote
    "ii"  'markdown-insert-image
    "ik"  'spacemacs/insert-keybinding-markdown
    "iI"  'markdown-insert-reference-image
    "il"  'markdown-insert-link
    "iL"  'markdown-insert-reference-link-dwim
    "iw"  'markdown-insert-wiki-link
    "iu"  'markdown-insert-uri

    ;; Element removal
    "k"   'markdown-kill-thing-at-point

    ;; Numbering
    "n"   #'markdown-cleanup-list-numbers
    ;; List editing
    "li"  'markdown-insert-list-item

    ;; region manipulation
    "xb"  'markdown-insert-bold
    "xi"  'markdown-insert-italic
    "xc"  'markdown-insert-code
    "xC"  'markdown-insert-gfm-code-block
    "xq"  'markdown-insert-blockquote
    "xQ"  'markdown-blockquote-region
    "xp"  'markdown-insert-pre
    "xP"  'markdown-pre-region

    ;; Following and Jumping
    "N"   'markdown-next-link
    "f"   'markdown-follow-thing-at-point
    "P"   'markdown-previous-link
    "<RET>" 'markdown-do

    "gj"    #'markdown-next-visible-heading
    "gk"    #'markdown-previous-visible-heading
    ;; Assumes you have a markdown renderer plugin in chrome
    "M-r"   #'browse-url-of-file
    "h]"    #'markdown-next-visible-heading
    "h["    #'markdown-previous-visible-heading
    "p["    #'markdown-promote
    "p]"    #'markdown-demote
    "l["    #'markdown-next-link
    "l]"    #'markdown-previous-link
   ) 

  (general-define-key
    :states '(normal motion insert)
    :keymaps 'markdown-mode-map

    "s-*"      #'markdown-insert-list-item
    "s-b"      #'markdown-insert-bold
    "s-i"      #'markdown-insert-italic

    "M--"      #'markdown-insert-hr
    "M-RET"    #'markdown-insert-header
    )
    
  (general-define-key
    :states '(normal motion)
    :keymaps 'markdown-mode-map

    "RET"    #'markdown-follow-thing-at-point)

#+END_SRC
***** Miscellaneous Keybindings
#+BEGIN_SRC emacs-lisp
;; Show which-key top-level bindings
(global-set-key (kbd "H-k") 'which-key-show-top-level)
;; override evil insert for kill line
(general-define-key :states '(insert) "C-k" 'kill-line)
#+END_SRC
***** Package  Keybindings
Keybindings for managing packages
#+BEGIN_SRC emacs-lisp
(general-define-key
  :states '(normal motion visual insert emacs)
  :keymaps 'override
  :prefix "SPC"
  :non-normal-prefix "C-SPC"

    "P" '(:ignore t :which-key "Packages")
    "Pl" 'paradox-list-packages
    "Pu" 'paradox-upgrade-packages
    "Pc" 'finder-commentary
    )
#+END_SRC
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-h C-c") 'finder-commentary)
#+END_SRC
***** Project Keybindings
#+BEGIN_SRC emacs-lisp
  (general-define-key
    :states '(normal visual emacs motion)
    :keymaps 'override
    :prefix "SPC"
    :non-normal-prefix "C-SPC"

      "p" '(:ignore t :which-key "Projects")
      "p!"  'projectile-run-shell-command-in-root
      "p&"  'projectile-run-async-shell-command-in-root
      "pa"  'projectile-toggle-between-implementation-and-test
      "pb"  'helm-projectile-switch-to-buffer
      "pc"  'projectile-compile-project
      "pC"  'desktop+-create
      "pd"  'helm-projectile-find-dir
      "pD"  'cpm/hydra-desktop
      ;; "pD"  'projectile-dired
      "pf"  'helm-projectile-find-file
      "pF"  #'cpm/helm-projectile-find-file-other-window
      "pg"  'cpm/goto-projects
      "ph"  'helm-projectile
      "pJ"  'bmkp-desktop-jump
      "pG"  'projectile-regenerate-tags
      "pI"  'projectile-invalidate-cache
      "pk"  'projectile-kill-buffers
      ;; "pl"  'desktop+-load
      "po"  'projectile-multi-occur
      "pp"  'helm-projectile-switch-project
      "pP"  'projectile-persp-switch-project
      ;; "pp"  'helm-persp-projectile-switch-project
      "pr"  'helm-projectile-recentf
      "pR"  'projectile-replace
      "pS"  'persp-switch
      "ps"  '(:ignore t :which-key "Frames")
      "pss"  'nameframe-switch-frame
      "ps1" #'cpm/load-phil101
      "ps2" #'cpm/load-phil232
      "ps5" #'cpm/load-phil105
      "ps8" #'cpm/load-phil871
      "psa" #'cpm/load-kant-apperception-substance
      "psb" #'(:ignore t :which-key "Books")
      "psba" #'cpm/load-kant-agency-book
      "psbr" #'cpm/load-kant-rationality-book
      "psc" #'cpm/load-emacs-config
      "psf" #'cpm/load-kant-free-thought
      "psr" #'cpm/load-kant-reflection
      "pst" #'cpm/load-org-agenda-todo
      "psw" #'cpm/load-website
      "psz" #'cpm/load-zettelkasten
      "pt"  #'cpm/search-todo-markers
      "pT"  'projectile-find-test-file
      "pv"  'hydra-persp/body
      "pV"  'projectile-vc
      "py"  'projectile-find-tag
    )
#+END_SRC
***** Quit Keybindings
#+BEGIN_SRC emacs-lisp
 (general-define-key
  :states '(normal motion visual insert emacs)
  :keymaps 'override
  :prefix "SPC"
  :non-normal-prefix "C-SPC"
 
    "q"  '(:ignore t :which-key "Quit")
    "qq" 'cpm/save-desktop-save-buffers-kill-emacs
    "qQ" 'evil-quit-all
    "qr" 'restart-emacs
    )
#+END_SRC
***** Search Keybindings
#+BEGIN_SRC emacs-lisp
 (general-define-key
  :states '(normal motion visual insert emacs)
  :keymaps 'override
  :prefix "SPC"
  :non-normal-prefix "C-SPC"
 
    "s" '(:ignore t :which-key "Search")
    "sa" 'helm-org-rifle-agenda-files
    "sd" 'cpm/helm-files-search-current-directory ; search current buffer's directory
    "sD" 'cpm/helm-files-do-ag ; search with directory input
    "sb" 'helm-ag-buffers
    "sf" 'helm-do-ag-this-file
    "sj" 'cpm/forward-or-backward-sexp
    "sk" 'helm-show-kill-ring
    "sl" 'last-search-buffer
    "so" 'helm-occur
    "sp" 'helm-ag-project-root
    "sr" #'vr/query-replace
    "sR" 'helm-org-rifle
    ;; "ss" 'helm-swoop-without-pre-input ;; search with swoop in file
    "ss" #'cpm/flyspell-ispell-goto-next-error ;; search for next spelling error
    "st" #'cpm/search-file-todo-markers ;; search for TODOs in file w/helm-ag
    "sT" #'cpm/search-todo-markers ;; search todo markers in directory w/helm-ag
    "/"  'cpm/helm-files-search-current-directory   ;; search in directory with word prompt
     )
#+END_SRC


***** Toggle Keybindings
#+BEGIN_SRC emacs-lisp
  (general-define-key
    :states '(normal motion visual insert emacs)
    :keymaps 'override
    :prefix "SPC"
    :non-normal-prefix "C-SPC"

      "t"  '(:ignore t :which-key "Toggles")
      "ta" 'company-mode
      "tb" 'buffer-line-mode
      "tB" 'beacon-mode
      "tc" 'centered-cursor-mode
      "tC" 'centered-window-mode
      ;; "td" 'cpm/osx-toggle-menubar-theme
      ;; "tf" 'toggle-serif
      "tF" 'toggle-frame-maximized
      "tg" 'git-gutter-mode
      "tG" 'golden-ratio-mode 
      "th" 'hl-line-mode
      "tH" 'hidden-mode-line-mode
      "te" 'toggle-indicate-empty-lines
      "tE" 'eldoc-mode
      "tM" #'treemacs
      "tm" #'cpm/toggle-display-markup
      ;; "tn" 'nlinum-mode
      "tn" 'display-line-numbers-mode
      "tN" 'org-numbers-overlay-mode
      "to" #'imenu-list-smart-toggle
      ;; "to" 'org-toggle-link-display
      ;; "tO" 'outline-toc-mode
      "tp" 'smartparens-mode
      "tP" 'show-paren-mode 
      "tr" 'rainbow-identifiers-mode
      "ts" 'flyspell-mode
      "tS" 'ispell-buffer
      "tt" 'toggle-dark-light-theme
      "tT" 'helm-themes
      "tw" 'writeroom-mode
      "tz" 'zone
      ;; "tt" 'counsel-load-theme
    )
#+END_SRC
***** User Keybindings
#+BEGIN_SRC emacs-lisp
  (general-define-key
    :states '(normal motion visual insert emacs)
    :keymaps 'override
    :prefix "SPC"
    :non-normal-prefix "C-SPC"

      "u"  '(:ignore t :which-key "User")
      "uA" '(:ignore t which-key "Agenda Files")
      "uAa" #'cpm/goto-reading.org
      "uAc" #'cpm/goto-classes.org
      "uAf" #'cpm/goto-org-files
      "uAi" #'cpm/goto-inbox.org
      "uAl" #'cpm/goto-links.org
      "uAr" #'cpm/goto-reference.org
      "uAp" #'cpm/goto-projects.org
      "uAs" #'cpm/goto-someday.org
      "uAt" #'cpm/goto-todo
      "ua"  '(:ignore t :which-key "Agenda")
      "uaa" 'cpm/jump-to-org-super-agenda
      "uaw" 'cpm/jump-to-week-agenda
      "um" 'cpm/org-to-markdown
      "uc" 'cpm/pandoc-convert-to-pdf
      "uC" 'cpm/pandoc-command-line-convert-to-pdf
      "ug" 'org-mac-grab-link
      "ui" 'cpm/org-goto-inbox
      "uk" 'kill-compilation
      "ul" 'desktop-read
      "uo" 'cpm/markdown-to-org
      "up" 'run-pandoc
      "uP" 'cpm/pandoc-pdf-open
      "ur" 'remember-notes
      "us" 'sb-expand-current-file
      "uS" 'just-one-space
      ;; "ut" 'cpm/org-goto-todo
      "ut" 'cpm/jump-to-org-agenda-all-todos
      "ud" 'distraction-free
      "uD" 'my-desktop
      "uj" 'cpm/goto-journal
      ;; "op" 'pandoc-convert-to-pdf
      "uw" 'count-words
      "uW" 'osx-dictionary-search-input
      "ux" 'helm-bibtex
      )
#+END_SRC
***** Version Control Keybindings
#+BEGIN_SRC emacs-lisp
(general-define-key
  :states '(normal motion visual insert emacs)
  :keymaps 'override
  :prefix "SPC"
  :non-normal-prefix "C-SPC"

  "g"  '(:ignore t :which-key "Git")
  "gb" 'magit-blame
  "gc" 'magit-commit
  "gd" 'magit-diff
  "gl" 'magit-log
  "gn" 'git-gutter:next-hunk
  "gp" 'git-gutter:previous-hunk
  "gr" 'magit-reflog
  "gs" 'magit-status
  )
#+END_SRC
***** Window Keybindings
#+BEGIN_SRC emacs-lisp
(general-define-key
  :states '(normal motion visual insert emacs)
  :keymaps 'override
  :prefix "SPC"
  :non-normal-prefix "C-SPC"

  "0" 'select-window-0
  "1" 'select-window-1
  "2" 'select-window-2
  "3" 'select-window-3
  "4" 'select-window-4
  "5" 'select-window-5

  "w"  '(:ignore t :which-key "Windows")
  "wa" 'ace-window
  "wf" 'cpm/toggle-window-split
  "wc" 'delete-window
  "wd" 'delete-window
  "wm" 'delete-other-windows
  "wr" 'cpm/rotate-windows
  "wR" 'cpm/rotate-windows-backward
  "wu" 'winner-undo
  "wU" 'winner-redo
  "wv" 'cpm/split-window-right-and-focus
  "wV" 'evil-window-vsplit
  "wx" 'cpm/window-exchange
  "w-" 'evil-window-split
  "w_" 'cpm/split-window-below-and-focus
  )
#+END_SRC
***** Wiki Keybindings
#+BEGIN_SRC emacs-lisp
  (general-define-key
    :states '(normal motion visual insert emacs)
    :keymaps 'override
    :prefix "SPC"
    :non-normal-prefix "C-SPC"

      "W" '(:ignore t :which-key "Wiki")
      ;; Keys in visualize mode
      "Wp" 'org-brain-add-parent
      "WP" 'org-brain-remove-parent
      "Wc" 'org-brain-add-child
      "WC" 'org-brain-remove-child
      "Wh" 'org-brain-new-child
      "Wn" 'org-brain-pin
      "Wt" 'org-brain-set-title
      "Wj" 'forward-button
      "Wk" 'backward-button
      "Wo" 'org-brain-goto-current
      "WO" 'org-brain-goto
      "Wv" 'org-brain-visualize
      "Wf" 'org-brain-add-friendship
      "WF" 'org-brain-remove-friendship
      "Wd" 'org-brain-delete-entry
      "Wl" 'org-brain-add-resource
      "Wa" 'org-brain-visualize-attach
      "WA" 'org-brain-archive
      "Wb" 'org-brain-visualize-back
      "W\C-y" 'org-brain-visualize-paste-resource
      "WT" 'org-brain-set-tags
      "Wq" 'org-brain-visualize-quit
      "Wr" 'org-brain-visualize-random
      "WR" 'org-brain-visualize-wander
      "Wm" 'org-brain-visualize-mind-map
      "W+" 'org-brain-visualize-add-grandchild
      "W-" 'org-brain-visualize-remove-grandchild
      "Wz" 'org-brain-visualize-add-grandparent
      "WZ" 'org-brain-visualize-remove-grandparent)


    ;;   "Wc" 'org-wiki-close
    ;;   "Wd" 'org-wiki-dired-all
    ;;   "Wk" 'org-wiki-close
    ;;   "Wh" 'org-wiki-helm
    ;;   "WH" 'org-wiki-help
    ;;   "WI" 'org-wiki-index
    ;;   "Wi" 'org-wiki-insert
    ;;   "Wl" 'org-wiki-link
    ;;   "Wm" 'org-wiki-make-page
    ;;   "Wv" 'org-wiki-server-toggle
    ;;   "We" 'org-wiki-export-html
    ;;   "Wp" 'org-wiki-panel
    ;;   "Ws" 'org-wiki-search
    ;;   "Wt" 'org-wiki-header
    ;; )
#+END_SRC
***** Zettelkasten Notes
#+BEGIN_SRC emacs-lisp
(general-define-key
  :prefix "SPC"
  :non-normal-prefix "C-SPC"
  :states '(normal visual insert motion emacs)
  :keymaps 'override
  "z"  '(nil :wk "Zettelkasten")
  "zc" '(zd-search-current-id :wk "search current id")
  "zd" '(cpm/zettel-dired :wk "zettel dired view")
  "zf" '(zd-avy-file-search :wk "avy file search")
  "zF" '(zd-avy-file-search-ace-window :wk "avy file other window")
  "zI" '(zd-find-file-id-insert :wk "insert id")
  "zi" '(zd-find-file-full-title-insert :wk "insert full title")
  "zl" '(zd-avy-link-search :wk "avy link search")
  "zn" '(zd-new-file :wk "new file")
  "zN" '(zd-new-file-and-link :wk "new file & link")
  "zo" '(zd-find-file :wk "find file")
  "zr" '(zd-file-rename :wk "rename")
  "zR" '(deft-refresh :wk "refresh")
  "zs" '(zd-deft-new-search :wk "new search")
  "zS" '(zd-search-at-point :wk "search at point")
  "zt" '(zd-avy-tag-search :wk "avy tag search")
  "zT" '(zd-tag-buffer :wk "tag list")
  )
#+END_SRC

**** Smooth Scrolling
 #+BEGIN_SRC emacs-lisp
  ;; Keyboard smooth scrolling: Prevent the awkward "snap to re-center" when
   ;; the text cursor moves off-screen. Instead, only scroll the minimum amount
   ;; necessary to show the new line. (A number of 101+ disables re-centering.)
   (setq scroll-conservatively 101)

   ;; Optimize mouse wheel scrolling for smooth-scrolling trackpad use.
   ;; Trackpads send a lot more scroll events than regular mouse wheels,
   ;; so the scroll amount and acceleration must be tuned to smooth it out.
   (setq
    ;; If the frame contains multiple windows, scroll the one under the cursor
    ;; instead of the one that currently has keyboard focus.
    mouse-wheel-follow-mouse 't
    ;; Completely disable mouse wheel acceleration to avoid speeding away.
    mouse-wheel-progressive-speed nil
    ;; The most important setting of all! Make each scroll-event move 2 lines at
    ;; a time (instead of 5 at default). Simply hold down shift to move twice as
    ;; fast, or hold down control to move 3x as fast. Perfect for trackpads.
    mouse-wheel-scroll-amount '(2 ((shift) . 4) ((control) . 6)))
 #+END_SRC
**** Which-key
 #+BEGIN_SRC emacs-lisp
 (use-package which-key
   :defer 1
   :diminish ""
   :config
   (setq which-key-special-keys nil)
   ;; Set the time delay (in seconds) for the which-key popup to appear.
   (setq which-key-idle-delay .3)
   (which-key-mode))
 #+END_SRC
**** Doom-Quit
 Quit prompt with messages from Doom exit messages

 #+BEGIN_SRC emacs-lisp
 (defun doom-quit-p (&optional prompt)
   "Return t if this session should be killed. Prompts the user for
 confirmation."
 (or (yes-or-no-p (format "››› %s" (or prompt "Quit Emacs?")))
     (ignore (message "Aborted"))))
 (setq confirm-kill-emacs nil)
 (add-hook 'kill-emacs-query-functions #'doom-quit-p)
 #+END_SRC


 #+BEGIN_SRC emacs-lisp
 (defvar +doom-quit-messages
   '(;; from Doom 1
     "Let's beat it -- This is turning into a bloodbath!"
     "I wouldn't leave if I were you. DOS is much worse."
     "Ya know, next time you come in here I'm gonna toast ya."
     "Go ahead and leave. See if I care."
     "Are you sure you want to quit this great editor?"
     ;; Custom
     "Emacs! Emacs!! Emacs!!!"
     "The King is dead, long live the King!"
     "Like you have somewhere better to be..."
     "Don't worry, I won't tell everyone you're a failure"
     "Aus so krummem Holze, als woraus der Mensch gemacht ist, kann nichts ganz Gerades gezimmert werden"
     "(setq nothing t everything 'permitted)"
     "Emacs will remember that."
     "Emacs, Emacs never changes."
     "Hey! Hey, M-x listen!"
     "Okay, look. We've both said a lot of things you're going to regret..."
     "You are *not* prepared!")
   "A list of quit messages, picked randomly by `+doom-quit'. Taken from
 http://doom.wikia.com/wiki/Quit_messages and elsewhere.")

 (defun +doom|quit (&rest _)
   (doom-quit-p
    (format "%s  Quit?"
            (nth (random (length +doom-quit-messages))
                 +doom-quit-messages))))

 (remove-hook 'kill-emacs-query-functions #'doom-quit-p)
 (add-hook 'kill-emacs-query-functions #'+doom|quit)
 #+END_SRC
**** Popup Windows
[[https://github.com/wasamasa/shackle][A package]] that puts an end to popped-up windows not behaving they way you'd like them to.

#+BEGIN_SRC emacs-lisp
  (use-package shackle
    :after helm
    :config
    ;; make helm pop-ups behave
    (setq helm-display-function #'pop-to-buffer)
    (setq shackle-rules '(("\\`\\*helm.*?\\*\\'" :regexp t :align t :ratio 0.46)))
    (shackle-mode 1))
#+END_SRC


**** Helpful (Documentation)
[[http://www.wilfred.me.uk/blog/2017/08/30/helpful-adding-contextual-help-to-emacs/][Contextual help]] for emacs
#+BEGIN_SRC emacs-lisp
(use-package helpful
  :config (evil-set-initial-state 'helpful-mode 'motion)
  :general
  ("C-h f" #'helpful-callable)
  ("C-h k" #'helpful-key)
  ("C-h v" #'helpful-variable)
  ("C-c C-." #'helpful-at-point)
  ("C-h C-l" #'find-library)
  :commands (helpful-function helpful-callable helpful-key helpful-variable helpful-at-point))
#+END_SRC

**** Clickable Links
Courtesy of [[http://xenodium.com/#actionable-urls-in-emacs-buffers][Álvaro Ramírez]]
#+BEGIN_SRC emacs-lisp
(use-package goto-addr
  :hook ((compilation-mode . goto-address-mode)
         (prog-mode . goto-address-prog-mode)
         (eshell-mode . goto-address-mode)
         (shell-mode . goto-address-mode))
  :bind (:map goto-address-highlight-keymap
              ("<RET>" . goto-address-at-point)
              ("M-<RET>" . newline))
  :commands (goto-address-prog-mode
             goto-address-mode))
#+END_SRC
** Programming
*** Alignment
[[https://github.com/edkolev/evil-lion][This package]] provides gl and gL align operators: gl MOTION CHAR and right-align gL MOTION CHAR
#+BEGIN_SRC emacs-lisp
(use-package evil-lion
  :defer t
  :config
  (general-define-key :states '(normal) :keymaps 'prog-mode-map
  "g l" 'evil-lion-left
  "g L" 'evil-lion-right)

  (general-define-key :states '(visual) :keymaps 'prog-mode-map
  "g l" 'evil-lion-left
  "g L" 'evil-lion-right)
  )
#+END_SRC
*** Rainbow delimiters
[[https://github.com/Fanael/rainbow-delimiters][Useful package]] that will highlight delimiters such as parentheses, brackets or braces according to their depth. Each successive level is highlighted in a different color. This makes it easy to spot matching delimiters, orient yourself in the code, and tell which statements are at a given depth.
   #+BEGIN_SRC emacs-lisp
   (use-package rainbow-delimiters 
     :commands rainbow-delimiters-mode
     :init
     (add-hook 'prog-mode-hook 'rainbow-delimiters-mode)
     :config
     (set-face-attribute 'rainbow-delimiters-unmatched-face nil
            :foreground "red"
            :inherit 'error
            :box t)) 
   #+END_SRC
*** Rainbow identifiers
[[https://github.com/Fanael/rainbow-identifiers][Rainbow identifiers mode]] is an Emacs minor mode providing highlighting of identifiers based on their names. Each identifier gets a color based on a hash of its name.
#+BEGIN_SRC emacs-lisp
(use-package rainbow-identifiers
  :commands rainbow-identifiers-mode
  :init
  (add-hook 'prog-mode-hook 'rainbow-identifiers-mode))
#+END_SRC
*** Rainbow mode
[[https://github.com/emacsmirror/rainbow-mode][Colorize color names]] in buffers 
#+BEGIN_SRC emacs-lisp
(use-package rainbow-mode
  :commands rainbow-mode)
#+END_SRC 
*** DISABLED Electric Pair (Autopair)
CLOSED: [2018-06-28 Thu 12:02]
#+BEGIN_SRC emacs-lisp
(use-package electric-pair
  :disabled t
  :ensure nil
  :commands electric-pair-mode
  :init
  (add-hook 'prog-mode-hook 'electric-pair-mode)
  (add-hook 'org-mode-hook 'electric-pair-mode)
  (add-hook 'markdown-mode-hook 'electric-pair-mode)
  :config 
  ;; via https://www.topbug.net/blog/2016/09/29/emacs-disable-certain-pairs-for-electric-pair-mode/
  (setq electric-pair-inhibit-predicate
      (lambda (c)
        (if (char-equal c ?\") t (electric-pair-default-inhibit c)))))
#+END_SRC
*** Languages
**** Applescript
#+BEGIN_SRC emacs-lisp
    (use-package applescript-mode
      :ensure t
      :mode (("\\.scpt\\'" . applescript-mode)
             ("\\.applescript\\'"       . applescript-mode))
      :commands (applescript-mode))
#+END_SRC
**** Elisp
#+BEGIN_SRC emacs-lisp 
  (use-package elisp-slime-nav
    :commands elisp-slime-nav-mode
    :config
    (dolist (hook '(emacs-lisp-mode-hook ielm-mode-hook))
      (add-hook hook 'turn-on-elisp-slime-nav-mode)))

  (use-package eldoc
    :commands eldoc-mode
    :diminish eldoc-mode
    :config 
    ;; Show ElDoc messages in the echo area immediately, instead of after 1/2 a second.
    (setq eldoc-idle-delay 0))
    ;; Elisp hook
    (add-hook 'emacs-lisp-mode-hook (lambda ()
                (setq show-trailing-whitespace t)
                (prettify-symbols-mode)
                (eldoc-mode)
                (yas-minor-mode)
                (company-mode)
                (rainbow-delimiters-mode)))

#+END_SRC
**** Haskell
#+BEGIN_SRC emacs-lisp
  (use-package haskell-mode
    :commands haskell-mode)
#+END_SRC
**** Html
#+BEGIN_SRC emacs-lisp
(use-package web-mode
  :commands (web-mode)
  :mode ("\\.html$" . web-mode)
  :config
  (setq web-mode-enable-auto-pairing t
        web-mode-enable-auto-expanding t
        web-mode-enable-css-colorization t
        web-mode-enable-auto-closing t
        web-mode-enable-auto-quoting t)) 
#+END_SRC
**** Lua
#+BEGIN_SRC emacs-lisp
(use-package lua-mode
  :commands lua-mode
  :init
  (dolist (pattern '("\\.lua\\'"))
  (add-to-list 'auto-mode-alist (cons pattern 'lua-mode))))
#+END_SRC
**** PHP
#+BEGIN_SRC emacs-lisp
(use-package php-mode
  :commands php-mode
  :init
  (dolist (pattern '("\\.php\\'"))
  (add-to-list 'auto-mode-alist (cons pattern 'php-mode))))
#+END_SRC
**** Shell script mode
#+BEGIN_SRC emacs-lisp
  (use-package sh-script
    :commands sh-script-mode
    :init
    (progn
      ;; Use sh-mode when opening `.zsh' files, and when opening Prezto runcoms.
      (dolist (pattern '("\\.zsh\\'"
                         "zlogin\\'"
                         "zlogout\\'"
                         "zpreztorc\\'"
                         "zprofile\\'"
                         "zshenv\\'"
                         "zshrc\\'"))
        (add-to-list 'auto-mode-alist (cons pattern 'sh-mode)))))

    (defun spacemacs//setup-shell ()
        (when (and buffer-file-name
                   (string-match-p "\\.zsh\\'" buffer-file-name))
          (sh-set-shell "zsh")))
      (add-hook 'sh-mode-hook 'spacemacs//setup-shell)
#+END_SRC
**** Yaml
#+BEGIN_SRC emacs-lisp
  (use-package yaml-mode
    :commands yaml-mode
    :config
    (add-to-list 'auto-mode-alist '("\\.yml$" . yaml-mode))
    (add-to-list 'auto-mode-alist '("\\.yaml$" . yaml-mode))
    (add-hook 'yaml-mode-hook (lambda () (run-hooks 'prog-mode-hook)))
  )
#+END_SRC
**** Vim
#+BEGIN_SRC emacs-lisp
(use-package vimrc-mode
  :commands vimrc-mode)
#+END_SRC
*** Macrostep
Interactive [[https://github.com/joddie/macrostep][macro expander]] for emacs
#+BEGIN_SRC emacs-lisp
(use-package macrostep
  :commands macrostep-expand
) 
#+END_SRC
*** Documentation
#+BEGIN_SRC emacs-lisp
(use-package tldr 
  :commands (tldr tldr-update-docs)
  :init 
  (evil-set-initial-state 'tldr-mode 'emacs)
  :config
  (setq tldr-directory-path (expand-file-name "tldr/" cpm-etc-dir)))
#+END_SRC

** Session & Project Management
*** Hydra
#+BEGIN_SRC emacs-lisp
  (use-package hydra
    ;; :commands (cpm/hydra-desktop/body))
    :defer 2)
    ;; hydra for TODOs
    (with-eval-after-load 'hydra
    (defhydra cpm/hydra-todo 
               (:pre
                (hl-todo-mode 1)
                :post
                (hl-todo-mode -1))
    "Todo"
    ("n" hl-todo-next "Next")
    ("p" hl-todo-previous "Previous")
    ("o" hl-todo-occur "Occur")
    ("q" nil "Quit" :color blue :exit t)))
#+END_SRC
*** Projectile
#+BEGIN_SRC emacs-lisp
  (use-package projectile
   :defer 1
   :init
   ;; save projectile-known-projects-file in cache folder
    (setq projectile-known-projects-file
       (concat cpm-cache-dir "projectile-bookmarks.eld"))
    (setq projectile-cache-file
       (concat cpm-cache-dir "projectile.cache"))
    (setq projectile-enable-caching t
          projectile-files-cache-expire 60)
    :config
    (projectile-mode t))
#+END_SRC
*** Perspectives
Yet another attempt to manage buffers/workspaces
#+BEGIN_SRC emacs-lisp 
  (use-package perspective
    :commands (persp-switch persp-add-buffer persp-set-buffer)
    :config
    (setq persp-show-modestring nil))

  (use-package persp-projectile
      :commands projectile-persp-switch-project)
  (with-eval-after-load 'persp-projectile
      (defhydra hydra-persp (:columns 4
                             :color blue)
        "Perspective"
        ("a" persp-add-buffer "Add Buffer")
        ("i" persp-import "Import")
        ("c" persp-kill "Close")
        ("n" persp-next "Next")
        ("p" persp-prev "Prev")
        ("k" persp-remove-buffer "Kill Buffer")
        ("r" persp-rename "Rename")
        ("A" persp-set-buffer "Set Buffer")
        ("s" persp-switch "Switch")
        ("C-x" persp-switch-last "Switch Last")
        ("b" persp-switch-to-buffer "Switch to Buffer")
        ("P" projectile-persp-switch-project "Switch Project")
        ("q" nil "Quit")))

  (with-eval-after-load 'desktop+
  (defhydra cpm/hydra-desktop (:columns 4
                               :color blue)
    "Desktops"
    ("c" desktop+-create "Create desktop")
    ("l" desktop+-load "Load desktop"))) 
#+END_SRC
*** FIXME Desktop Perspective Integration
A [[https://github.com/nex3/perspective-el/issues/19][useful set of functions]] for loading perspectives via desktop-save
#+BEGIN_SRC emacs-lisp
(defun perspectives-buffer-name-p (buffer)
    (if (and buffer
         (buffer-name buffer)
         (not (string-prefix-p "*" (buffer-name buffer)))
         (not (string-suffix-p "*" (buffer-name buffer))))
    t
      nil))

  (defun perspectives-hash-filter (current filtered parameters saving)
    (let ((value (cdr current))
      (result ())
      (keys (hash-table-keys (cdr current))))
      ;; for every perspective...
      (dolist (key keys)
    (let ((persp (gethash key value)))
      ;; that isn't killed...
      (if (not (persp-killed persp))
          (add-to-list
           'result
           (cons key
             ;; save the list of buffers
             (list (cons "buffers"
             (list
              (mapcar 'buffer-name (seq-filter 'perspectives-buffer-name-p (persp-buffers persp)))))))))))
    ;; return a different variable name so perspectives doesn't clobber it
    (cons 'perspectives-hash-serialized result)))

  ;; serialize perspectives hash
  (add-to-list 'frameset-filter-alist '(perspectives-hash . perspectives-hash-filter))
  ;; don't serialize anything else
  (add-to-list 'frameset-filter-alist '(persp-modestring . :never))
  (add-to-list 'frameset-filter-alist '(persp-recursive . :never))
  (add-to-list 'frameset-filter-alist '(persp-last . :never))
  (add-to-list 'frameset-filter-alist '(persp-curr . :never))

  (defun perspectives-restore-state ()
    (dolist (frame (frame-list))
      ;; get the serialized state off of the frame
      (let ((state (frame-parameter frame 'perspectives-hash-serialized)))
    (if state (progn
            (message "Found state, attempting restore")
            ;; delete it so we don't end up in a loop
            (set-frame-parameter frame 'perspectives-hash-serialized nil)
            (with-selected-frame frame
              (dolist (elem state)
            ;; recreate the perspective
            (with-perspective (car elem)
              (dolist (buffer-name (car (cdr (assoc "buffers" (cdr elem)))))
                ;; add the buffer back to the perspective
                (persp-add-buffer buffer-name)
                )))
              ))
      (message "No state found")
      )
    )))

  (add-hook 'desktop-after-read-hook 'perspectives-restore-state)

#+END_SRC
*** Eyebrowse Workspace & Window Management
Easy workspace creation and switching
#+BEGIN_SRC emacs-lisp
  (use-package eyebrowse
    :commands (eyebrowse-switch-to-window-config-1 eyebrowse-switch-to-window-config-2)
    :general
    (:states '(insert normal motion emacs) :keymaps 'override
      "s-1" 'eyebrowse-switch-to-window-config-1
      "s-2" 'eyebrowse-switch-to-window-config-2
      "s-3" 'eyebrowse-switch-to-window-config-3
      "s-4" 'eyebrowse-switch-to-window-config-4
      "s-5" 'eyebrowse-switch-to-window-config-5)
    :config
    (setq eyebrowse-new-workspace 'dired-jump
          eyebrowse-mode-line-style 'hide
          eyebrowse-wrap-around t
          eyebrowse-switch-back-and-forth t)

    ;; Define a tabedit command (a la Vim) to create new tabs with
    ;; optional file name or directory name. When no filename is passed on
    ;; it calls the default eyebrowse function.
    (evil-define-command cpm/eyebrowse-create-window-config-with-file (file)
      :repeat nil
      (interactive "<f>")
      (if (and file (f-exists? file))
        (progn
          (eyebrowse-create-window-config)
          (find-file file))
        (eyebrowse-create-window-config)))

    (evil-ex-define-cmd "tabc[lose]" 'eyebrowse-close-window-config)
    (evil-ex-define-cmd "tabe[dit]"  'cpm/eyebrowse-create-window-config-with-file)
    (evil-ex-define-cmd "tabfirst"   'eyebrowse-switch-to-window-config-0)
    (evil-ex-define-cmd "tablast"    'eyebrowse-last-window-config)
    (evil-ex-define-cmd "tabn"       'eyebrowse-next-window-config)
    (evil-ex-define-cmd "tabp"       'eyebrowse-prev-window-config)
    (evil-ex-define-cmd "tabs"       'eyebrowse-switch-to-window-config)

    ;; This one doesn't exist in Vim, but it's useful if you'd like to use
    ;; tabs like Tmux, where it's very common to rename tabs.
    (evil-ex-define-cmd "tabr[ename]" 'eyebrowse-rename-window-config)

    (eyebrowse-setup-evil-keys)
    (eyebrowse-mode t))
#+END_SRC


*** Nameframe
[[https://github.com/john2x/nameframe][Nameframe]] provides utility functions to manage frames by their names.
#+BEGIN_SRC emacs-lisp
   (use-package nameframe
     :commands (nameframe-create-frame)
     :general
     ("s-p" 'nameframe-switch-frame)
     :config
     (nameframe-projectile-mode t)
     (nameframe-perspective-mode t))


  ;; functions for named work frames
  (defun cpm/load-website ()
    (interactive)
    (persp-mode 1)
    (nameframe-create-frame "Website")
    (toggle-frame-maximized)
    (find-file "~/Dropbox/Work/projects/website/website.org")
    (magit-status))
  (defun cpm/load-org-agenda-todo ()
    (interactive)
    (persp-mode 1)
    (nameframe-create-frame "Org Agenda")
    (toggle-frame-maximized)
    (cpm/jump-to-org-super-agenda)
    (split-window-right)
    (find-file "~/Dropbox/org-files/todo.org"))
   (defun cpm/load-phil101 ()
     (interactive)
     (persp-mode 1)
     (nameframe-create-frame "PHIL 101")
     (toggle-frame-maximized)
     (find-file "~/Dropbox/Work/projects/phil101/content/slides/lecture_outline.org")
     (split-window-right)
     (find-file "~/Dropbox/Work/projects/phil101/content/pages/schedule.org"))
   (defun cpm/load-phil105 ()
     (interactive)
     (persp-mode 1)
     (nameframe-create-frame "PHIL 105")
     (toggle-frame-maximized)
     (find-file "~/Dropbox/Work/projects/phil105/phil105-classplan.org")
     (magit-status))
   (defun cpm/load-phil232 ()
     (interactive)
     (persp-mode 1)
     (nameframe-create-frame "PHIL 232")
     (toggle-frame-maximized)
     (find-file "~/Dropbox/Work/projects/phil232/phil232_lecture_outline.org")
     (split-window-right)
     (find-file "~/Dropbox/Work/projects/phil232/content/pages/schedule.org"))
    (defun cpm/load-phil871 ()
      (interactive)
      (persp-mode 1)
      (nameframe-create-frame "PHIL 871")
      (toggle-frame-maximized)
      (find-file "~/Dropbox/Work/projects/phil871-kant-survey/phil871-kant-survey.org"))
   (defun cpm/load-kant-apperception-substance ()
     (interactive)
     (persp-mode 1)
     (nameframe-create-frame "Apperception & Substance")
     (toggle-frame-maximized)
     ;; (org-open-link-from-string "[[file:~/Dropbox/org-files/todo.org::*Apperception%20&%20Substance][Apperception & Substance]]")
     (find-file "~/Dropbox/Work/projects/KantApperception/Kantsubstance.md")
     (split-window-right)
     (find-file "~/Dropbox/Work/projects/KantApperception/phil-imprint-submission/revision-notes.org"))
     ;; (magit-status)
   (defun cpm/load-kant-reflection ()
     (interactive)
     (persp-mode 1)
     (nameframe-create-frame "Kant on Reflection")
     (toggle-frame-maximized)
     (find-file "~/Dropbox/Work/projects/KantReflection/Kant-reflection-notes.org")
     (magit-status))
   (defun cpm/load-kant-agency-book ()
     (interactive)
     (persp-mode 1)
     (nameframe-create-frame "Kant on Rational Agency")
     (toggle-frame-maximized)
     (find-file "~/Dropbox/Work/projects/Book-Projects/Kant-Agency-Book/Kant-Rational-Agency-Notes.org")
     (magit-status))
   (defun cpm/load-kant-rationality-book ()
     (interactive)
     (persp-mode 1)
     (nameframe-create-frame "Kant on Rationality")
     (toggle-frame-maximized)
     (find-file "~/Dropbox/notes/zettel/2019-0119-1607-book-notes.md")
     (split-window-right)
     (find-file "~/Dropbox/Work/projects/Book-Projects/rationality-book/chapters")
     (split-window-below)
     (magit-status))
   (defun cpm/load-emacs-config ()
     (interactive)
     (persp-mode 1)
     (nameframe-create-frame "Emacs Config")
     (toggle-frame-maximized)
     (find-file "~/.emacs.d/config.org"))
   (defun cpm/load-kant-free-thought ()
     (interactive)
     (persp-mode 1)
     (nameframe-create-frame "Kant on Free Intellect")
     (toggle-frame-maximized)
     (find-file "~/Dropbox/Work/projects/KantFreeThought/KantFreeThought.md")
     (split-window-right)
     (org-open-link-from-string "[[file:~/Dropbox/org-files/todo.org::*Freedom%20of%20thought][Freedom of thought]]"))
   (defun cpm/load-zettelkasten ()
       (interactive)
       (persp-mode 1)
       (nameframe-create-frame "Zettelkasten")
       (toggle-frame-maximized)
       (zd-deft-new-search))


#+END_SRC


** Search
*** Ag
 #+BEGIN_SRC emacs-lisp
   (use-package ag
   :commands (helm-do-ag cpm/helm-files-do-ag cpm/helm-files-search-current-directory helm-do-ag-this-file helm-ag-buffers)
   :config
   (progn
     (defun ag/jump-to-result-if-only-one-match ()
       "Jump to the first ag result if that ag search came up with just one match."
       (let (only-one-match)
         (when (member "--stats" ag-arguments)
           (save-excursion
             (goto-char (point-min))
             (setq only-one-match (re-search-forward "^1 matches\\s-*$" nil :noerror)))
           (when only-one-match
             (next-error)
             (kill-buffer (current-buffer))
             (message (concat "ag: Jumping to the only found match and "
                              "killing the *ag* buffer."))))))
     (add-hook 'ag-search-finished-hook #'ag/jump-to-result-if-only-one-match)  
    
     ;; Set default ag arguments
     ;; It looks like the ~/.agignore is used when launching ag from emacs too.
     ;; So the ignores from ~/.agignore don't have to be set here again.

     (setq ag-highlight-search t)
     ;; By default, ag.el will open results in a different window in the frame, so
     ;; the results buffer is still visible. You can override this so the results
     ;; buffer is hidden and the selected result is shown in its place:
     (setq ag-reuse-window nil)
     ;; reuse the same *ag* buffer for all your searches
     (setq ag-reuse-buffers t)
     ;; ;; To save buffer automatically when `wgrep-finish-edit'
     ;; (setq wgrep-auto-save-buffer t)

     (with-eval-after-load 'projectile
       ;; Override the default function to use the projectile function instead
       (defun ag/project-root (file-path)
         (let ((proj-name (projectile-project-root)))
           (if proj-name
               proj-name ; return `projectile-project-root' if non-nil
             ;; Else condition is same as the `ag/project-root' definition
             ;; from ag.el
             (if ag-project-root-function
                 (funcall ag-project-root-function file-path)
               (or (ag/longest-string
                    (vc-git-root file-path)
                    (vc-svn-root file-path)
                    (vc-hg-root file-path))
                   file-path))))))))

 #+END_SRC
 
*** TESTING Ripgrep (rg)
An [[https://github.com/Wilfred/deadgrep][interface]] for [[https://github.com/BurntSushi/ripgrep][ripgrep]]
 #+BEGIN_SRC emacs-lisp 
   (use-package deadgrep
     :ensure t
     :general
     (:states '(normal motion visual insert emacs)
     :keymaps 'override
     :prefix "SPC"
     :non-normal-prefix "C-SPC"
     "sg" #'deadgrep)
     (:states '(normal motion visal)
      :keymaps 'deadgrep-mode-map
      "j" #'deadgrep-forward
      "k" #'deadgrep-backward
      "l" #'deadgrep-visit-result))
   ;; (use-package rg
   ;;   :commands rg)
 #+END_SRC
*** Anzu
[[https://github.com/syohex/emacs-anzu][anzu.el]] is an Emacs port of anzu.vim. anzu.el provides a minor mode which displays current match and total matches information in the mode-line in various search modes.
#+BEGIN_SRC emacs-lisp
(use-package anzu
  :commands (isearch-foward isearch-backward)
  :config (global-anzu-mode))
(use-package evil-anzu
  :commands (evil-search-forward evil-search-backward))
#+END_SRC

** Shell
*** Sane term
 Sane settings for ansi-term
 #+BEGIN_SRC emacs-lisp
   (use-package sane-term
     :commands sane-term
     :init
     ;; shell to use for sane-term
     (setq sane-term-shell-command "/usr/local/bin/zsh")
     ;; sane-term will create first term if none exist
     (setq sane-term-initial-create t)
     ;; `C-d' or `exit' will kill the term buffer.
     (setq sane-term-kill-on-exit t)
     ;; After killing a term buffer, not cycle to another.
     (setq sane-term-next-on-kill nil))
 #+END_SRC
*** Shell Pop
 A popup shell
 #+begin_src emacs-lisp 
   (use-package shell-pop
     :commands shell-pop
     :init
     (setq shell-pop-term-shell "/usr/local/bin/zsh")
     (setq shell-pop-shell-type '("eshell" "*eshell*" (lambda nil (eshell))))
     :config
       (defun ansi-term-handle-close ()
        "Close current term buffer when `exit' from term buffer."
        (when (ignore-errors (get-buffer-process (current-buffer)))
          (set-process-sentinel (get-buffer-process (current-buffer))
                                (lambda (proc change)
                                  (when (string-match "\\(finished\\|exited\\)" change)
                                    (kill-buffer (when (buffer-live-p (process-buffer proc)))
                                    (delete-window))))))
      (add-hook 'shell-pop-out-hook 'kill-this-buffer)
      (add-hook 'term-mode-hook (lambda () (linum-mode -1) (ansi-term-handle-close)))))
 #+end_src
*** Shell settings
 Other useful shell settings  
 #+begin_src emacs-lisp
    ;; basic settings
    ;; (evil-set-initial-state 'term-mode 'emacs)
    (setq explicit-shell-file-name "/usr/local/bin/zsh")
    ;; don't add newline in long lines
    (setq-default term-suppress-hard-newline t)
    ;; kill process buffers without query
    (setq kill-buffer-query-functions (delq 'process-kill-buffer-query-function kill-buffer-query-functions))
    ;; (global-set-key (kbd "C-x k") 'kill-this-buffer) 
    ;; kill ansi-buffer on exit
    (defadvice term-sentinel (around my-advice-term-sentinel (proc msg))
      (if (memq (process-status proc) '(signal exit))
          (let ((buffer (process-buffer proc)))
             ad-do-it
             (kill-buffer buffer))
            ad-do-it))
          (ad-activate 'term-sentinel)

   ;; clickable links & no highlight of line
   (defun my-term-hook ()
     (goto-address-mode) (global-hl-line-mode 0))
   (add-hook 'term-mode-hook 'my-term-hook)
    
   ;; paste and navigation
   (defun term-send-tab ()
   "Send tab in term mode."
     (interactive)
     (term-send-raw-string "\t"))

   ;; Emacs doesn’t handle less well, so use cat instead for the shell pager 
   (setenv "PAGER" "cat")

   ;; hack to fix pasting issue, the paste micro-state won't work in term
   (general-define-key :states '(normal) :keymaps 'term-raw-map 
          "p" 'term-paste
          "C-k" 'term-send-up
          "C-j" 'term-send-down)

   (general-define-key :states '(insert) :keymaps 'term-raw-map 
          "C-c C-d" 'term-send-eof
          "C-c C-z" 'term-stop-subjob
          "<tab>"   'term-send-tab
          "s-v"     'term-paste
          "C-k"     'term-send-up
          "C-j"     'term-send-down)
 #+end_src
*** Compilation buffer

 Whenever I run ~compile~, the buffer stays even after a successful compilation. Let's make it close automatically if the compilation is successful.

 #+BEGIN_SRC emacs-lisp
 (setq compilation-finish-functions
       (lambda (buf str)
         (if (null (string-match ".*exited abnormally.*" str))
             ;;no errors, make the compilation window go away in a few seconds
             (progn
               (run-at-time "0.4 sec" nil
                            (lambda ()
                              (select-window (get-buffer-window (get-buffer-create "*compilation*")))
                              (switch-to-buffer nil)
                              (delete-window)))
               (message "No Compilation Errors!")))))
 #+END_SRC
*** Completion buffer
 Kill the completion buffer
 #+BEGIN_SRC emacs-lisp
   ;; Remove completion buffer when done
   (add-hook 'minibuffer-exit-hook 
   '(lambda ()
            (let ((buffer "*Completions*"))
              (and (get-buffer buffer)
               (kill-buffer buffer)))))
 #+END_SRC
*** Virtualenvwrapper
 #+BEGIN_SRC emacs-lisp
   (use-package virtualenvwrapper
    :after (:any eshell sane-term ansi-term)
    :config
    (venv-initialize-interactive-shells) ;; if you want interactive shell support
    (venv-initialize-eshell) ;; if you want eshell support
    (setq venv-location "~/bin/virtualenvs")
    (setq venv-project-home "~/Dropbox/Work/projects/")
    (add-hook 'venv-postactivate-hook (lambda () (workon-venv))))

   (defcustom venv-project-home
     (expand-file-name (or (getenv "PROJECT_HOME") "~/Dropbox/Work/projects/"))
       "The location(s) of your virtualenv projects."
       :group 'virtualenvwrapper)

   (defun workon-venv ()
    "change directory to project in eshell"
     (eshell/cd (concat venv-project-home venv-current-name)))
 #+END_SRC
*** Tramp
An easy way to ssh
#+BEGIN_SRC emacs-lisp
(use-package tramp-term
  :commands tramp-term
)
#+END_SRC
*** Eshell
 Eshell is an [[https://www.masteringemacs.org/article/complete-guide-mastering-eshell][elisp shell]]. It has its own configuration parameters, distinct
 from those of shell or ansi-terminal.
**** Eshell Settings
 Basic settings
 #+BEGIN_SRC emacs-lisp 
   (use-package eshell
     :commands eshell
     :init
     (setq eshell-directory-name (concat cpm-local-dir "eshell/")
           eshell-history-file-name (concat cpm-local-dir "eshell/history")
           eshell-aliases-file (concat cpm-local-dir "eshell/alias")
           eshell-last-dir-ring-file-name (concat cpm-local-dir "eshell/lastdir")
           eshell-highlight-prompt nil
           eshell-buffer-shorthand t
           eshell-cmpl-ignore-case t
           eshell-cmpl-cycle-completions t
           eshell-destroy-buffer-when-process-dies t
           eshell-history-size 10000
           ;; auto truncate after 20k lines
           eshell-buffer-maximum-lines 20000
           eshell-hist-ignoredups t
           eshell-error-if-no-glob t
           eshell-glob-case-insensitive t
           eshell-scroll-to-bottom-on-input 'all
           eshell-scroll-to-bottom-on-output 'all
           eshell-list-files-after-cd t
           eshell-banner-message ""
           ;; eshell-banner-message (message "Emacs initialized in %.2fs \n\n" (float-time (time-subtract (current-time) my-start-time)))
           ;; eshell-banner-message "What would you like to do?\n\n"
         )
         ;; Visual commands
     (setq eshell-visual-commands '("ranger" "vi" "screen" "top" "less" "more" "lynx"
                                        "ncftp" "pine" "tin" "trn" "elm" "vim"
                                        "nmtui" "alsamixer" "htop" "el" "elinks"
                                        ))
     (setq eshell-visual-subcommands '(("git" "log" "diff" "show"))))



   (defun cpm/setup-eshell ()
    (interactive)
     ;; turn off semantic-mode in eshell buffers
     (semantic-mode -1)
     ;; turn off hl-line-mode
     (hl-line-mode -1))
#+END_SRC

**** Eshell Helm
#+BEGIN_SRC emacs-lisp
     ;; helm support
     (add-hook 'eshell-mode-hook
          (lambda ()
            (eshell-cmpl-initialize)
            (define-key eshell-mode-map [remap eshell-pcomplete] 'helm-esh-pcomplete)
            (define-key eshell-mode-map (kbd "M-l") 'helm-eshell-history)
            (cpm/setup-eshell)))

         (when (not (functionp 'eshell/rgrep))
           (defun eshell/rgrep (&rest args)
             "Use Emacs grep facility instead of calling external grep."
             (eshell-grep "rgrep" args t)))
#+END_SRC

**** Eshell Truncate Buffers
Per this [[https://emacs.stackexchange.com/a/10874/11934][stack exchange discussion]]
#+BEGIN_SRC emacs-lisp
(defun my/truncate-eshell-buffers ()
  "Truncates all eshell buffers"
  (interactive)
  (save-current-buffer
    (dolist (buffer (buffer-list t))
      (set-buffer buffer)
      (when (eq major-mode 'eshell-mode)
        (eshell-truncate-buffer)))))

;; After being idle for 5 seconds, truncate all the eshell-buffers if
;; needed. If this needs to be canceled, you can run `(cancel-timer
;; my/eshell-truncate-timer)'
(setq my/eshell-truncate-timer
      (run-with-idle-timer 5 t #'my/truncate-eshell-buffers))
 #+END_SRC
**** Eshell Evil History Navigation
History browsing. Note keybindings need to be buffer local as per https://github.com/noctuid/general.el/issues/80
#+BEGIN_SRC emacs-lisp
(add-hook 'eshell-mode-hook
(lambda ()
(general-define-key :states  '(normal insert emacs) :keymaps 'eshell-mode-map
    "<down>" 'eshell-next-input
    "<up>"   'eshell-previous-input
    "C-k"    'eshell-next-input
    "C-j"    'eshell-previous-input)
    ))
#+END_SRC
**** Eshell Prompt
A nicer [[https://gist.github.com/ekaschalk/f0ac91c406ad99e53bb97752683811a5][eshell prompt]] with some [[http://www.modernemacs.com/post/custom-eshell/][useful discussion]] of how it was put together.
I've made just a few tiny modifications.

#+BEGIN_SRC emacs-lisp
  (require 'dash)
  (require 's)

  (defmacro with-face (STR &rest PROPS)
    "Return STR propertized with PROPS."
    `(propertize ,STR 'face (list ,@PROPS)))

  (defmacro esh-section (NAME ICON FORM &rest PROPS)
    "Build eshell section NAME with ICON prepended to evaled FORM with PROPS."
    `(setq ,NAME
           (lambda () (when ,FORM
                   (-> ,ICON
                      (concat esh-section-delim ,FORM)
                      (with-face ,@PROPS))))))

  (defun esh-acc (acc x)
    "Accumulator for evaluating and concatenating esh-sections."
    (--if-let (funcall x)
        (if (s-blank? acc)
            it
          (concat acc esh-sep it))
      acc))

  (defun esh-prompt-func ()
    "Build `eshell-prompt-function'"
    (concat esh-header
            (-reduce-from 'esh-acc "" eshell-funcs)
            "\n"
            eshell-prompt-string))

  (esh-section esh-dir
               "\xf07c"  ;  (faicon folder)
               (abbreviate-file-name (eshell/pwd))
               '(:foreground "#268bd2" :underline t))

  (esh-section esh-git
               "\xe907"  ;  (git icon)
               (with-eval-after-load 'magit
               (magit-get-current-branch))
               '(:foreground "#b58900"))

  (esh-section esh-python
               "\xe928"  ;  (python icon)
               (with-eval-after-load "virtualenvwrapper"
               venv-current-name))

  (esh-section esh-clock
               "\xf017"  ;  (clock icon)
               (format-time-string "%H:%M" (current-time))
               '(:foreground "forest green"))

  ;; Below I implement a "prompt number" section
  (setq esh-prompt-num 0)
  (add-hook 'eshell-exit-hook (lambda () (setq esh-prompt-num 0)))
  (advice-add 'eshell-send-input :before
              (lambda (&rest args) (setq esh-prompt-num (incf esh-prompt-num))))

  (esh-section esh-num
               "\xf0c9"  ;  (list icon)
               (number-to-string esh-prompt-num)
               '(:foreground "brown"))

  ;; Separator between esh-sections
  (setq esh-sep " | ")  ; or "  "

  ;; Separator between an esh-section icon and form
  (setq esh-section-delim " ")

  ;; Eshell prompt header
  (setq esh-header "\n┌─")  ; or "\n "

  ;; Eshell prompt regexp and string. Unless you are varying the prompt by eg.
  ;; your login, these can be the same.
  (setq eshell-prompt-regexp "^└─>> ") ;; note the '^' to get regex working right
  (setq eshell-prompt-string "└─>> ") 

  ;; Choose which eshell-funcs to enable
  (setq eshell-funcs (list esh-dir esh-git esh-python esh-clock esh-num))

  ;; Enable the new eshell prompt
  (setq eshell-prompt-function 'esh-prompt-func)
#+END_SRC
**** Shell Switcher
 Useful for switching between [[https://github.com/DamienCassou/shell-switcher][multiple instances]] of eshell. But you can
 configure for any shell that you use.
 #+BEGIN_SRC emacs-lisp
   (use-package shell-switcher
     :general
     ("C-'"  'shell-switcher-switch-buffer-other-window)
     :config
     (add-hook 'eshell-mode-hook 'shell-switcher-manually-register-shell)
     (setq shell-switcher-mode t))
 #+END_SRC
**** Clear Eshell 
 Make eshell act like a standard unix terminal.
 #+BEGIN_SRC emacs-lisp
   (defun eshell-clear-buffer ()
   "Clear terminal"
   (interactive)
   (let ((inhibit-read-only t))
     (erase-buffer)
     (eshell-send-input)))
 (add-hook 'eshell-mode-hook
       '(lambda()
           (local-set-key (kbd "C-l") 'eshell-clear-buffer)))
 #+END_SRC
**** Eshell Magit
 #+BEGIN_SRC emacs-lisp
 (defun eshell/magit ()
 "Function to open magit-status for the current directory"
   (interactive)
   (magit-status default-directory)
   nil)
 #+END_SRC
**** Eshell Fringe Status
Show [[https://github.com/ryuslash/eshell-fringe-status][last status in fringe]]
#+BEGIN_SRC emacs-lisp
(use-package eshell-fringe-status
  :defer t
  :config
  (add-hook 'eshell-mode-hook 'eshell-fringe-status-mode))
#+END_SRC
**** Eshell Autosuggest
Fish-like [[https://github.com/dieggsy/esh-autosuggest/][history autosuggestions]] in eshell
#+BEGIN_SRC emacs-lisp
(use-package esh-autosuggest
  :hook (eshell-mode . esh-autosuggest-mode))
#+END_SRC

** Version Control
 Magit is a great interface for git projects. It's much more pleasant to use than
 the standard git interface on the command line. I've set up some easy
 keybindings to access magit and related packages.

*** Magit
 #+BEGIN_SRC emacs-lisp
   (use-package magit
     :commands 
     (magit-blame-mode
      magit-commit
      magit-diff
      magit-log
      magit-status)
     :init
     (add-hook 'git-commit-mode-hook 'turn-on-flyspell)
     (add-hook 'magit-mode-hook 'evil-magit-init)
     (setq vc-follow-symlinks t)
     ;; Suppress the message we get about "Turning on
     ;; magit-auto-revert-mode" when loading Magit.
     (setq magit-no-message '("Turning on magit-auto-revert-mode..."))
     :config
     ;; make magit go fullscreen
     ;; (setq magit-display-buffer-function #'magit-display-buffer-fullframe-status-v1)
     (setq magit-diff-refine-hunk t)
     (global-git-commit-mode t) ; use emacs as editor for git commits
     (setq magit-push-always-verify nil)
     )
 #+END_SRC

*** Evil Magit
 Evil bindings for magit
 #+BEGIN_SRC emacs-lisp
 (use-package evil-magit
   :after magit
   :demand t
   :config
   (setq evil-magit-use-y-for-yank t
         evil-magit-use-z-for-folds t))
 #+END_SRC
 
 
*** TESTING Magit-Org-Todos
#+BEGIN_SRC emacs-lisp
  (use-package magit-todos
  :load-path "~/.emacs.d/.local/elisp/magit-todos"
  :after magit
  :config
  (magit-todos-mode))
#+END_SRC
*** DISABLED Magithub
CLOSED: [2018-09-07 Fri 00:53]
Magit & Github = [[https://github.com/vermiculus/magithub][Awesome]]
#+BEGIN_SRC emacs-lisp
(use-package magithub
  :ensure t
  :after magit
  :config
  (magithub-feature-autoinject t)
  (setq magithub-clone-default-directory "~/.emacs.d/.local/elisp/"))
#+END_SRC

*** TESTING Helm Gitignore
#+BEGIN_SRC emacs-lisp
  (use-package helm-gitignore
    :ensure t
    :commands helm-gitignore)
#+END_SRC

*** Git Commit
#+BEGIN_SRC emacs-lisp
(use-package git-commit
  :ensure t
  :after magit
  :hook (git-commit-mode . cpm/git-commit-auto-fill-everywhere)
  :custom (git-commit-summary-max-length 50)
  :preface
  (defun cpm/git-commit-auto-fill-everywhere ()
    "Ensures that the commit body does not exceed 72 characters."
    (setq fill-column 72)
    (setq-local comment-auto-fill-only-comments nil)))
#+END_SRC
*** DISABLED Git Auto Commit
CLOSED: [2018-08-22 Wed 16:17]
[[https://github.com/ryuslash/git-auto-commit-mode][Automatically commit to git]] after each save
#+BEGIN_SRC emacs-lisp
  (use-package git-auto-commit-mode
    :ensure t
    :commands git-auto-commit-mode
    :config
    (setq gac-automatically-push-p 1
          gac-ask-for-summary-p nil))
#+END_SRC

*** Git timemachine
 #+BEGIN_SRC emacs-lisp
 (use-package git-timemachine            ; Go back in Git time
   :commands git-timemachine)
 #+END_SRC
 
*** Gited
Give git projects branches the dired treatment
#+BEGIN_SRC emacs-lisp
(use-package gited
  :commands (gited-list gited-list-branches))
#+END_SRC
 
*** Git gutter
Git gutter is great for giving visual feedback on changes, but it doesn't play
well with org-mode using org-indent. So I don't use it globally. 
 #+BEGIN_SRC emacs-lisp
   (use-package git-gutter
     :defer t
     :init
     (add-hook! (markdown-mode prog-mode conf-mode) 'git-gutter-mode)
     :config
     (setq git-gutter:disabled-modes '(org-mode asm-mode image-mode)
           git-gutter:update-interval 2
           git-gutter:window-width 2))

   (use-package git-gutter-fringe
     :diminish git-gutter-mode
     :after git-gutter
     ;; :demand fringe-helper
     :config
     ;; subtle diff indicators in the fringe
     ;; places the git gutter outside the margins.
     (setq-default fringes-outside-margins t)
     ;; thin fringe bitmaps
     (define-fringe-bitmap 'git-gutter-fr:added
     [224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224]
     nil nil 'center)
     (define-fringe-bitmap 'git-gutter-fr:modified
     [224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224]
     nil nil 'center)
     (define-fringe-bitmap 'git-gutter-fr:deleted
     [0 0 0 0 0 0 0 0 0 0 0 0 0 128 192 224 240 248]
     nil nil 'center))

 #+END_SRC

*** Quick commits
Make a quick commit without opening magit. This is a version of a
workflow I used to use in Sublime Text. Perfect for short commit messages.
 #+BEGIN_SRC emacs-lisp
   (defun quick-commit ()
   "make a quick commit from the mini-buffer"
   (interactive)
   (evil-ex '"!Git add % && Git commit -m '" ))
 #+END_SRC





* Org Mode
** Settings
*** New Org
Ensure ELPA org is prioritized above built-in org.
#+BEGIN_SRC emacs-lisp 
(setq load-path (remove-if (lambda (x) (string-match-p "org$" x)) load-path))
#+END_SRC
*** Org Directories 
#+BEGIN_SRC emacs-lisp
(setq org-directory "~/Dropbox/org-files")
(setq org-default-notes-file (concat org-directory "/inbox.org"))
#+END_SRC
*** State Settings
#+BEGIN_SRC emacs-lisp
(setq org-todo-keywords
 '((sequence "TODO(t)" "DOING(g)" "NEXT(n)" "|" "DONE(d)")
   (sequence "WAITING(w@/!)" "HOLD(h@/!)" "|" "CANCELED(c@/!)")))
#+END_SRC
*** Priority Settings
#+BEGIN_SRC emacs-lisp
(setq org-priority-faces '((?A . (:foreground "red" :weight 'bold))
                           (?B . (:foreground "orange"))
                           (?C . (:foreground "DarkGoldenrod2"))
                           (?D . (:forefround "green"))))
#+END_SRC
*** Org Logging
Log timestamp when task is marked "DONE" or other finished keyword
#+BEGIN_SRC emacs-lisp
(setq org-log-done 'time)
(setq org-log-into-drawer t)
(setq org-log-state-notes-insert-after-drawers nil)
;;;; Don't log the time a task was rescheduled or redeadlined.
(setq org-log-redeadline nil)
(setq org-log-reschedule nil)

;; Prefer rescheduling to future dates and times:
(setq org-read-date-prefer-future 'time)
#+END_SRC
*** Org Tags
#+begin_src emacs-lisp
(setq org-tag-alist (quote (("@errand" . ?e)
                            ("@unl" . ?s)
                            ("@home" . ?h)
                            ("@computer" . ?c))))

(setq org-fast-tag-selection-single-key nil)
#+end_src
*** Org Babel Languages
#+BEGIN_SRC emacs-lisp
(with-eval-after-load 'org
(org-babel-do-load-languages
 'org-babel-load-languages
 '((latex . t)
   (lisp . t)
   (shell . t)))

(defun cpm/org-confirm-babel-evaluate (lang body)
  "Do not confirm evaluation for these languages."
  (not (or (string= lang "emacs-lisp"))))
        
(setq org-confirm-babel-evaluate 'my-org-confirm-babel-evaluate))
#+END_SRC
*** Org Babel Source Blocks
#+BEGIN_SRC emacs-lisp
  (setq org-src-fontify-natively t
        org-src-window-setup 'other-window
        org-src-tab-acts-natively nil
        org-src-strip-leading-and-trailing-blank-lines t)
#+END_SRC

*** Org Config Settings
#+BEGIN_SRC emacs-lisp
  (setq-default 
        org-footnote-section nil ;; place footnotes locally rather than in own section
        org-return-follows-link t ;; make RET follow links
        org-list-allow-alphabetical t ;; allow alphabetical list
        org-hide-emphasis-markers t  ;; hide markers
        org-pretty-entities t ;; make latex look good
        org-pretty-entities-include-sub-superscripts t
        org-hide-leading-stars t
        org-export-with-smart-quotes t ;; export smart quote marks
        org-refile-use-cache t  ;; use cache for org refile
        org-startup-folded t
        org-yank-adjusted-subtrees t  ;; adjust subtrees to depth when yanked
        org-yank-folded-subtrees t  ;; fold subtrees on yank
        org-M-RET-may-split-line '((default . nil))  ;; don't split line when creating a new headline, list item, or table field
        org-fontify-quote-and-verse-blocks t ;; make quotes stand out
        org-table-export-default-format "orgtbl-to-csv" ;; export for org-tables to csv
        ;; org-ellipsis "↷" ;; nicer elipses "↴" "▼"
        org-startup-indented t ;; start in indent mode
        org-imenu-depth 8
        imenu-auto-rescan t)
#+END_SRC
*** Org Modules
A list of org modules to load on startup
#+BEGIN_SRC emacs-lisp 
(setq org-modules (quote (org-info org-tempo org-protocol org-habit org-mac-link)))
#+END_SRC
*** Org ID
#+BEGIN_SRC emacs-lisp
(setq org-id-locations-file (concat cpm-cache-dir ".org-id-locations"))
#+END_SRC
*** Org Regex (Emphasis)
Per this [[https://emacs.stackexchange.com/questions/13820/inline-verbatim-and-code-with-quotes-in-org-mode][stack exchange]] discussion.
#+BEGIN_SRC emacs-lisp

(with-eval-after-load 'org
; chars for prematch
(setcar org-emphasis-regexp-components            "     ('\"{“”\[\\\_\-") 
; chars for postmatch
(setcar (nthcdr 1 org-emphasis-regexp-components) "\] -   .,!?;:''“”\")}/\\“”\_\-") 
; forbidden chars
(setcar (nthcdr 2 org-emphasis-regexp-components) "    \t\r\n,\"")
; body
(setcar (nthcdr 3 org-emphasis-regexp-components) ".")
; max newlines 
(setcar (nthcdr 4 org-emphasis-regexp-components) 1)
(org-set-emph-re 'org-emphasis-regexp-components org-emphasis-regexp-components))

#+END_SRC
*** Org Entities
Display proper utf-8 characters
#+BEGIN_SRC emacs-lisp
(setq org-entities-user
      '(("nec" "\Box" nil "◻" "" "" "◻")
        ("pos" "\Diamond" nil "◇" "" "" "◇")))
#+END_SRC
*** Hooks
#+BEGIN_SRC emacs-lisp
  (add-hook 'org-mode-hook
      (lambda () 
      (turn-on-visual-fill-column-mode) 
      (centered-cursor-mode)
        ;; (turn-on-auto-fill)
        ))
#+END_SRC



** Org Archive
Tell org where to archive completed tasks
#+BEGIN_SRC emacs-lisp
(setq org-archive-location (concat org-directory "/org-archive/archived.org::datetree/"))
#+END_SRC

Also tell org how to archive all the done tasks (DONE or CANCELED) in a file.
From [[https://changelog.complete.org/archives/9877-emacs-3-more-on-org-mode][here]] based on a stack overflow [[https://stackoverflow.com/a/27043756][answer]]
#+BEGIN_SRC emacs-lisp
(defun cpm/org-archive-done-tasks ()
  (interactive)
  (org-map-entries
   (lambda ()
     (org-archive-subtree)
     (setq org-map-continue-from (outline-previous-heading)))
   "/DONE" 'file)
  (org-map-entries
   (lambda ()
     (org-archive-subtree)
     (setq org-map-continue-from (outline-previous-heading)))
   "/CANCELED" 'file)
)

#+END_SRC

** Org Refile
Set refile settings.  I got a lot of help on this from [[https://blog.aaronbieber.com/2017/03/19/organizing-notes-with-refile.html][Aaron Bieber's discussion]].

With this set, you can trigger Refile with C-c C-w in any Org file and
get a completing read of all headings up to three levels deep in all
files in =org-agenda-files=. You can also refile to the top header in a
document and create new parents.
#+BEGIN_SRC emacs-lisp
  (setq org-refile-targets '((org-agenda-files :maxlevel . 8)
                             ("/Users/roambot/.emacs.d/config.org" :maxlevel . 8)))
  (setq org-refile-use-outline-path 'file)
  (setq org-outline-path-complete-in-steps nil)
  (setq org-refile-allow-creating-parent-nodes 'confirm)
#+END_SRC

** Open Files In Default Application
Open files in their default applications (ms word being the prime example)
#+BEGIN_SRC emacs-lisp
  (setq org-file-apps
        '(("\\.docx\\'" . default)
          ("\\.mm\\'" . default)
          ("\\.x?html?\\'" . default)
          ("\\.pdf\\'" . default)
          (auto-mode . emacs)))
#+END_SRC

** Org-Agenda
*** Agenda Settings
Settings for the [[http://orgmode.org/manual/Agenda-Views.html][agenda]].
#+BEGIN_SRC emacs-lisp
  (setq org-agenda-files '("~/Dropbox/org-files/"))
  (general-define-key "C-c a" #'org-agenda)

  ;; Display properties
  (setq org-cycle-separator-lines 0
        org-tags-column 72
        org-agenda-tags-column org-tags-column
        org-agenda-window-setup 'only-window
        org-agenda-restore-windows-after-quit t
        org-agenda-todo-ignore-scheduled nil
        org-agenda-todo-ignore-deadlines nil 
        org-agenda-block-separator ""
        ;; org-agenda-sticky t
        org-agenda-span 'day)

  (with-eval-after-load 'org-agenda
    (general-define-key :keymaps 'org-agenda-mode-map 
                        "j" 'org-agenda-next-item
                        "k" 'org-agenda-previous-item))

  ;; automatically refresh the agenda after adding a task
  (defun cpm/org-agenda-refresh ()
  (interactive)
  (when (get-buffer "*Org Agenda*")
      (with-current-buffer "*Org Agenda*"
          (org-agenda-redo t)
          (message "[org agenda] refreshed!"))))
  (add-hook 'org-capture-after-finalize-hook 'cpm/org-agenda-refresh)

  ;; show all todos
  (defun cpm/jump-to-org-agenda-all-todos ()
    "open agenda with all unscheduled/non-deadline todos"
    (interactive)
    (org-agenda nil "z"))

  ;; jump to week agenda
  (defun cpm/jump-to-week-agenda ()
    "open custom week agenda"
    (interactive)
    (org-agenda nil "W"))

;; from stack overflow https://stackoverflow.com/a/22900459/6277148
;; note that the formatting is nicer that just using '%b'
(setq org-agenda-prefix-format    
 '((agenda . " %i %-12:c%?-12t% s")
  (timeline . "  % s")
  (todo .
   " %i %-12:c %(concat \"\"(org-format-outline-path (org-get-outline-path)) \" \->\") ")
  (tags .
   " %i %-12:c %(concat \"\"(org-format-outline-path (org-get-outline-path)) \" \->\") ")
  (search . " %i %-12:c")))
#+END_SRC
*** Agenda Navigation
Courtesy of [[https://blog.aaronbieber.com/2016/09/25/agenda-interactions-primer.html][Aaron Bieber]]
#+BEGIN_SRC emacs-lisp
(defun air-org-agenda-next-header ()
  "Jump to the next header in an agenda series."
  (interactive)
  (air--org-agenda-goto-header))

(defun air-org-agenda-previous-header ()
  "Jump to the previous header in an agenda series."
  (interactive)
  (air--org-agenda-goto-header t))

(defun air--org-agenda-goto-header (&optional backwards)
  "Find the next agenda series header forwards or BACKWARDS."
  (let ((pos (save-excursion
               (goto-char (if backwards
                              (line-beginning-position)
                            (line-end-position)))
               (let* ((find-func (if backwards
                                     'previous-single-property-change
                                   'next-single-property-change))
                      (end-func (if backwards
                                    'max
                                  'min))
                      (all-pos-raw (list (funcall find-func (point) 'org-agenda-structural-header)
                                         (funcall find-func (point) 'org-agenda-date-header)
                                         (funcall find-func (point) 'org-super-agenda-header)))
                      (all-pos (cl-remove-if-not 'numberp all-pos-raw))
                      (prop-pos (if all-pos (apply end-func all-pos) nil)))
                 prop-pos))))
    (if pos (goto-char pos))
    (if backwards (goto-char (line-beginning-position)))))
 
(with-eval-after-load 'org-agenda
(general-define-key :keymaps 'org-agenda-mode-map :states '(normal motion)
  "J" 'air-org-agenda-next-header
  "K" 'air-org-agenda-previous-header))
  
(defun air-org-skip-subtree-if-habit ()
  "Skip an agenda entry if it has a STYLE property equal to \"habit\"."
  (let ((subtree-end (save-excursion (org-end-of-subtree t))))
    (if (string= (org-entry-get nil "STYLE") "habit")
        subtree-end
      nil)))

(defun air-org-skip-subtree-if-priority (priority)
  "Skip an agenda subtree if it has a priority of PRIORITY.

PRIORITY may be one of the characters ?A, ?B, or ?C."
  (let ((subtree-end (save-excursion (org-end-of-subtree t)))
        (pri-value (* 1000 (- org-lowest-priority priority)))
        (pri-current (org-get-priority (thing-at-point 'line t))))
    (if (= pri-value pri-current)
        subtree-end
      nil)))
#+END_SRC

*** Org Super-Agenda
[[https://github.com/alphapapa/org-super-agenda][Supercharge]] org-agenda. Settings courtesy of [[https://github.com/alphapapa/org-super-agenda/blob/master/examples.org#forward-looking][alphapapa]].
#+BEGIN_SRC emacs-lisp
  (use-package org-super-agenda
   ;; :pin manual ;; throws errors for some reason when I update
   :general 
   (:states '(normal motion emacs) :keymaps 'org-agenda-keymap 
   ","  'cpm/hydra-org-agenda/body)
   :after (org org-agenda)
   :demand t
   :config
   (org-super-agenda-mode)
   (setq org-super-agenda-groups
     '((:name "Overdue"
        :deadline past)
       (:name "Today"
        :scheduled today
        :time-grid t
        :deadline nil)
       (:name "Due Today"
        :deadline today)
       (:name "Upcoming"
        :deadline future
        :scheduled future)
       (:name "Scheduled"
        :scheduled t)
        )))
  (defun cpm/jump-to-org-super-agenda ()
  (interactive)
  (org-agenda nil "A"))


#+END_SRC

*** Hydra for Agenda
Hydra for org agenda (graciously offered by Spacemacs)
#+BEGIN_SRC emacs-lisp
(after! org-agenda
(org-super-agenda-mode)
(defhydra cpm/hydra-org-agenda (:color pink :hint none)
  "
Org agenda (_q_uit)

^Clock^      ^Visit entry^              ^Date^             ^Other^
^-----^----  ^-----------^------------  ^----^-----------  ^-----^---------
_ci_ in      _SPC_ in other window      _ds_ schedule      _gr_ reload
_co_ out     _TAB_ & go to location     _dd_ set deadline  _._  go to today
_cq_ cancel  _RET_ & del other windows  _dt_ timestamp     _gd_ go to date
_cj_ jump    _o_   link                 _+_  do later      ^^
^^           ^^                         _-_  do earlier    ^^
^^           ^^                         ^^                 ^^
^View^          ^Filter^                 ^Headline^         ^Toggle mode^
^----^--------  ^------^---------------  ^--------^-------  ^-----------^----
_vd_ day        _ft_ by tag              _ht_ set status    _tf_ follow
_vw_ week       _fr_ refine by tag       _hk_ kill          _tl_ log
_vt_ fortnight  _fc_ by category         _hr_ refile        _ta_ archive trees
_vm_ month      _fh_ by top headline     _hA_ archive       _tA_ archive files
_vy_ year       _fx_ by regexp           _h:_ set tags      _tr_ clock report
_vn_ next span  _fd_ delete all filters  _hp_ set priority  _td_ diaries
_vp_ prev span  ^^                       ^^                 ^^
_vr_ reset      ^^                       ^^                 ^^
^^              ^^                       ^^                 ^^
"
  ;; Entry
  ("hA" org-agenda-archive-default)
  ("hk" org-agenda-kill)
  ("hp" org-agenda-priority)
  ("hr" org-agenda-refile)
  ("h:" org-agenda-set-tags)
  ("ht" org-agenda-todo)
  ;; Visit entry
  ("o"   link-hint-open-link :exit t)
  ("<tab>" org-agenda-goto :exit t)
  ("TAB" org-agenda-goto :exit t)
  ("SPC" org-agenda-show-and-scroll-up)
  ("RET" org-agenda-switch-to :exit t)
  ;; Date
  ("dt" org-agenda-date-prompt)
  ("dd" org-agenda-deadline)
  ("+" org-agenda-do-date-later)
  ("-" org-agenda-do-date-earlier)
  ("ds" org-agenda-schedule)
  ;; View
  ("vd" org-agenda-day-view)
  ("vw" org-agenda-week-view)
  ("vt" org-agenda-fortnight-view)
  ("vm" org-agenda-month-view)
  ("vy" org-agenda-year-view)
  ("vn" org-agenda-later)
  ("vp" org-agenda-earlier)
  ("vr" org-agenda-reset-view)
  ;; Toggle mode
  ("ta" org-agenda-archives-mode)
  ("tA" (org-agenda-archives-mode 'files))
  ("tr" org-agenda-clockreport-mode)
  ("tf" org-agenda-follow-mode)
  ("tl" org-agenda-log-mode)
  ("td" org-agenda-toggle-diary)
  ;; Filter
  ("fc" org-agenda-filter-by-category)
  ("fx" org-agenda-filter-by-regexp)
  ("ft" org-agenda-filter-by-tag)
  ("fr" org-agenda-filter-by-tag-refine)
  ("fh" org-agenda-filter-by-top-headline)
  ("fd" org-agenda-filter-remove-all)
  ;; Clock
  ("cq" org-agenda-clock-cancel)
  ("cj" org-agenda-clock-goto :exit t)
  ("ci" org-agenda-clock-in :exit t)
  ("co" org-agenda-clock-out)
  ;; Other
  ("q" nil :exit t)
  ("gd" org-agenda-goto-date)
  ("." org-agenda-goto-today)
  ("gr" org-agenda-redo)))

#+END_SRC



*** Agenda Custom Commands
#+BEGIN_SRC emacs-lisp 
  ; https://orgmode.org/manual/Storing-searches.html#Storing-searches
  (setq org-agenda-custom-commands
        '(("x" agenda)
          ("y" agenda*) ; or agenda entries planned this week/day with an hour specification like [h]h:mm
          ("z" todo "TODO")
          ("i" todo "INPROGRESS")
          ("n" todo "NEXT")
          ("r" todo "REVISE")
          ("w" todo "WAITING")
          ("A" "Super Agenda" (
                               (agenda "" ((org-agenda-span 'day)))
                               (alltodo "" ((org-agenda-overriding-header "")
                               (org-super-agenda-groups 
                                 '((:name "Next to do"
                                    :todo "NEXT")
                                   (:name "In Progress"
                                    :todo "DOING")
                                   (:name "Important"
                                    :tag "Important"
                                    :priority "A")
                                   (:todo ("WAITING" "HOLD"))
                                   (:todo "MAYBE")
                                   (:name "Reading List"
                                    :todo "TOREAD")))))))
          ("W" "Week's agenda and all TODOs"
           ((tags "PRIORITY=\"A\""
                  ((org-agenda-skip-function '(org-agenda-skip-entry-if 'todo 'done))
                   (org-agenda-overriding-header "High-priority unfinished tasks:")))
            (agenda "" ((org-agenda-span 'week)))
            (alltodo ""
                     ((org-agenda-skip-function '(or (air-org-skip-subtree-if-habit)
                                                     (air-org-skip-subtree-if-priority ?A)
                                                     (org-agenda-skip-if nil '(scheduled deadline))))
                      (org-agenda-overriding-header "ALL normal priority tasks:"))))
           ((org-agenda-compact-blocks nil)))))
 #+END_SRC
         

** Org Capture
*** Capture Settings
#+BEGIN_SRC emacs-lisp
  (general-define-key "C-c c" 'org-capture)
  (add-hook 'org-capture-mode-hook 'evil-insert-state)
  (setq org-capture-templates
        '(("p" "Projects" entry (file "~/Dropbox/org-files/projects.org")
           "* %? \n  %i")
          ("c" "Capture" entry (file "~/Dropbox/org-files/inbox.org")
           "* TODO %?\n %i")
          ("j" "Journal" entry (file+olp+datetree "~/Dropbox/org-files/journal.org")
           "**** %<%H:%M>\n%?")
          ("l" "A link, for reading later." entry (file "~/Dropbox/org-files/links.org")
            "* %:description\n%u\n\n%c\n\n%i"
            :empty-lines 1)
          ("m" "Mail-Task" entry (file "~/Dropbox/org-files/inbox.org")
           "* TODO %:description                         :email: \n[[message://%l][Email link]] \n%? ")
          ("r" "Reference" entry (file "~/Dropbox/org-files/reference.org")
          "* %?")
          ("w" "Review: Weekly Review" entry (file+datetree "~/Dropbox/org-files/reviews.org")
            (file "~/Dropbox/org-files/templates/weekly_review_template.org"))))

    ;; Add date to captured items
    (defun add-property-with-date-captured ()
      "Add DATE_CAPTURED property to the current item."
      (interactive)
      (org-set-property "DATE_CAPTURED" (format-time-string "%c")))

    (add-hook 'org-capture-before-finalize-hook 'add-property-with-date-captured)

#+END_SRC
*** Org Journal Capture
Tell emacs what you're doing a few times a day. Depends on a [[/Users/roambot/bin/scripts/emacs_journal.sh][shell script]] run
in the background. I got the idea from [[http://www.diegoberrocal.com/blog/2015/08/19/org-protocol/][Diego Berrocal]]. Hat tip to [[http://stackoverflow.com/questions/23517372/hook-or-advice-when-aborting-org-capture-before-template-selection][stack
overflow]] for help on hooks for the created frame.

#+BEGIN_SRC emacs-lisp
(defun cpm/org-journal ()
  (interactive) (org-capture nil "j"))

(defun cpm/what-are-you-doing-capture ()
  (interactive)
  (make-frame '((name . "What are you doing?") (left . (+ 550)) (top . (+ 400)) (width . 100) (height . 24)))
  (select-frame-by-name "What are you doing?")
  (cpm/org-journal)
  (cpm/insert-weather)
  )

#+END_SRC
*** Alfred capture workflow
Help alfred and org-capture play nice. Courtesy of [[http://orgmode.org/worg/org-contrib/alfred-org-capture.html][worg]] with some slight modifications.
#+BEGIN_SRC emacs-lisp
(defun cpm/org-capture-frame ()
  (interactive)
  (org-capture nil "c"))
  
(defun cpm/make-orgcapture-frame ()
  "Create a new frame and run org-capture."
  (interactive)
  (make-frame '((name . "alfred-capture") (width . 90) (height . 20)
                (top . 400) (left . 300)
                ))
  (select-frame-by-name "alfred-capture")
  (cpm/org-capture-frame))

#+END_SRC
*** Capture advice
Make capture the only window and close after refiling.
 #+BEGIN_SRC emacs-lisp
   (defadvice org-capture
     (after make-full-window-frame activate)
     "Advise capture to be the only window when used as a popup"
     (cond ((equal "What are you doing?" (frame-parameter nil 'name)) (delete-other-windows))
           ((equal "alfred-capture" (frame-parameter nil 'name)) (delete-other-windows))
           ((equal "Email Capture" (frame-parameter nil 'name)) (delete-other-windows))

           ))

    (defadvice org-capture-finalize
      (after delete-capture-frame activate)
       "Advise capture-finalize to close the frame"
       (cond ((equal "What are you doing?" (frame-parameter nil 'name)) (delete-frame))
             ((equal "alfred-capture" (frame-parameter nil 'name)) (delete-frame))
             ((equal "Email Capture" (frame-parameter nil 'name)) (delete-frame))
             ))
#+END_SRC


** Org Template Expansions

#+BEGIN_SRC emacs-lisp 
  (with-eval-after-load 'org
  (setq new-structure-template-alist
        '(("el" . "src emacs-lisp")
          ("t" . "COMMENT TODO:")
          ("b" . "REVEAL: split")
          ("f" . "ATTR_REVEAL: :frag (appear)")))
  (dolist (ele new-structure-template-alist)
      (add-to-list 'org-structure-template-alist ele)))
  ;; (tempo-define-template "src-elisp"
  ;;              '("src emacs-lisp" L)
  ;;              "<L"
  ;;              "Insert an elisp src block")
  ;; (add-to-list 'org-structure-template-alist
  ;;   '("L" "src emacs-lisp"))
  ;; (add-to-list 'org-structure-template-alist
  ;;   '("n" "notes"))
  ;; (add-to-list 'org-structure-template-alist
  ;;   '("t" "COMMENT TODO: "))
  ;; (add-to-list 'org-structure-template-alist
  ;;   '("b" "REVEAL: split"))
  ;; (add-to-list 'org-structure-template-alist
  ;;   '("f" "ATTR_REVEAL: :frag (appear)")))
#+END_SRC
** Org Bullets
#+BEGIN_SRC emacs-lisp
  (use-package org-bullets
    :hook (org-mode . org-bullets-mode)
    :config 
    (setq org-bullets-bullet-list '("◉" "⚫"))) 

    ;; Other bullets
    ;; "●" "◉" "→"
    ;; ("◉" "◎" "⚫" "○" "►" "◇")
    ;;  "∙" "∶" "∵" "∷" "∺" )))
    ;; (setq org-bullets-bullet-list '("❂" "⁑" "⁂" "❖" "✮" "✱" "✵")))

  ;; Asterisks and dashes for bullet lists are fine, but actual circular bullets are better
  ;; via http://www.howardism.org/Technical/Emacs/orgmode-wordprocessor.html
  (font-lock-add-keywords 'org-mode
                        '(("^ +\\([-*]\\) "
                           (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "•"))))))
#+END_SRC

** Org Prettify Source Blocks

Make source blocks look better. Courtesy of [[https://pank.eu/blog/pretty-babel-src-blocks.html][Rasmus Pank Roulund]].
Last updated: 2018-04-06
#+BEGIN_SRC emacs-lisp
  (with-eval-after-load 'org
    (defvar-local rasmus/org-at-src-begin -1
      "Variable that holds whether last position was a ")

    (defvar rasmus/ob-header-symbol ?☰
      "Symbol used for babel headers")

    (defun rasmus/org-prettify-src--update ()
      (let ((case-fold-search t)
            (re "^[ \t]*#\\+begin_src[ \t]+[^ \f\t\n\r\v]+[ \t]*")
            found)
        (save-excursion
          (goto-char (point-min))
          (while (re-search-forward re nil t)
            (goto-char (match-end 0))
            (let ((args (org-trim
                         (buffer-substring-no-properties (point)
                                                         (line-end-position)))))
              (when (org-string-nw-p args)
                (let ((new-cell (cons args rasmus/ob-header-symbol)))
                  (cl-pushnew new-cell prettify-symbols-alist :test #'equal)
                  (cl-pushnew new-cell found :test #'equal)))))
          (setq prettify-symbols-alist
                (cl-set-difference prettify-symbols-alist
                                   (cl-set-difference
                                    (cl-remove-if-not
                                     (lambda (elm)
                                       (eq (cdr elm) rasmus/ob-header-symbol))
                                     prettify-symbols-alist)
                                    found :test #'equal)))
          ;; Clean up old font-lock-keywords.
          (font-lock-remove-keywords nil prettify-symbols--keywords)
          (setq prettify-symbols--keywords (prettify-symbols--make-keywords))
          (font-lock-add-keywords nil prettify-symbols--keywords)
          (while (re-search-forward re nil t)
            (font-lock-flush (line-beginning-position) (line-end-position))))))

    (defun rasmus/org-prettify-src ()
      "Hide src options via `prettify-symbols-mode'.

    `prettify-symbols-mode' is used because it has uncollpasing. It's
    may not be efficient."
      (let* ((case-fold-search t)
             (at-src-block (save-excursion
                             (beginning-of-line)
                             (looking-at "^[ \t]*#\\+begin_src[ \t]+[^ \f\t\n\r\v]+[ \t]*"))))
        ;; Test if we moved out of a block.
        (when (or (and rasmus/org-at-src-begin
                       (not at-src-block))
                  ;; File was just opened.
                  (eq rasmus/org-at-src-begin -1))
          (rasmus/org-prettify-src--update))
        ;; Remove composition if at line; doesn't work properly.
        ;; (when at-src-block
        ;;   (with-silent-modifications
        ;;     (remove-text-properties (match-end 0)
        ;;                             (1+ (line-end-position))
        ;;                             '(composition))))
        (setq rasmus/org-at-src-begin at-src-block)))

    (defun rasmus/org-prettify-symbols ()
      (mapc (apply-partially 'add-to-list 'prettify-symbols-alist)
            (cl-reduce 'append
                       (mapcar (lambda (x) (list x (cons (upcase (car x)) (cdr x))))
                               `(("#+begin_src" . ?╦) ;; ➤ 🖝 ➟ ➤ ✎ ✎
                                 ("#+end_src"   . ?╩) ;; □
                                 ("#+header:" . ,rasmus/ob-header-symbol)
                                 ("#+begin_comment" . ?✎)
                                 ("#+end_comment" . ?✎)
                                 ("#+begin_notes" . ?➤)
                                 ("#+end_notes" . ?➤)
                                 ("#+begin_quote" . ?»)
                                 ("#+end_quote" . ?«)))))
      (turn-on-prettify-symbols-mode)
      (add-hook 'post-command-hook 'rasmus/org-prettify-src t t))
    (add-hook 'org-mode-hook #'rasmus/org-prettify-symbols))


#+END_SRC


** Org-Goto
Make counsel display org headings nicely. 
#+BEGIN_SRC emacs-lisp
(with-eval-after-load 'org
  (setq counsel-org-goto-display-style 'path)
  (setq counsel-org-goto-separator " ➜ ")
  (setq counsel-org-goto-face-style 'org)
  (define-key org-mode-map (kbd "C-c C-j") 'counsel-org-goto)
  (define-key org-mode-map (kbd "C-u C-c C-j") 'counsel-org-goto-all))
#+END_SRC
** Org-Reveal
#+BEGIN_SRC emacs-lisp
  (use-package ox-reveal
  ;; :commands (org-reveal-export-current-subtree org-reveal-export-to-html-and-browse)
  :after ox
  :defer 5
  :config
  (setq org-reveal-root (concat "file://" (getenv "HOME") "/bin/reveal.js")
        org-reveal-theme "moon"
        org-reveal-default-frag-style "roll-in"
        org-reveal-hlevel 2
        ))
     
  (defun cpm/narrowed-subtree-to-html ()
    "export narrowed tree to html"
    (interactive)
    (org-reveal-export-current-subtree)
    (org-narrow-to-subtree))
    
  (fset 'cpm/reveal-to-html-open
   "\C-c\C-e\C-sRB")
#+END_SRC
** Org Organization (GTD)
*** GTD Projects
#+begin_src emacs-lisp
(defun cpm/org-goto-todo ()
  (interactive)
  (find-file "~/Dropbox/org-files/todo.org")
  (widen)
  (beginning-of-buffer))
  

(defun cpm/org-goto-inbox ()
  (interactive)
  (find-file "~/Dropbox/org-files/inbox.org")
  (widen)
  (beginning-of-buffer)
  (beginning-of-line))

(defun cpm/org-goto-projects.org ()
  (interactive)
  (find-file "~/Dropbox/org-files/projects.org"))

(defun cpm/project-overview ()
  (interactive)
  (cpm/org-goto-projects.org)
  (org-narrow-to-subtree)
  (org-columns))
#+end_src
*** Stuck Projects
#+begin_src emacs-lisp
  ;; (setq org-stuck-projects '("/PROJECT" ("NEXT") nil ""))
  (setq org-stuck-projects '("+LEVEL=2/-DONE" ("TODO" "NEXT" "WAITING") nil ""))
  (defun cpm/my-org-agenda-list-stuck-projects ()
    (interactive)
    (cpm/org-goto-projects.org)
    (org-agenda nil "#" 'subtree))
#+end_src
*** Areas
#+begin_src emacs-lisp
(defun cpm/go-to-areas ()
    (interactive)
    (find-file "~/Dropbox/org-files/todo.org")
    (widen)
    (beginning-of-buffer)
    (re-search-forward "* Areas")
    (beginning-of-line))

(defun cpm/areas-overview ()
    (interactive)
    (go-to-areas)
    (org-narrow-to-subtree)
    (org-columns))
#+end_src
*** Random Notes
#+begin_src emacs-lisp
(use-package org-randomnote
  :commands (org-randomnote org-randomnote--go-to-random-header org-randomnote--get-random-file org-randomnote--get-random-subtree)
  :init
  (setq org-randomnote-candidates '("~/Dropbox/org-files/todo.org")))
#+end_src




** Org Functions
Some useful org-specific functions
*** Org-Fill Functions
 Functions to calculate apt offsets and call regular org fill stuff. There's a
 useful [[http://stackoverflow.com/questions/14351154/org-mode-outline-level-specific-fill-column-values][stack overflow thread]] on this. 
#+BEGIN_SRC emacs-lisp
  (defun calc-offset-on-org-level ()
    "Calculate offset (in chars) on current level in org mode file."
    (* (or (org-current-level) 0) org-indent-indentation-per-level))

  (defun my-org-fill-paragraph (&optional JUSTIFY)
    "Calculate apt fill-column value and fill paragraph."
    (let* ((fill-column (- fill-column (calc-offset-on-org-level))))
      (org-fill-paragraph JUSTIFY)))

  (defun my-org-auto-fill-function ()
    "Calculate apt fill-column value and do auto-fill"
    (let* ((fill-column (- fill-column (calc-offset-on-org-level))))
      (org-auto-fill-function)))
    
  (defun my-org-mode-hook ()
    (setq fill-paragraph-function   'my-org-fill-paragraph
          normal-auto-fill-function 'my-org-auto-fill-function))

  ;; (add-hook 'org-load-hook 'my-org-mode-hook)
  ;; (add-hook 'org-mode-hook 'my-org-mode-hook)
#+END_SRC
*** Narrow & Advance/Retreat
Functions to advance forwards or backwards through narrowed tree
#+BEGIN_SRC emacs-lisp
(defun cpm/org-advance ()
  (interactive)
  (when (buffer-narrowed-p)
    (beginning-of-buffer)
    (widen)
    (org-forward-heading-same-level 1))
  (org-narrow-to-subtree))

(defun cpm/org-retreat ()
  (interactive)
  (when (buffer-narrowed-p)
    (beginning-of-buffer)
    (widen)
    (org-backward-heading-same-level 1))
  (org-narrow-to-subtree))
#+END_SRC
*** Org files
#+BEGIN_SRC emacs-lisp
(defun cpm/goto-org-files ()
  "goto org-files directory"
  (interactive)
  (require 'ranger)
  (find-file "~/Dropbox/org-files"))
(defun cpm/goto-inbox.org ()
  "goto org-inbox"
  (interactive)
  (find-file "~/Dropbox/org-files/inbox.org"))
(defun cpm/goto-todo.org ()
  "goto org-todo"
  (interactive)
  (find-file "~/Dropbox/org-files/todo.org"))
(defun cpm/goto-articles.org ()
  "goto org-articles"
  (interactive)
  (find-file "~/Dropbox/org-files/articles.org"))
(defun cpm/goto-classes.org ()
  "goto org-classes"
  (interactive)
  (find-file "~/Dropbox/org-files/classes.org"))
(defun cpm/goto-reference.org ()
  "goto org reference notes"
  (interactive)
  (find-file "~/Dropbox/org-files/reference.org"))
(defun cpm/goto-someday.org ()
  "goto org-someday"
  (interactive)
  (find-file "~/Dropbox/org-files/someday-maybe.org"))
(defun cpm/goto-links.org ()
  "goto org-links"
  (interactive)
  (find-file "~/Dropbox/org-files/links.org"))
(defun cpm/goto-reading.org ()
  "goto reading list"
  (interactive)
  (find-file "~/Dropbox/org-files/reading.org"))


#+END_SRC
*** Export Headings as Separate PDF Files
Helpful advice from [[http://pragmaticemacs.com/emacs/export-org-mode-headlines-to-separate-files/][pragmatic emacs]]
#+BEGIN_SRC emacs-lisp
;; export headlines to separate files
;; http://emacs.stackexchange.com/questions/2259/how-to-export-top-level-headings-of-org-mode-buffer-to-separate-files
(defun cpm/org-export-headlines-to-pdf ()
  "Export all subtrees that are *not* tagged with :noexport: to
separate files.

Subtrees that do not have the :EXPORT_FILE_NAME: property set
are exported to a filename derived from the headline text."
  (interactive)
  (save-buffer)
  (let ((modifiedp (buffer-modified-p)))
    (save-excursion
      (goto-char (point-min))
      (goto-char (re-search-forward "^*"))
      (set-mark (line-beginning-position))
      (goto-char (point-max))
      (org-map-entries
       (lambda ()
         (let ((export-file (org-entry-get (point) "EXPORT_FILE_NAME")))
           (unless export-file
             (org-set-property
              "EXPORT_FILE_NAME"
              (replace-regexp-in-string " " "_" (nth 4 (org-heading-components)))))
           (deactivate-mark)
           (org-pandoc-export-to-latex-pdf nil t)
           (unless export-file (org-delete-property "EXPORT_FILE_NAME"))
           (set-buffer-modified-p modifiedp)))
       "-noexport" 'region-start-level))))
#+END_SRC
*** TESTING Org demote/promote region
#+BEGIN_SRC emacs-lisp
(defun endless/demote-everything (number beg end)
  "Add a NUMBER of * to all headlines between BEG and END.
Interactively, NUMBER is the prefix argument and BEG and END are
the region boundaries."
  (interactive "p\nr")
  (save-excursion
    (save-restriction
      (save-match-data
        (widen)
        (narrow-to-region beg end)
        (goto-char (point-min))
        (let ((string (make-string number ?*)))
          (while (search-forward-regexp "^\\*" nil t)
            (insert string)))))))
#+END_SRC
*** Org Hide Property Drawers
From [[https://www.reddit.com/r/emacs/comments/9htd0r/how_to_completely_hide_the_properties_drawer_in/e6fehiw][Reddit]]
#+BEGIN_SRC emacs-lisp
(defun org-toggle-properties ()
  ;; toggle visibility of properties in current header if it exists
  (save-excursion
    (when (not (org-at-heading-p))
      (org-previous-visible-heading 1))
    (when (org-header-property-p)
      (let* ((a (re-search-forward "\n\\:" nil t)))
        (if (outline-invisible-p (point))
            (outline-show-entry)
          (org-cycle-hide-drawers 'all))))))
#+END_SRC
** Org Rifle
Search [[https://github.com/alphapapa/helm-org-rifle][rapidly]] through org files using helm
#+BEGIN_SRC emacs-lisp
  (use-package helm-org-rifle
    :commands (helm-org-rifle helm-org-rifle-agenda-files helm-org-rifle-org-directory))
#+END_SRC
** Org-Download
Drag and drop images to Emacs org-mode. Courtesy of [[https://github.com/abo-abo/org-download][abo-abo]]. 
#+BEGIN_SRC emacs-lisp
  (use-package org-download
    :commands (org-download-yank org-download-screenshot org-download-image)
    :config
     (setq org-download-method 'directory)
           org-download-image-dir "~/Dropbox/org-files/org-pictures"
           org-download-image-latex-width 500
   )
#+END_SRC
** Org Pomodoro
Helps with time tracking
#+BEGIN_SRC emacs-lisp
  (use-package org-pomodoro
    :commands org-pomodoro
    :init
    (progn
      (setq org-pomodoro-audio-player "/usr/bin/afplay")))
#+END_SRC emacs-lisp
** Org Indirect Buffer
Some advice to automatically switch to a new indirect buffer upon creation
#+BEGIN_SRC emacs-lisp
(defadvice org-tree-to-indirect-buffer (after org-tree-to-indirect-buffer-after activate) (other-window 1))
#+END_SRC


** Org Numbers Overlay
[[https://github.com/larkery/emacs/blob/master/site-lisp/org-numbers-overlay.el][This]] is a useful minor-mode to number org-mode headings. It came up in
the course of [[https://www.reddit.com/r/emacs/comments/6crtzw/it_is_possible_to_display_numbers_at_the/][this reddit]] discussion. 
#+BEGIN_SRC emacs-lisp
(define-minor-mode org-numbers-overlay-mode
  "Add overlays to org headings which number them"
  nil " *1." nil

  (let ((hooks '(after-save-hook
                 org-insert-heading-hook))
        (funcs '(org-promote
                 org-cycle-level
                 org-promote-subtree
                 org-demote
                 org-demote-subtree
                 org-move-subtree-up
                 org-move-subtree-down
                 org-move-item-down
                 org-move-item-up
                 org-cut-subtree
                 org-insert-todo-heading
                 org-insert-todo-subheading
                 org-meta-return
                 org-set-property
                 org-move)))
    (if org-numbers-overlay-mode
        (progn
          (org-numbers-overlay-update)
          (dolist (fn funcs)
            (advice-add fn :after #'org-numbers-overlay-update))
          (dolist (hook hooks)
            (add-hook hook #'org-numbers-overlay-update)))

      (progn
        (dolist (fn funcs)
          (advice-add fn :after #'org-numbers-overlay-update))
        (dolist (hook hooks)
          (remove-hook hook #'org-numbers-overlay-update))

        (loop for o in (overlays-in (point-min) (point-max))
              if (eq (overlay-get o 'type) 'org-number)
              do (delete-overlay o))))))

(defun org-numbers-overlay-update (&rest args)
  (when org-numbers-overlay-mode
    (let ((levels (make-vector 10 0)))
      (save-excursion
        (widen)
        (goto-char (point-min))
        (while (outline-next-heading)
          (if (assoc "UNNUMBERED" (org-entry-properties))
              ;; if it's unnumbered delete any overlays we have on it
              (loop for o in (overlays-in (point)
                                          (save-excursion (end-of-line) (point)))
                    if (eq (overlay-get o 'type) 'org-number)
                    do (delete-overlay o))
            ;; if it's not unnumbered add a number or update it
            (let* ((detail (org-heading-components))
                   (level (- (car detail) 1))
                   (lcounter (1+ (aref levels level)))
                   (o (or (loop for o in (overlays-in (point)
                                                      (save-excursion (end-of-line) (point)))
                                if (eq (overlay-get o 'type) 'org-number)
                                return o)
                          (make-overlay (point) (+ (point) (car detail))))))
              (aset levels level lcounter)
              (loop for i from (1+ level) to 9
                    do (aset levels i 0))
              (overlay-put o 'type 'org-number)
              (overlay-put o 'evaporate t)
              (overlay-put o 'after-string
                           (let (s)
                             (loop for i across levels
                                   until (zerop i)
                                   do (setf s (if s (format "%s.%d" s i)
                                                (format " %d" i))
                                            ))
                             s)))))))))
(provide 'org-numbers-overlay)
#+END_SRC
** Org Export
Some useful settings
#+BEGIN_SRC emacs-lisp
;; backends
(setq org-export-backends '(ascii html icalendar latex odt pandoc hugo md))
#+END_SRC
*** Org & Pandoc (Ox-pandoc)

#+BEGIN_SRC emacs-lisp
  (use-package ox-pandoc
    :after ox
    :defer 5 
    :config
    ;; default options for all output formats
    (setq org-pandoc-command (expand-file-name "/usr/local/bin/pandoc"))
    (setq org-pandoc-options '((standalone . t)))
    ;; cancel above settings only for 'docx' format
    (setq org-pandoc-options-for-docx '((standalone . nil)))
    ;; special settings for beamer-pdf and latex-pdf exporters
    (setq org-pandoc-options-for-beamer-pdf '((pdf-engine . "xelatex")))
    (setq org-pandoc-options-for-latex-pdf '((pdf-engine . "xelatex")))
    (setq org-pandoc-format-extensions '(org+smart)))

    ;; export menu options
    (defcustom org-pandoc-menu-entry
    '(
      ;;(?0 "to jats." org-pandoc-export-to-jats)
      ;;(?0 "to jats and open." org-pandoc-export-to-jats-and-open)
      ;;(?  "as jats." org-pandoc-export-as-jats)
      ;;(?1 "to epub2 and open." org-pandoc-export-to-epub2-and-open)
      ;;(?! "to epub2." org-pandoc-export-to-epub2)
      ;;(?2 "to tei." org-pandoc-export-to-tei)
      ;;(?2 "to tei and open." org-pandoc-export-to-tei-and-open)
      ;;(?" "as tei." org-pandoc-export-as-tei)
      ;;(?3 "to markdown_mmd." org-pandoc-export-to-markdown_mmd)
      ;;(?3 "to markdown_mmd and open." org-pandoc-export-to-markdown_mmd-and-open)
      ;;(?# "as markdown_mmd." org-pandoc-export-as-markdown_mmd)
      ;;(?4 "to html5." org-pandoc-export-to-html5)
      (?4 "to html5 and open." org-pandoc-export-to-html5-and-open)
      (?$ "as html5." org-pandoc-export-as-html5)
      (?5 "to html5-pdf and open." org-pandoc-export-to-html5-pdf-and-open)
      (?% "to html5-pdf." org-pandoc-export-to-html5-pdf)
      ;;(?6 "to markdown_phpextra." org-pandoc-export-to-markdown_phpextra)
      ;;(?6 "to markdown_phpextra and open." org-pandoc-export-to-markdown_phpextra-and-open)
      ;;(?& "as markdown_phpextra." org-pandoc-export-as-markdown_phpextra)
      ;;(?7 "to markdown_strict." org-pandoc-export-to-markdown_strict)
      ;;(?7 "to markdown_strict and open." org-pandoc-export-to-markdown_strict-and-open)
      ;;(?' "as markdown_strict." org-pandoc-export-as-markdown_strict)
      ;;(?8 "to opendocument." org-pandoc-export-to-opendocument)
      ;;(?8 "to opendocument and open." org-pandoc-export-to-opendocument-and-open)
      ;;(?( "as opendocument." org-pandoc-export-as-opendocument)
      ;;(?9 "to opml." org-pandoc-export-to-opml)
      ;;(?9 "to opml and open." org-pandoc-export-to-opml-and-open)
      ;;(?) "as opml." org-pandoc-export-as-opml)
      ;;(?: "to rst." org-pandoc-export-to-rst)
      ;;(?: "to rst and open." org-pandoc-export-to-rst-and-open)
      ;;(?* "as rst." org-pandoc-export-as-rst)
      ;;(?< "to slideous." org-pandoc-export-to-slideous)
      (?< "to slideous and open." org-pandoc-export-to-slideous-and-open)
      (?, "as slideous." org-pandoc-export-as-slideous)
      (?= "to ms-pdf and open." org-pandoc-export-to-ms-pdf-and-open)
      (?- "to ms-pdf." org-pandoc-export-to-ms-pdf)
      ;;(?> "to textile." org-pandoc-export-to-textile)
      ;;(?> "to textile and open." org-pandoc-export-to-textile-and-open)
      ;;(?. "as textile." org-pandoc-export-as-textile)
      ;;(?a "to asciidoc." org-pandoc-export-to-asciidoc)
      ;;(?a "to asciidoc and open." org-pandoc-export-to-asciidoc-and-open)
      ;;(?A "as asciidoc." org-pandoc-export-as-asciidoc)
      (?b "to beamer-pdf and open." org-pandoc-export-to-beamer-pdf-and-open)
      (?B "to beamer-pdf." org-pandoc-export-to-beamer-pdf)
      (?c "to context-pdf and open." org-pandoc-export-to-context-pdf-and-open)
      (?C "to context-pdf." org-pandoc-export-to-context-pdf)
      ;;(?d "to docbook5." org-pandoc-export-to-docbook5)
      (?d "to docbook5 and open." org-pandoc-export-to-docbook5-and-open)
      (?D "as docbook5." org-pandoc-export-as-docbook5)
      (?e "to epub3 and open." org-pandoc-export-to-epub3-and-open)
      (?E "to epub3." org-pandoc-export-to-epub3)
      ;;(?f "to fb2." org-pandoc-export-to-fb2)
      ;;(?f "to fb2 and open." org-pandoc-export-to-fb2-and-open)
      ;;(?F "as fb2." org-pandoc-export-as-fb2)
      ;;(?g "to gfm." org-pandoc-export-to-gfm)
      (?g "to gfm and open." org-pandoc-export-to-gfm-and-open)
      (?G "as gfm." org-pandoc-export-as-gfm)
      ;;(?h "to html4." org-pandoc-export-to-html4)
      (?h "to html4 and open." org-pandoc-export-to-html4-and-open)
      (?H "as html4." org-pandoc-export-as-html4)
      ;;(?i "to icml." org-pandoc-export-to-icml)
      (?i "to icml and open." org-pandoc-export-to-icml-and-open)
      (?I "as icml." org-pandoc-export-as-icml)
      ;;(?j "to json." org-pandoc-export-to-json)
      (?j "to json and open." org-pandoc-export-to-json-and-open)
      (?J "as json." org-pandoc-export-as-json)
      ;; (?k "to markdown." org-pandoc-export-to-markdown)
      (?k "to markdown and open." org-pandoc-export-to-markdown-and-open)
      (?K "as markdown." org-pandoc-export-as-markdown)
      (?l "to latex-pdf and open." org-pandoc-export-to-latex-pdf-and-open)
      (?L "to latex-pdf." org-pandoc-export-to-latex-pdf)
      ;;(?m "to man." org-pandoc-export-to-man)
      (?m "to man and open." org-pandoc-export-to-man-and-open)
      (?M "as man." org-pandoc-export-as-man)
      ;;(?n "to native." org-pandoc-export-to-native)
      (?n "to native and open." org-pandoc-export-to-native-and-open)
      (?N "as native." org-pandoc-export-as-native)
      (?o "to odt and open." org-pandoc-export-to-odt-and-open)
      (?O "to odt." org-pandoc-export-to-odt)
      (?p "to pptx and open." org-pandoc-export-to-pptx-and-open)
      (?P "to pptx." org-pandoc-export-to-pptx)
      ;;(?q "to commonmark." org-pandoc-export-to-commonmark)
      ;;(?q "to commonmark and open." org-pandoc-export-to-commonmark-and-open)
      ;;(?Q "as commonmark." org-pandoc-export-as-commonmark)
      ;;(?r "to rtf." org-pandoc-export-to-rtf)
      (?r "to rtf and open." org-pandoc-export-to-rtf-and-open)
      (?R "as rtf." org-pandoc-export-as-rtf)
      ;;(?s "to s5." org-pandoc-export-to-s5)
      ;;(?s "to s5 and open." org-pandoc-export-to-s5-and-open)
      ;;(?S "as s5." org-pandoc-export-as-s5)
      ;;(?t "to texinfo." org-pandoc-export-to-texinfo)
      ;;(?t "to texinfo and open." org-pandoc-export-to-texinfo-and-open)
      ;;(?T "as texinfo." org-pandoc-export-as-texinfo)
      ;;(?u "to dokuwiki." org-pandoc-export-to-dokuwiki)
      (?u "to dokuwiki and open." org-pandoc-export-to-dokuwiki-and-open)
      (?U "as dokuwiki." org-pandoc-export-as-dokuwiki)
      ;; (?v "to revealjs." org-pandoc-export-to-revealjs)
      (?v "to revealjs and open." org-pandoc-export-to-revealjs-and-open)
      (?V "as revealjs." org-pandoc-export-as-revealjs)
      ;;(?w "to mediawiki." org-pandoc-export-to-mediawiki)
      (?w "to mediawiki and open." org-pandoc-export-to-mediawiki-and-open)
      (?W "as mediawiki." org-pandoc-export-as-mediawiki)
      (?x "to docx and open." org-pandoc-export-to-docx-and-open)
      (?X "to docx." org-pandoc-export-to-docx)
      ;;(?y "to slidy." org-pandoc-export-to-slidy)
      (?y "to slidy and open." org-pandoc-export-to-slidy-and-open)
      (?Y "as slidy." org-pandoc-export-as-slidy)
      ;;(?z "to dzslides." org-pandoc-export-to-dzslides)
      (?z "to dzslides and open." org-pandoc-export-to-dzslides-and-open)
      (?Z "as dzslides." org-pandoc-export-as-dzslides)
      ;;(?{ "to muse." org-pandoc-export-to-muse)
      ;;(?{ "to muse and open." org-pandoc-export-to-muse-and-open)
      ;;(?[ "as muse." org-pandoc-export-as-muse)
      ;;(?} "to zimwiki." org-pandoc-export-to-zimwiki)
      ;;(?} "to zimwiki and open." org-pandoc-export-to-zimwiki-and-open)
      ;;(?] "as zimwiki." org-pandoc-export-as-zimwiki)
      ;;(?~ "to haddock." org-pandoc-export-to-haddock)
      ;;(?~ "to haddock and open." org-pandoc-export-to-haddock-and-open)
      ;;(?^ "as haddock." org-pandoc-export-as-haddock)
     )
    "Pandoc menu-entry."
    :group 'org-pandoc
    :type 'list)

#+END_SRC 

*** Ox-Hugo
[[https://github.com/kaushalmodi/ox-hugo][Export]] to Hugo with Org
#+BEGIN_SRC emacs-lisp
  (use-package ox-hugo :after ox)
  ;; (use-package ox-hugo-auto-export :ensure nil :after ox-hugo)
#+END_SRC


*** Org Export Top-Level Trees
From a useful [[https://emacs.stackexchange.com/questions/27226/how-to-export-top-level-trees-in-an-org-file-to-corresponding-files][stack exchange]] post
#+BEGIN_SRC emacs-lisp
(defun cpm/org-map-entries (org-file in-tags func)
  (let ((tags (if (stringp in-tags)
                   (list in-tags)
                 in-tags)))

    (with-temp-buffer
      (org-mode)
      (insert-file-contents org-file-main)

      ;; Execute func at each heading that matches tags.
      (while (< (point) (point-max))

        ;; If find a heading...
        (and (search-forward-regexp "^\* " nil "end")

             ;; ...that matches the given tags...
             (seq-reduce
              (lambda(a b) (and a b))
              (mapcar
               (lambda (tag)
                 (beginning-of-line)
                 (search-forward-regexp
                  (concat ":" tag ":") (line-end-position) "end"))
               tags)
              t)

             ;; ... then execute given function with cursor at beginning of
             ;; heading.
             (progn
               (beginning-of-line)
               (save-excursion
                 (funcall func))
               (end-of-line)))))))
#+END_SRC






** Org Miscellaneous Packages  
Other useful org packages

#+BEGIN_SRC emacs-lisp
  (use-package htmlize :commands (htmlize-buffer))
  (use-package org-inlinetask :ensure nil :commands org-inlinetask-insert-task)
  ;; ignore export of headlines marked with :ignore: tag
  (with-eval-after-load 'org
    (require 'ox-extra)
    (ox-extras-activate '(ignore-headlines)))
#+END_SRC 

** Org Keybindings
*** Evil Org 
#+BEGIN_SRC emacs-lisp
  (use-package evil-org
    :ensure t
    :after org
    :config
    (add-hook 'org-mode-hook 'evil-org-mode)
    (add-hook 'evil-org-mode-hook
              (lambda ()
                (evil-org-set-key-theme '(textobjects insert navigation additional shift))))
    (require 'evil-org-agenda)
    (evil-org-agenda-set-keys))
#+END_SRC
*** Org Local Leader Keybindings

#+BEGIN_SRC emacs-lisp
  (general-define-key
  :states '(normal visual)
  :keymaps 'org-mode-map
  :prefix "SPC m" 
  :non-normal-prefix "C-SPC m"

   ""    '(nil :which-key "Local Leader")
   "RET" #'cpm/org-archive-done-tasks
   "SPC" #'org-toggle-checkbox
   "."   #'org-cycle-agenda-files
   "/"   #'org-sparse-tree
   "="   #'org-align-all-tags
   "?"   #'org-tags-view
   ":"   #'org-set-tags
   "a"   #'super-jump-to-org-agenda
   "A"   #'org-archive-subtree
   "b"   #'org-tree-to-indirect-buffer
   "B"   #'org-babel-tangle
   "c"   #'org-capture
   "d"   #'org-time-stamp
   "D"   #'org-deadline
   "e"   #'org-edit-special
   "n"   #'cpm/narrow-or-widen-dwim
   "r"   #'org-refile
   "s"   #'org-schedule
   "t"   #'counsel-org-tag
   "T"   #'org-todo
   "v"   #'variable-pitch-mode
   "l"   #'org-insert-link
   "L"   #'org-store-link
   "+"   #'org-timestamp-up-day
   "-"   #'org-timestamp-down-day
   "<"   #'org-metaleft
   ">"   #'org-metaright

   "i"  '(:ignore t :which-key "Insert...")
         "il" #'org-insert-link
         "if" #'org-footnote-new

   "R"  '(:ignore t :which-key "RevealJS..." )
         "Rr" #'cpm/reveal-to-html-open
         "Rs" #'cpm/narrowed-subtree-to-html
         "RS" #'org-reveal-export-current-subtree
         "Rp" #'cpm/reveal-to-pdf)

  (general-define-key
    :states '(normal motion emacs)
    :keymaps 'org-agenda-mode-map
    :prefix "SPC"
    :non-normal-prefix "C-SPC"
      "<escape>" #'org-agenda-Quit
      "m"   #'org-agenda-month-view
      "C-j" #'org-agenda-next-item
      "C-k" #'org-agenda-previous-item
      "C-n" #'org-agenda-next-item
      "C-p" #'org-agenda-previous-item)
#+END_SRC
*** Alternate Bindings
#+BEGIN_SRC emacs-lisp
  (general-define-key :states '(normal) :keymaps 'org-mode-map
        "RET" 'org-open-at-point     ;; Open with return in evil
        "p"   'org-yank ;; better pasting behavior
        "s-J" 'crux-top-join-line)
  ;;   normal, insert, visual shortcuts
    (general-define-key :states '(normal insert visual) :keymaps 'org-mode-map
      "M-q" #'cpm/fill-or-unfill
      "C-t" #'transpose-chars)
  ;;   ;; normal & insert state shortcuts.
    (general-define-key :states '(normal insert) :keymaps 'org-mode-map
       ;; easily emphasize text
       ;; see https://emacs.stackexchange.com/questions/27645/unable-to-bind-emphasize-key-in-org-mode
       "s-b" (lambda () (interactive) (org-emphasize ?\*))
       "s-i" (lambda () (interactive) (org-emphasize ?\/))
       "s-l" (lambda () (interactive) (org-emphasize ?\=))
        ;; better pasting behavior in org-mode
       "s-v" 'org-yank)
#+END_SRC

* Research & Writing
** Deft
#+BEGIN_SRC emacs-lisp
  (use-package deft
    :ensure t
    :commands (deft deft-open-file-other-window big-notes zd-new-file zd-deft-new-search deft-new-file-named)
    :general
    (:keymaps 'deft-mode-map :states '(normal motion)
     "o" 'cpm/deft-open
     "p" 'cpm/deft-open-preview)
    (:keymaps 'deft-mode-map :states '(insert)
     "C-j" 'evil-next-line
     "C-k" 'evil-previous-line
     "C-o" 'cpm/deft-open
     "C-p" 'cpm/deft-open-preview)
    :config
    (add-to-list 'evil-insert-state-modes 'deft-mode)
    ;; basic settings for use with zettel
    (setq deft-directory (concat (getenv "HOME") "/Dropbox/notes/zettel/")
          deft-recursive t
          deft-use-filename-as-title t
          deft-separator " "
          deft-extensions '("md" "txt" "org")
          deft-default-extension "md")
    ;; file renaming rules
    (setq deft-file-naming-rules
        '((noslash . "-")
          (nospace . "-")
          (case-fn . downcase)))
    (setq deft-strip-summary-regexp
     (concat "\\("
             "[\n\t]" ;; blank
             "\\|^#\\+[a-zA-Z_]+:.*$" ;;org-mode metadata
             ;;yaml metadata
             "\\|^\\-\\{3\\}$"
             "\\|^[a-zA-Z_]+:.*$"
             "\\|@[a-zA-Z_].*$"
             ;; line beginning with markdown links
             "\\|^\\[.*$"
             "\\|^# .*$" ;; md titles
             "\\)"))

    ;;function to run deft in specified directory
    (defun any-deft (dir)
      "Run deft in directory DIR"
      (setq deft-directory dir)
      (switch-to-buffer "*Deft*")
      (kill-this-buffer)
      (require 'org)
      (deft))
    (defun big-notes ()
      "Goto main notes with deft"
      (interactive)
      (any-deft "~/Dropbox/Notes")
      (kill-this-buffer)
      (any-deft "~/Dropbox/Notes"))
    (defun cpm/deft-open ()
      (interactive)
      (deft-open-file-other-window t))
    (defun cpm/deft-open-preview ()
      (interactive)
      (deft-open-file-other-window)))

#+END_SRC
** Zetteldeft
A useful set of functions for managing a Zettelkasten. Based on [[https://github.com/EFLS/zetteldeft][EFLS]]. 
*** Customization

For easy but minor customization options.

#+BEGIN_SRC emacs-lisp
(defgroup zetteldeft nil
  "A zettelkasten on top of deft.")
#+END_SRC

*** Basic =zetteldeft= functions

In this section:
#+TOC: headlines 2 local

**** Search functions
***** =zd-get-thing-at-point= returns string

Returns the thing at point as string.

Tries to get, in the following order:
 - links between =[[=
 - hashtags: =§=, =#= or =@=
 - words

Based on snippet suggested by =saf-dmitry= on deft's [[https://github.com/jrblevin/deft/issues/52#issuecomment-401766828][Github]].

#+BEGIN_SRC emacs-lisp
(defun zd-get-thing-at-point ()
  "Return the thing at point, which can be a link, tag or word."
  (require 'thingatpt)
  (let* ((link-re "\\[\\[\\([^]]+\\)\\]\\]")
         (htag-re "\\([§#@][[:alnum:]_-]+\\)"))
   (cond
    ((thing-at-point-looking-at link-re)
      (match-string-no-properties 1))
     ((thing-at-point-looking-at htag-re)
      (match-string-no-properties 1))
     (t (thing-at-point 'word t)))))
#+END_SRC

***** =zd-search-at-point= thing at point

Search the thing at point.
Note that calling =zd-search-at-point= on a =§= link includes =§= in the filter string.

Based on snippet suggested by =saf-dmitry= on deft's [[https://github.com/jrblevin/deft/issues/52#issuecomment-401766828][Github]].

#+BEGIN_SRC emacs-lisp
(defun zd-search-at-point ()
  "Search deft with thing-at-point as filter.
Thing can be a double-bracketed link, a hashtag, or a word."
  (interactive)
  (let ((string (zd-get-thing-at-point)))
   (if string
       (zd-search-global string t)
     (user-error "No search term at point"))))
#+END_SRC

***** =zd-search-global= for string

Search with deft for given string.
If there is only one result, that file is opened, unless additional argument is true.

Based on snippet suggested by =saf-dmitry= on deft's [[https://github.com/jrblevin/deft/issues/52#issuecomment-401766828][Github]].

#+BEGIN_SRC emacs-lisp
(defun zd-search-global (str &optional dntOpn)
  "Search deft with STR as filter.
If there is only one result, open that file (unless DNTOPN is true)."
  ;; Sanitize the filter string
  (setq str (replace-regexp-in-string "[[:space:]\n]+" " " str))
  ;; Call deft search on the filter string
  (let ((deft-incremental-search t))
   (deft)
   (deft-filter str t))
  ;; If there is a single match, open the file
  (unless dntOpn
   (when (eq (length deft-current-files) 1)
     (deft-open-file (car deft-current-files)))))
#+END_SRC

***** =zd-search-filename= for string

Deft search on filename.
If there is only one result, open that file.

Incremental search is turned off, and the filter is set to filenames only.

#+BEGIN_SRC emacs-lisp
(defun zd-search-filename (thisStr &optional otherWindow)
  "Search for deft files with string THISSTR in filename.
Open if there is only one result (in another window if otherWindow is non-nill)."
  ;; Sanitize the filter string
  (setq thisStr (replace-regexp-in-string "[[:space:]\n]+" " " thisStr))
  ;; Call deft search on the filter string
  (let ((deft-filter-only-filenames t))
   (deft-filter thisStr t))
  ;; If there is a single match, open the file
  (when (eq (length deft-current-files) 1)
    (deft-open-file (car deft-current-files) otherWindow)))
#+END_SRC

***** =zd-search-current-id= searches current id

Deft search on the id of the current file.

This function is useful to easily see which notes link to the current file.

Result is not opened automaticaly.

Steps:
 1. Get the filename from the current buffer.
 2. Lift the ID from it.
 3. Search with resulting string.

#+BEGIN_SRC emacs-lisp
(defun zd-search-current-id ()
  "Search deft with the id of the current file as filter.
Open if there is only one result."
  (interactive)
  (zd--check)
  (zd-search-global (zd-lift-id (file-name-base (buffer-file-name))) t))
#+END_SRC

***** =zd-get-file-list= returns file list with search term

Get a list of the files with given search string.

To *fix*: sorting of results.

The code searches for the given string and returns =deft-current-files=.

#+BEGIN_SRC emacs-lisp
(defun zd-get-file-list (srch)
  "Returns a list of files with the search item SRCH."
  (let ((deft-current-sort-method 'title))
    (deft-filter srch t)
    deft-current-files))
#+END_SRC

**** IDs
***** =zd-id-format= for generating ID strings

String format when generating ids.

#+BEGIN_SRC emacs-lisp
(defcustom zd-id-format "%Y-%m%d-%H%M"
  "Format used when generating zetteldeft IDs.
Be warned: the regexp to find these IDs is set separately."
  :type 'string
  :group 'zetteldeft)
#+END_SRC

While we're at it, lets tell deft to create new files with this new format.
For good measure: I advise creating new notes in the =zetteldeft= system with =zd-new-file= or =zd-new-file-and-link= as defined below.

#+BEGIN_SRC emacs-lisp
(setq deft-new-file-format zd-id-format)
#+END_SRC

Here is the function to generate an ID string in said format.

#+BEGIN_SRC emacs-lisp
(defun zd-generate-id ()
  "Generates an id in `zd-id-format'."
  (format-time-string zd-id-format))
#+END_SRC

***** =zd-id-regex= for finding IDs

The regular expression used to search for zetteldeft IDs.

This dictates that a zetteldeft ID should consist of:
 1. a series of exactly 4 numbers
 2. followed by exactly 3 sets of a dash and two or more numbers

#+BEGIN_SRC emacs-lisp
(defcustom zd-id-regex "[0-9]\\{4\\}\\(-[0-9]\\{2,\\}\\)\\{2\\}"
  "The regex used to search for zetteldeft IDs."
  :type 'string
  :group 'zetteldeft)
#+END_SRC

***** =zd-lift-id= filters the ID from a string

Return the zetteldeft ID from any string.

Searches with a temporary buffer, from the end of the string backwards (hence the =-1= argument), which implies that the last zetteldeft string is returned.

#+BEGIN_SRC emacs-lisp
(defun zd-lift-id (str)
  "Extract the zetteldeft ID from STR with the regular expression stored in `zd-id-regex'."
  (with-temp-buffer
    (insert str)
    (when (re-search-forward zd-id-regex nil t -1)
      (match-string 0))))
#+END_SRC

Or are there better ways than working =with-temp-buffer=?

Here is a little test.

#+BEGIN_SRC emacs-lisp :exports both :tangle no :results replace value
(zd-lift-id "2018-1109-1934 Some text (1989) - testing (2000 p. 12-25)")
#+END_SRC

#+RESULTS:
: 2018-1109-1934

**** Finding & linking files from minibuffer
***** =zd-find-file= opens file from minibuffer

Select file from the deft folder from the minibuffer.

Based on =deft-find-file=.

#+BEGIN_SRC emacs-lisp
(defun zd-find-file (file)
  "Open deft file FILE."
  (interactive
    (list (completing-read "Deft find file: "
           (deft-find-all-files-no-prefix))))
  (deft-find-file file))
#+END_SRC

***** =zd-find-file-id-insert= inserts file id

Select file from minibuffer and insert its link

Based on =deft-find-file=.

#+BEGIN_SRC emacs-lisp
(defun zd-find-file-id-insert (file)
  "Find deft file FILE and insert its link id"
  (interactive (list
    (completing-read "File to insert id from: "
      (deft-find-all-files-no-prefix))))
  (insert (concat "" (zd-lift-id file))))
#+END_SRC

***** =zd-find-file-full-title-insert= inserts id and title

Select file from minibuffer and insert its link

Based on =deft-find-file=.

#+BEGIN_SRC emacs-lisp
(defun zd-find-file-full-title-insert (file)
  "Find deft file FILE and insert its link id with title"
  (interactive (list
    (completing-read "File to insert full title from: "
      (deft-find-all-files-no-prefix))))
  (insert (concat "" (file-name-base file))))
#+END_SRC

**** New file creation
***** =zd-new-file= creates new file

Create new file with filename as =zd-id-format= and a string.

Either provide a name as argument, or enter one in the mini-buffer.
A title is automatically added to the file, unless an additioanl parameter is given.
When =evil= is used, enter the insert state as well.
The full name is added to the kill ring.
Note that the file is only actually created upon save.

#+BEGIN_SRC emacs-lisp
(defun zd-new-file (str &optional empty)
  "Create a new deft file. Filename is `zd-id-format' appended by STR. No extension needed.

After creating, the title is inserted in org-mode format (unless EMPTY is true) and the full file name is added to the kill ring."
  (interactive (list (read-string "name: ")))
  (let* ((zdId (zd-generate-id))
         (zdName (concat zdId " " str)))
  (setq deft-directory "/Users/roambot/Dropbox/notes/zettel/")  
  (deft-new-file-named zdName)
  (kill-new zdName)
  (unless empty (zd-insert-md-title))
  (when (featurep 'evil) (evil-insert-state))))
#+END_SRC

***** =zd-new-file-and-link= inserts generated id

Generate an id, append a name, and generate a new file based on id and link.

Either provide a name as argument, or enter one in the mini-buffer.

#+BEGIN_SRC emacs-lisp
(defun zd-new-file-and-link (str)
  "Inserts generated id with `zd-id-format' appended with STR.
Creates new deft file with id and STR as name."
  (interactive (list (read-string "name: ")))
  (setq deft-directory "/Users/roambot/Dropbox/notes/zettel/")  
  (insert "" (zd-generate-id) "-" str)
  (zd-new-file str))
#+END_SRC

**** Moving around with =avy=
***** =zd-avy-tag-search=

Use avy to jump to a tag and search for it.

The search term should include the =#= as tag identifier, so it's as easy as jumping to the =#= and running =zd-search-at-point=.

#+BEGIN_SRC emacs-lisp
(defun zd-avy-tag-search ()
  "Call on avy to jump and search tags indicated with #."
  (interactive)
  (save-excursion
   (avy-jump zd-tag-regex)
   (zd-search-at-point)))
#+END_SRC

***** =zd-avy-link-search=

Use avy to jump to an id and search for it.

Jumps to the =[[= identifier and searches for the thing at point, excluding the =[[= character.

#+BEGIN_SRC emacs-lisp
(defun zd-avy-link-search ()
  "Call on avy to jump and search link ids indicated with [[.
Opens immediately if there is only one result."
  (interactive)
  (save-excursion
    (avy-goto-char-2 ?\[?\[)
    (zd-search-global (zd-lift-id (zd-get-thing-at-point)))))
#+END_SRC

***** FIXME =zd-avy-file-search=

Select and follow an ID link to a file.

Use avy to jump to an id and find the corresponding file. There should be only
one result, as the id should be unique. That file is then opend (in another
window if requested).

Jump to a =[[= with =avy=, get the thing at point. If it is non-nil, search it
after sanitizing.

#+BEGIN_SRC emacs-lisp
(defun zd-avy-file-search (&optional otherWindow)
 "Call on avy to jump to link ids indicated with [[ and use it to search for filenames.
Open that file (when it is the only search result, and in another window if OTHERWINDOW)."
  (interactive)
  (save-excursion
    (avy-goto-char-2 ?\[?\[)
    (forward-char)
    (zd-search-filename (zd-lift-id (zd-get-thing-at-point)) otherWindow)))
#+END_SRC

Let's also define a function to open a file in another window. Selection of
the window occurs via =ace-window=.

#+BEGIN_SRC emacs-lisp
(defun zd-avy-file-search-ace-window ()
  "Call on avy to jump to link ids indicated with [[ and use it to search for filenames.
When there is only one search result, as there should be, open that file in a window selected through `ace-window'."
  (interactive)
  (require 'ace-window)
  (save-excursion
    (avy-goto-char ?\[?\[)
    (let ((ID (zd-lift-id (zd-get-thing-at-point))))
      (select-window (aw-select "Select window..."))
      (zd-search-filename ID))))
#+END_SRC

**** Utility functions
***** Deft new search

The following function launches deft, clears the filter and enters =evil-insert-state= (when evil is used).

#+BEGIN_SRC emacs-lisp
(defun zd-deft-new-search ()
  "Launch deft, clear filter and enter insert state."
  (interactive)
  (setq deft-directory "/Users/roambot/Dropbox/notes/zettel/")  
  (deft)
  (deft-filter-clear)
  (when (featurep 'evil) (evil-insert-state)))
#+END_SRC

***** =zd--check= checks if file is part of zetteldeft

A quick but necessary check to see whether the provided file is part of the deft directory.

To achieve this, take the directory of the current buffer file name and expand it to its absolute path.
Then check whether the =deft-directory= is part of that absolute path.
Signal a user error if it is not.

#+BEGIN_SRC emacs-lisp
(defun zd--check ()
  "Checks if the currently visited file is in `zetteldeft' territory: whether it has `deft-directory' somewhere in its path."
  (unless (string-match-p
            (regexp-quote deft-directory)
            (file-name-directory (buffer-file-name)))
    (user-error "Not in zetteldeft territory.")))
#+END_SRC

***** =zd-file-rename= renames visited file

Rename the current file.
Based on the function =deft-rename-file= with only minor changes in the way =old-filename= is set: from current buffer rather than from =deft= search buffer.

Probably requires some more testing.
Anyway, best to use this only when visiting a file in the deft directory.

The function also updates the =#+title:= at the top of the buffer, if any is present.

#+BEGIN_SRC emacs-lisp
(defun zd-file-rename ()
  "Rename the current file via the deft function. Use this on files in the deft-directory."
  (interactive)
  (zd--check)
    (let ((old-filename (buffer-file-name))
          (zdId (zd-generate-id))
          (deft-dir (file-name-as-directory deft-directory))
          new-filename old-name new-name)
      (when old-filename
        (setq old-name (deft-base-filename old-filename))
        (setq new-name (read-string
                        (concat "Rename " old-name " to (without extension): ")
                        old-name))
        (setq new-filename
              (concat deft-dir zdId "-" new-name "." deft-default-extension))
        (rename-file old-filename new-filename)
        (deft-update-visiting-buffers old-filename new-filename)
        (zd-update-title-in-file)
        (deft-refresh))))
#+END_SRC

To update the title of the currently visited file, the following function is used.

#+BEGIN_SRC emacs-lisp
(defun zd-update-title-in-file ()
  "Update the TITLE in the current file, if present."
  (save-excursion
    (let ((zd-string-after-title ""))
      (goto-char (point-min))
      (when (search-forward "title:" nil t)
        (delete-region (line-beginning-position) (line-end-position))
        (zd-insert-md-title)))))
#+END_SRC

***** =zd-lift-file-title= returns file title from path

Returns only the file title from a file, removing path, extension, and link ID.

#+BEGIN_SRC emacs-lisp
(defun zd-lift-file-title (zdFile)
  "Returns the title of a zetteldeft note.
ZDFILE should be a full path to a note."
  (let ((baseName (file-name-base zdFile)))
    (replace-regexp-in-string
     "[0-9]\\{2,\\}-[0-9-]+[[:space:]]"
     "" baseName)))
#+END_SRC

***** =zd-insert-md-title= inserts file title 

Easily insert the title of the current file 

The code gets the base of the buffer file name, takes from it the file title (i.e. strips the link id at the beginning), and inserts the remaining string.

Below the title, an additional template string is inserted automatically.
This string, variable =zd-string-after-title=, can be customized and is empty by default.

#+BEGIN_SRC emacs-lisp
(defun zd-insert-md-title ()
  "Insert filename of current file as md syntax."
  (interactive)
  (zd--check)
  (insert
    "title: "
    (zd-lift-file-title (file-name-base (buffer-file-name)))
    zd-string-after-title))
#+END_SRC

Customize the string to be inserted below the title.
Used when generating a new file.

#+BEGIN_SRC emacs-lisp
(defcustom zd-string-after-title ""
  "String inserted below title when `zd-insert-md-title' is called.
Empty by default.
Don't forget to add `\\n' at the beginning to start a new line."
  :type 'string
  :group 'zetteldeft)
#+END_SRC

***** =zd-count-words= counts total number of words

To count the total number of words, lets loop over all the files and count words in each.
The total is printed in the minibuffer.

#+BEGIN_SRC emacs-lisp
(defun zd-count-words ()
  "Prints total number of words and notes in the minibuffer."
  (interactive)
  (let ((numWords 0))
    (dolist (deftFile deft-all-files)
      (with-temp-buffer
        (insert-file-contents deftFile)
        (setq numWords (+ numWords (count-words (point-min) (point-max))))))
    (message "Your zettelkasten contains %s notes with %s words in total." (length deft-all-files) numWords)))
#+END_SRC

***** =zd-copy-id-current-file= copies id in filename

Add the ID from the current file to the kill ring.

Steps:
 1. Get the filename from the buffer
 2. Strip the ID from it.
 3. Result can be empty string when no id is detected in the filename.

#+BEGIN_SRC emacs-lisp
(defun zd-copy-id-current-file ()
  "Add the id from the filename the buffer is currently visiting to the kill ring."
  (interactive)
  (zd--check)
  (let ((ID (concat "" (zd-lift-id (file-name-base (buffer-file-name))))))
    (kill-new ID)
    (message "%s" ID)))
#+END_SRC

***** =zd-id-to-full-title= returns title from ID

Convert a zetteldeft ID into its full title.

The ID should lead to only one title, obviously, so an error is thrown when this is not the case.

#+BEGIN_SRC emacs-lisp
(defun zd-id-to-full-title (zdID)
  "Return full title from given zetteldeft ID.
Throws an error when either none or multiple files with said ID are found."
  (let ((deft-filter-only-filenames t))
    (deft-filter zdID t))
  (unless (eq (length deft-current-files) 1)
    (user-error "ID Error. Either no or multiple zetteldeft files found with ID %s." zdID))
  (file-name-base (car deft-current-files)))
#+END_SRC

**** Alternative views
Here's a function to view zettel in dired with peep-dired enabled
#+BEGIN_SRC emacs-lisp
  (defun cpm/zettel-dired ()
    (interactive)
    (find-file "~/Dropbox/Notes/zettel")
    (peep-dired))
#+END_SRC
*** Listing all tags

=zd-all-tags= puts all tags in =zd-tag-list= and returns them.

Use =zd-tag-buffer= to create a buffer with all tags.

**** =zd-all-tags= returns them all

Extracting tags with =zd-extract-tags=.

#+BEGIN_SRC emacs-lisp
(defun zd-all-tags ()
  "Return a list of all the tags found in zetteldeft files."
  (setq zd-tag-list (list))
  (dolist (deftFile deft-all-files)
    (zd-extract-tags deftFile))
  zd-tag-list)
#+END_SRC

**** =zd-tag-buffer= puts all tags in a buffer

The name of the buffer we'll be using:

#+BEGIN_SRC emacs-lisp
(setq zd-tag-buffer-name "*zd-tag-buffer*")
#+END_SRC

And some code to create that buffer.

Move to the =zd-tag-buffer-name=

#+BEGIN_SRC emacs-lisp
(defun zd-tag-buffer ()
  "Switch to the *zd-tag-buffer* and list tags."
  (interactive)
  (switch-to-buffer zd-tag-buffer-name)
  (erase-buffer)
  (dolist (zdTag (zd-all-tags))
    (insert (format "%s \n" zdTag)))
  (unless (eq major-mode 'org-mode) (org-mode))
  (sort-lines nil (point-min) (point-max)))
#+END_SRC

**** Tag extracting functions

Some utility functions to achieve all of this.

***** =zd-tag-format= provides the tag-finding regex

The regular expression used to filter out tags.
Tags start with a =#= or =@= and contain least one or more letters.
Dashes are allowed.

Tags should be positioned either be at the beginning of a new line, or preceded by a space.
This should help filter out hashtags used in URLs.

#+BEGIN_SRC emacs-lisp
(defcustom zd-tag-format "\\(^\\|\s\\)[#@][a_z_]+"
  "Regular expression used to filter out tags."
  :type 'string
  :group 'zetteldeft)
#+END_SRC

***** =zd-extract-tags= from a file

Open a given file in a temporary buffer.
Loop a search for the tag regexp.
When a tag is found, remove any whitespace from it and add it to the =zd-tag-list= if it isn't there already.
Delete the found tag and search again.

#+BEGIN_SRC emacs-lisp
(defun zd-extract-tags (deftFile)
  "Find all tags in DEFTFILE and add them to zd-tag-list"
  (with-temp-buffer
    (insert-file-contents deftFile)
    (while (re-search-forward zd-tag-format nil t)
      (let ((foundTag (replace-regexp-in-string " " "" (match-string 0))))
        ;; Add found tag to zd-tag-list if it isn't there already
        (unless (member foundTag zd-tag-list)
          (push foundTag zd-tag-list)))
      ;; Remove found tag from buffer
      (delete-region (point) (re-search-backward zd-tag-format)))))
#+END_SRC

*** Gathering notes

In this section:
#+TOC: headlines 2 local

**** On "gathering notes"

Sometimes you want to easily gather all notes with a certain tag or search term.
Say you want to quickly generate a list of links to all files including the tag =#zetteldeft=.

The following functions do that for you.
There are three of them, each either taking a search term as argument or prompting for one:
 1. =zd-insert-list-links= inserts a simple list of notes which contain the search term, spelling out the full filename for each note (including ID).
 2. =zd-org-search-include= generates =org-mode= syntax to =#+INCLUDE= the files below a header with their title.
 3. =zd-org-search-insert= inserts the contents of all of these notes below their respective titles.

More documentation can be found below.
    
**** List of links
***** FIXME =zd-insert-list-links= generates list with tagged files

Creates and inserts a list with links to all files with selected search term.

The code gets a list of files that contain the search string, runs through said list and inserts a link for each entry.

To *fix*: when called from within a zetteldeft note, exclude the note itself from the generated list.

#+BEGIN_SRC emacs-lisp
(defun zd-insert-list-links (zdSrch)
  "Inserts at point a list of links to all deft files with a search string ZDSRCH.
When searching for a tag, include # manually in the search."
  (interactive (list (read-string "search string: ")))
  (dolist (zdFile (zd-get-file-list zdSrch))
    (zd-list-entry-file-link zdFile)))
#+END_SRC

***** =zd-insert-list-links-new= generates list with new links

Does the same as the above function, but only inserts IDs that aren't already present in the current file.

This is especially handy when you hope to check wheter all notes with a certain tag are linked to, or simply to list unlinked notes.

One potential *issue*, to be fixed in the future: the file from where the function is called, will also be in said list...

#+BEGIN_SRC emacs-lisp
(defun zd-insert-list-links-new (zdSrch)
  "Inserst a list of links to all deft files with a search string ZDSRCH, yet in contrast to `zd-insert-list-links' only includes links that are not yet present in the current file.
Can only be called from a file in the zetteldeft directory."
  (interactive (list (read-string "search string: ")))
  (zd--check)
  (let (zdCurrentIDs zdFoundIDs zdFinalIDs)
    (setq zdCurrentIDs (zd-extract-links (buffer-file-name)))
    ; filter IDs from search results
    (dolist (zdFile (zd-get-file-list zdSrch))
      (push (zd-lift-id zdFile) zdFoundIDs))
    ; create new list with unique ids
    (dolist (zdID zdFoundIDs)
      (unless (member zdID zdCurrentIDs)
        (push zdID zdFinalIDs)))
    ; finally find full title for each ID and insert it
    (dolist (zdID zdFinalIDs)
      (setq zdID (zd-id-to-full-title zdID))
      (insert " - " (concat "" zdID "\n")))))
#+END_SRC

***** =zd-list-entry-file-link= includes a file link as list entry

Inserts for given file a link id and title as a list entry.

#+BEGIN_SRC emacs-lisp
(defun zd-list-entry-file-link (zdFile)
  "Insert ZDFILE as list entry."
  (insert " - " (concat "" (file-name-base zdFile)) "\n"))
#+END_SRC

**** Compiling a single =org=
***** Idea and example
****** Including notes with given search term

The following explains what =zd-org-search-include= does, but the concept is more or less the same for =zd-org-search-insert=.

For each of the notes with the provided search term, it inserts a heading, a line with =#+INCLUDE= and the full path to the relevant notes.
This results in a single file that can be easily exported.

The only function meant for use on the users end, is =zd-org-search-include=.

For example,

#+BEGIN_SRC emacs-lisp :tangle no
(zd-org-search-include "#export")
#+END_SRC

inserts necessary code to include all files containing the tag =#export=.
The results would look like the following:

#+BEGIN_SRC org
\* First file title
#+INCLUDE: "/path/to/2018-07-13-2210 First file title.org"

\* File two
#+INCLUDE: "/path/to/2018-07-13-2223 File two.org"
#+END_SRC

All functions are documented below.

****** Semi-automated example

You could, for example, add the following code to a document and execute (or evaluate) it from within =org-mode=.
Add it under a "comment" type heading to prevent it from being exported itself, like so: =* COMMENT Code=.

#+BEGIN_SRC emacs-lisp :tangle no
(let (frst)
  (save-excursion
    ;; Move to next heading
    (outline-next-heading)
    (setq frst (point))
    ;; Delete everything after
    (delete-region frst (point-max))
    ;; Include the files
    (zd-org-search-include "#tag")
    ; Sort these entries alphabetically (set mark to use a region)
;   (goto-char frst) (set-mark (point-max))
;   (org-sort-entries nil ?a)
  ))
#+END_SRC

The code deletes everything after the current header and inserts all notes with =#tag= in them.

In order to also sort the entries alphabetically, uncomment the last two lines.

A final caveat: don't put the file with the above code in you =deft= folder, or it will attempt to include itself (since it has =#tag= in it).

****** Issues & things to note

Before we look at the functions, a note on limitations of the current implementation.

1. *Over-enthusiastic inclusion*
   Sometimes, a tag appears in a file without the need for it to be included.
   For example, a file with a list of all tags will also include the tag one wants.
   In the future, this might be resolved by filtering, for example with http://ergoemacs.org/emacs/elisp_filter_list.html.

2. *Inclusion from second line onwards*
   Currently, the =#+INCLUDE= lines only include from the second line onwards.
   This is a work-around to prevent =#+TITLE= lines from being included (and messing up the title on =org-export=.
   To change this, edit the inserted strings in the =zd-org-include-file= function.

3. *Sorting*
   The files included are unsorted, or rather: sorted as =deft= provides the results.
   Attempts at sorting by title are included in =zd-get-file-list=, but not working properly.
   As a solution, use =org-sort= manually after running =zd-org-search-include=.

***** =zd-org-search-include= generates =#+INCLUDE= syntax

Asks user for a search string and inserts headers and =#+INCLUDE= code for all files with said tag.
When used on =#tag=, make sure to include the =#= manually.

#+BEGIN_SRC emacs-lisp
(defun zd-org-search-include (zdSrch)
  "Inserts at point org-mode code to include all files with the selected tag. Include the # manually in the prompt."
  (interactive (list (read-string "tag (include the #): ")))
  (dolist (zdFile (zd-get-file-list zdSrch))
    (zd-org-include-file zdFile)))
#+END_SRC

***** =zd-org-search-insert= generates titles & file content

Very similar to the previous function, but rather than writing syntax to include files, insert their contents directly.

#+BEGIN_SRC emacs-lisp
(defun zd-org-search-insert (zdSrch)
  "Inserts at point all the content of the files with ZDSRCH. When looking for zetteldeft tags, include the # manually in the search."
  (interactive (list (read-string "Search term: ")))
  (dolist (zdFile (zd-get-file-list zdSrch))
    (zd-org-insert-file zdFile)))
#+END_SRC

**** Helper functions
***** =zd-insert-file-contents= returns the contents of a file

Returns the contents of a file.

#+BEGIN_SRC emacs-lisp
(defun zd-file-contents (zdFile &optional removeLines)
  "Inserts file contents of a zetteldeft note.
ZDFILE should be a full path to a note.

Optional: leave out first REMOVELINES lines."
  (with-temp-buffer
    (insert-file-contents zdFile)
    (when removeLines
      (kill-whole-line removeLines))
    (buffer-string)))
#+END_SRC

***** =zd-org-include-file= includes a file in =org= format

Inserts the title as a new header, with the =#+INCLUDE= line below.
Includes only from the second line onward, so that any =#+TITLE= lines are omitted.

#+BEGIN_SRC emacs-lisp
(defun zd-org-include-file (zdFile)
  "Insert code to include org-file zdFile."
  (insert
    ;; Insert org-mode title
    "* " (zd-lift-file-title zdFile) "\n"
    ;; Insert #+INCLUDE: "file.org" :lines 2-
    "#+INCLUDE: \"" zdFile "\" :lines \"2-\"\n\n"))
#+END_SRC

***** =zd-org-insert-file= inserts a files content

For a file, insert its title and contents (without first 3 lines).

Even better would be: without any of the lines starting with =#= at the beginning of the file.

#+BEGIN_SRC emacs-lisp
(defun zd-org-insert-file (zdFile)
  "Insert title and contents of ZDFILE."
  (insert
    ;; Insert org-mode title
    "\n* " (zd-lift-file-title zdFile) "\n\n"
    ;; Insert file contents (without the first 3 lines)
    (zd-file-contents zdFile 3)))
#+END_SRC

*** Creating visuals

In this section:
#+TOC: headlines 2 local

**** Introducing graphs

Linking notes together in plain text is fun, but sometimes you want to visualize which notes are connected.

The following functions attempt to provide said functionallity, but are in a very early stage of development.
They generate an org source block for =graphviz=, which can then be executed to generate a pdf.

A brief introduction:
 - =zd-org-graph-search= creates a graph with all the notes containing a provided string.
 - =zd-org-graph-note= creates a graph that starts at a note, connects all notes linked to it, and all notes linked to those. In other words, it looks two levels deep.


The resulting graph looks something like this:

[[./img/zd-graph.jpg]]

It's worth noting, again, that this is very provisional.
 
**** Graph functions
***** =zd-org-graph-search= creates graph from search string

An org code block with =graphviz= code for a =graph.pdf=.

Find all notes with the provided search term.
Loop over this list, and insert title and links for each one.

#+BEGIN_SRC emacs-lisp :results silent
(defun zd-org-graph-search (str)
  "Insert org source block for graph with zd search results. STR should be the search the resulting notes of which should be included in the graph."
  (interactive (list (read-string "search string: ")))
  (setq zd-graph--links (list))
  (let ((zdList (zd-get-file-list str)))
    (insert zd-graph-syntax-begin)
    (insert "\n  // links\n")
    (dolist (oneFile zdList)
      (insert "\n")
      (zd-graph-insert-links oneFile))
    (zd-graph-insert-all-titles))
  (insert zd-graph-syntax-end))
#+END_SRC

***** =zd-org-graph-note= creates graph from note

Insert an org source code block for a graphviz presentation of a note and its connections.

When links are added, they are also stored in =zd-graph--links= which is later used to insert titles.

#+BEGIN_SRC emacs-lisp
(defun zd-org-graph-note (deftFile)
  "Create a graph starting from note DEFTFILE."
  (interactive)
  (setq zd-graph--links (list))
  (insert zd-graph-syntax-begin)
  (insert "\n  // base note and links \n")
  (zd-graph-insert-links deftFile)
  (zd-graph-insert-additional-links)
  (zd-graph-insert-all-titles)
  (insert zd-graph-syntax-end))
#+END_SRC

**** Building blocks
***** =zd-graph-syntax-begin= provides opening syntax

Within graphviz, I advise to use =fdp=, =twopi= (which overlaps more) or =circo= as layouts.

#+BEGIN_SRC emacs-lisp
(defcustom zd-graph-syntax-begin
  "#+BEGIN_SRC dot :file ./graph.pdf :cmdline -Kfdp -Tpdf
  \n graph {\n"
  "Syntax to be included at the start of the zetteldeft graph.")
#+END_SRC
          
***** =zd-graph-syntax-end= provides closing syntax

#+BEGIN_SRC emacs-lisp
(defcustom zd-graph-syntax-end
  "} \n#+END_SRC\n"
  "Syntax to be included at the end of the zetteldeft graph.")
#+END_SRC

***** =zd-extract-links= pulls links from a file

Very similar to the =zd-extract-tags= function, but returns links instead of storing them.

#+BEGIN_SRC emacs-lisp
(defun zd-extract-links (deftFile)
  "Find all links in DEFTFILE and return a list."
  (let ((zdLinks (list)))
    (with-temp-buffer
      (insert-file-contents deftFile)
      (while (re-search-forward zd-id-regex nil t)
        (let ((foundTag (replace-regexp-in-string " " "" (match-string 0))))
          ;; Add found tag to zdLinks if it isn't there already
          (unless (member foundTag zdLinks)
            (push foundTag zdLinks)))
        ;; Remove found tag from buffer
        (delete-region (point) (re-search-backward zd-id-regex))))
   zdLinks))
#+END_SRC

***** =zd-graph-insert-links= inserts graphviz links

Insert the sanitized ID from the file, followed by an arrow and all of the links.

Store both the deft file provided and any found files in =zd-graph--links=.

#+BEGIN_SRC emacs-lisp
(defun zd-graph-insert-links (deftFile)
  "Inserts a file's links in a one line dot graph format.
Any inserted ID is also stored in `zd-graph--links'."
  (insert "  \""
          (zd-lift-id deftFile)
          "\" -- {")
  (dolist (oneLink (zd-extract-links deftFile))
    (zd-graph-store-link oneLink t)
    (insert "\"" oneLink "\" "))
  (insert "}\n")
  (zd-graph-store-link deftFile))
#+END_SRC

***** =zd-graph-insert-title= inserts graphviz title line

Titles have to be inserted in the correct =graphviz= format, like so:

#+BEGIN_SRC dot :tangle no :exports code
 B [label = "Node B"]
#+END_SRC

The following function should achieve that.

#+BEGIN_SRC emacs-lisp
(defun zd-graph-insert-title (deftFile)
  "Inserts the DEFTFILE title definition in a one line dot graph format."
  (let ((zdTitle (replace-regexp-in-string "\"" "" (zd-lift-file-title deftFile)))
        (zdId    (zd-lift-id deftFile)))
    (insert "  \"" zdId "\""
            " [label = \"" zdTitle " (" zdId ")\"")
    (insert "]" "\n"))
  (zd-graph-store-link deftFile))
#+END_SRC

The title is taken from the file string and any additional quotes removed.

***** =zd-graph-store-link= stores provided notes

For future reference, linked files are stored in =zd-graph--links=.
This function facilitates that process.

Provide a link to a file to store it.
Simply providing an ID works too, if you provide the second argument as true.

#+BEGIN_SRC emacs-lisp
(defun zd-graph-store-link (deftFile &optional idToFile)
  "Push DEFTFILE to zd-graph--links unless it's already there.
When IDTOFILE is non-nil, DEFTFILE is considered an id and the the function first looks for the corresponding file."
  (when idToFile
    (let ((deft-filter-only-filenames t))
      (progn
        (deft-filter deftFile t)
        (setq deftFile (car deft-current-files)))))
  (unless (member deftFile zd-graph--links)
    (push deftFile zd-graph--links)))
#+END_SRC

***** =zd-graph-insert-additional-links= inserts stored links

Insert links stored in the =zd-graph--links= list.
Except the first list item, as this is considered the base file already included.

#+BEGIN_SRC emacs-lisp
(defun zd-graph-insert-additional-links ()
  "Insert rest of `zd-graph--links'."
  (setq zd-graph--links (cdr zd-graph--links))
  (dolist (oneFile zd-graph--links)
    (zd-graph-insert-links oneFile)))
#+END_SRC

***** =zd-graph-insert-all-titles= inserts all stored titles

Insert all titles stored in =zd-graph--links=.

#+BEGIN_SRC emacs-lisp
(defun zd-graph-insert-all-titles ()
  "Insert all graphviz title lines for all links stored in `zd-graph--links'."
  (insert "\n  // titles \n")
  (dolist (oneLink zd-graph--links)
    ;; Sometimes, a 'nil' list item is present. Ignore those.
    (when oneLink
      (zd-graph-insert-title oneLink))))
#+END_SRC

*** Aesthetics
**** FIXME Highlighting zetteldeft links

Need to highlight zetteldeft links in markdown. What's below is for org-mode

Currently, the regexp to find links is hardcoded.

Highlighting not working in comments.

#+BEGIN_SRC emacs-lisp
(font-lock-add-keywords 'org-mode '(
  ("§[0-9]\\{2,\\}-[0-9-]+" . font-lock-warning-face)))
#+END_SRC

** Spelling
Use flyspell and aspell
#+BEGIN_SRC emacs-lisp
  (use-package ispell
    :commands (ispell-word ispell-region ispell-buffer)
    :config
    (when (executable-find "aspell")
      (setq ispell-program-name "aspell")
      ;; Please note ispell-extra-args contains ACTUAL parameters passed to aspell
      (setq ispell-extra-args '("--sug-mode=ultra" "--lang=en_US"))))
    ;; (when (executable-find "hunspell")
    ;;   (setq-default ispell-program-name "hunspell")
    ;;   (setq ispell-extra-args   '("-d en_US"))
    ;;   (setq ispell-really-hunspell t)))

    ;; Save a new word to personal dictionary without asking
    ;; (setq ispell-silently-savep nil)

    ;; (setq-default ispell-program-name "/usr/local/bin/aspell")
    ;; (setq ispell-extra-args
    ;;     (list "--sug-mode=fast" ;; ultra|fast|normal|bad-spellers
    ;;           "--lang=en_US"
    ;;           "--ignore=3")))

  (use-package flyspell
    :commands (flyspell-auto-correct-previous-word flyspell-correct-word-generic)
    :init
    ;; Below variables need to be set before `flyspell' is loaded.
    (setq flyspell-use-meta-tab nil)
    :custom
    (flyspell-abbrev-p t)
    (flyspell-use-global-abbrev-table-p t)
    (flyspell-issue-message-flag nil)
    (flyspell-issue-welcome-flag nil)
    :config
    ;; Use mouse
    (define-key flyspell-mouse-map [down-mouse-3] #'flyspell-correct-word)
    (define-key flyspell-mouse-map [mouse-3] #'undefined))
    (add-hook 'flyspell-mode-hook 'flyspell-buffer) ; show misspelled

  (use-package flyspell-correct-ivy
    :general
    (:states '(normal insert emacs) :keymaps 'flyspell-mode-map
     "C-;" 'flyspell-auto-correct-previous-word
     "C-:" 'flyspell-correct-word-generic)
    :custom (flyspell-correct-interface 'flyspell-correct-ivy))

  (with-eval-after-load 'hydra
    (defhydra hydra-spelling (:color blue)
    "
    ^
    ^Spelling^          ^Errors^            ^Checker^
    ^────────^──────────^──────^────────────^───────^───────
    _q_ quit            _<_ previous        _c_ correction
    ^^                  _>_ next            _d_ dictionary
    ^^                  _f_ check           _m_ mode
    ^^                  ^^                  ^^
    "
    ("q" nil)
    ("<" flyspell-correct-previous :color pink)
    (">" flyspell-correct-next :color pink)
    ("c" ispell)
    ("d" ispell-change-dictionary)
    ("f" flyspell-buffer :color pink)
    ("m" flyspell-mode)))
#+END_SRC 


** Abbrev
Abbrev mode
#+BEGIN_SRC emacs-lisp
(use-package abbrev
  :ensure nil
  :defer 2
  :config
  ;; (add-hook 'text-mode-hook #'abbrev-mode)
  (setq abbrev-file-name (concat cpm-local-dir "abbrev/.abbrev_defs")
        save-abbrevs 'nil)
  (if (file-exists-p abbrev-file-name)
      (quietly-read-abbrev-file)))
#+END_SRC

** Helm-Bibtex
Great for managing citations and notes
#+begin_src emacs-lisp
  (use-package helm-bibtex
    :commands helm-bibtex
    :config
    ;; Set insert citekey with markdown citekeys for org-mode
    (setq bibtex-completion-format-citation-functions
          '((org-mode    . bibtex-completion-format-citation-pandoc-citeproc)
          (latex-mode    . bibtex-completion-format-citation-cite)
          (markdown-mode . bibtex-completion-format-citation-pandoc-citeproc)
          (default       . bibtex-completion-format-citation-default)))
    (setq bibtex-completion-display-formats
          '((t . "${author:36} ${title:*} ${year:4} ${=has-pdf=:1}${=has-note=:1} ${=type=:7}")))
    ;; Set default action for helm-bibtex as inserting citation
    (helm-delete-action-from-source "Insert citation" helm-source-bibtex)
    (helm-add-action-to-source "Insert citation" 'helm-bibtex-insert-citation helm-source-bibtex 0)
    (setq bibtex-completion-pdf-symbol "⌘")
    (setq bibtex-completion-notes-symbol "✎")
    (setq bibtex-completion-notes-template-one-file "* ${author} (${date}): ${title} \n :PROPERTIES:\n :INTERLEAVE_PDF: ${file}\n :Custom_ID: ${=key=}\n :END:\n [[pdfview:${file}][file link]]")
    (setq bibtex-completion-notes-template-multiple-files
          "---\ntitle: '${author} (${year}): ${title}'\nnocite: |\n   @${=key=}\n---\n\n[PDF Link](${file})\n\n")
    (setq bibtex-completion-bibliography "~/Dropbox/Work/bibfile.bib" 
          bibtex-completion-library-path "~/Dropbox/Work/be-library/"
          bibtex-completion-pdf-field nil
          bibtex-completion-notes-path "~/Dropbox/Notes/zettel/reading-notes"
          ;; bibtex-completion-additional-search-fields '(keywords)
          bibtex-completion-notes-extension ".md"
          helm-bibtex-full-frame nil))
#+end_src
** Markdown mode
*** Markdown settings
#+begin_src emacs-lisp
  (use-package markdown-mode
    :commands (markdown-mode gfm-mode)
    :mode (("\\.markdown\\'" . markdown-mode)
           ("\\.md\\'"       . markdown-mode) 
           ("README\\.md\\'" . gfm-mode))
    :init
    ;; markdown hooks
    (add-hook 'markdown-mode-hook
          '(lambda ()
          (turn-on-flyspell) (auto-fill-mode) (centered-cursor-mode) (git-gutter-mode 1) (hl-todo-mode)))
    (setq markdown-command
      (concat
       "/usr/local/bin/pandoc"
       " --from=markdown --to=html"
       " --standalone --mathjax --highlight-style=pygments"
       " --css=/Users/roambot/.pandoc/pandoc.css"
       " --quiet"
       " --number-sections"
       " --lua-filter=/Users/roambot/dotfiles/pandoc/cuthead.lua"
       " --lua-filter=/Users/roambot/dotfiles/pandoc/date.lua"
       " --metadata-file=/Users/roambot/dotfiles/pandoc/metadata.yml"
       " --metadata=reference-section-title:'References & Further Reading'"
       " --bibliography=/Users/Roambot/Dropbox/Work/bibfile.bib"
       ))

    (setq markdown-enable-math nil
          markdown-enable-wiki-links t
          markdown-nested-imenu-heading-index t
          markdown-open-command "~/bin/mark.sh"
          markdown-footnote-location 'immediately
          markdown-unordered-list-item-prefix "-   "
          markdown-use-pandoc-style-yaml-metadata t)
     :config
     ;; remove strikout comment face
     (set-face-attribute 'markdown-comment-face nil 
     :weight 'bold :strike-through nil)

     )

  ;; macro: delete backslashes in paragraph to cleanup markdown conversion
  (fset 'cpm/md-delete-backslash
     (lambda (&optional arg) "Keyboard macro." (interactive "p") (kmacro-exec-ring-item (quote ("\361\361f\\x" 0 "%d")) arg)))

#+end_src
*** Pandoc
Pandoc mode for markdown conversion
#+BEGIN_SRC emacs-lisp
  (use-package pandoc-mode
    :commands (cpm/pandoc-convert-to-pdf run-pandoc pandoc-convert-to-pdf)
    :config
    (setq pandoc-use-async t)
    ;; stop pandoc from just hanging forever and not completing conversion
    ;; see https://github.com/joostkremers/pandoc-mode/issues/44
    (setq pandoc-process-connection-type nil)
    (progn
      (defun run-pandoc ()
        "Start pandoc for the buffer and open the menu"
        (interactive)
        (pandoc-mode)
        (pandoc-main-hydra/body))
      (add-hook 'pandoc-mode-hook 'pandoc-load-default-settings)

    (defun cpm/pandoc-convert-to-pdf ()
     (interactive)
     (cond
     ((eq major-mode 'org-mode)
      (call-interactively 'org-pandoc-export-to-latex-pdf-and-open))
     (t
      (call-interactively 'pandoc-convert-to-pdf) (cpm/pandoc-pdf-open) (evil-window-prev 1))))

    (defun cpm/pandoc-command-line-convert-to-pdf ()
     "convert to pdf"
     (interactive)
     (evil-ex "!pandoc -s -N -V mainfont=Optima --pdf-engine=xelatex --bibliography=~/Dropbox/Work/bibfile.bib --template=~/.pandoc/pandoc-templates/default.latex -o '%.pdf' '%'"))

    (defun cpm/pandoc-pdf-open ()
     "Open created PDF file"  
     (interactive)
     (find-file-other-window (concat (file-name-sans-extension buffer-file-name) ".pdf"))))
    :init
    (progn
      (setq pandoc-data-dir (concat cpm-local-dir "pandoc-mode/"))
      ;; help pandoc find xelatex
      (setenv "PATH" (concat (getenv "PATH") ":/Library/TeX/texbin"))))
#+END_SRC
** Writeroom (Distraction free mode)
This simulates programs like writeroom that provide a distraction-free
mode of writing. 
#+BEGIN_SRC emacs-lisp
(use-package writeroom-mode
  :commands (writeroom-mode)
  :config
  (setq writeroom-fullscreen-effect 'maximized)
  (setq writeroom-width 85)
  (setq writeroom-mode-line t)
  (setq writeroom-bottom-divider-width 0))
    (defun distraction-free ()
    "distraction free writing"
      (interactive)
      (git-gutter-mode 0) 
      (linum-mode 0) 
      (centered-cursor-mode)
      (writeroom-mode)
      )

#+END_SRC
** Interleave
[[https://github.com/rudolfochrist/interleave][Interleave]] your reading notes with the PDF.
#+BEGIN_SRC emacs-lisp
(use-package interleave
  :commands interleave)
#+END_SRC
** Lorem ipsum
Make arbitrary blocks or sentences of text.
#+BEGIN_SRC emacs-lisp
  (use-package lorem-ipsum
    :commands (Lorem-ipsum-insert-sentences Lorem-ipsum-insert-list Lorem-ipsum-insert-paragraphs)
    :config 
    (lorem-ipsum-use-default-bindings)
    )

#+END_SRC
** Palimpsest mode
#+BEGIN_SRC emacs-lisp
  (use-package palimpsest
    :defer t
    :diminish palimpsest-mode
    :init 
    (add-hook 'markdown-mode-hook 'palimpsest-mode)
    (add-hook 'org-mode-hook 'palimpsest-mode)
    :config
    (setq palimpsest-trash-file-suffix ".archive"))
#+END_SRC
** LaTeX

#+BEGIN_SRC emacs-lisp
  ;; Basic settings
  (use-package auctex
    :mode (("\\.tex\\'" . latex-mode)
           ("\\.latex\\'" . latex-mode))
    :commands (latex-mode LaTeX-mode plain-tex-mode)
    :init
    (progn
      (add-hook 'LaTeX-mode-hook #'LaTeX-preview-setup)
      (add-hook 'LaTeX-mode-hook #'flyspell-mode)
      (add-hook 'LaTeX-mode-hook #'turn-on-reftex)
      (setq-default TeX-engine 'xetex)
      (setq TeX-auto-save t
            TeX-parse-self t
            TeX-save-query nil
            TeX-PDF-mode t)
      (setq-default TeX-master nil)))

  (use-package preview
    :ensure nil
    :after auctex
    :commands LaTeX-preview-setup
    :init
    (progn
      (setq-default preview-scale 1.4
        preview-scale-function '(lambda () (* (/ 10.0 (preview-document-pt)) preview-scale)))))

  (use-package reftex
    :commands turn-on-reftex
    :init
    (progn
      (setq reftex-plug-into-AUCTeX t)))

  (use-package bibtex
    :defer t
    :mode ("\\.bib" . bibtex-mode)
    :init
    (progn
      (setq bibtex-align-at-equal-sign t)
      (add-hook 'bibtex-mode-hook (lambda () (set-fill-column 120)))))


  ;; Auto-fill for LaTeX
  (defun schnouki/latex-auto-fill ()
    "Turn on auto-fill for LaTeX mode."
    (turn-on-auto-fill)
    (set-fill-column 80)
    (setq default-justification 'left))
  (add-hook 'LaTeX-mode-hook #'schnouki/latex-auto-fill)

  ;; Compilation command
  (add-hook 'LaTeX-mode-hook (lambda () (setq compile-command "latexmk -pdflatex=xelatex -f -pdf %f")))

  ;; Prevent ispell from verifying some LaTeX commands
  ;; http://stat.genopole.cnrs.fr/dw/~jchiquet/fr/latex/emacslatex
  (defvar schnouki/ispell-tex-skip-alists
        '("cite" "nocite"
    "includegraphics"
    "author" "affil"
    "ref" "eqref" "pageref"
    "label"))
  (setq ispell-tex-skip-alists
        (list
         (append (car ispell-tex-skip-alists)
           (mapcar #'(lambda (cmd) (list (concat "\\\\" cmd) 'ispell-tex-arg-end)) schnouki/ispell-tex-skip-alists))
         (cadr ispell-tex-skip-alists)))

  ;; Indentation with align-current in LaTeX environments
  (defvar schnouki/LaTeX-align-environments '("tabular" "tabular*"))
  (add-hook 'LaTeX-mode-hook
      (lambda ()
        (require 'align)
        (setq LaTeX-indent-environment-list
        ;; For each item in the list...
        (mapcar (lambda (item)
            ;; The car is an environment
            (let ((env (car item)))
              ;; If this environment is in our list...
              (if (member env schnouki/LaTeX-align-environments)
            ;; ...then replace this item with a correct one
            (list env 'align-current)
          ;; else leave it alone
          item)))
          LaTeX-indent-environment-list))))

  ;; Use dvipdfmx to convert DVI files to PDF in AUCTeX
  (eval-after-load 'tex
    '(add-to-list 'TeX-command-list
                  '("DVI to PDF" "dvipdfmx %d" TeX-run-command t t) t))

  ;; SyncTeX (http://www.emacswiki.org/emacs/AUCTeX#toc19)
  (defun synctex/un-urlify (fname-or-url)
    "A trivial function that replaces a prefix of file:/// with just /."
    (if (string= (substring fname-or-url 0 8) "file:///")
        (substring fname-or-url 7)
      fname-or-url))

#+END_SRC


** PDF-Tools
Better than doc-view, but doesn't render well on retina screens :(
#+BEGIN_SRC emacs-lisp 
    (use-package pdf-tools
      :mode (("\\.pdf$" . pdf-view-mode))
      :commands (pdf-view-mode)
      :config
      (progn
        (pdf-tools-install)
        (evil-set-initial-state 'pdf-view-mode 'normal)
        (evil-set-initial-state 'pdf-outline-buffer-mode 'normal)
        (general-define-key :states '(normal) :keymaps 'pdf-view-mode-map
            ;; Navigation
            "j"  'pdf-view-next-line-or-next-page
            "k"  'pdf-view-previous-line-or-previous-page
            "l"  'pdf-view-next-page 
            "h"  'pdf-view-previous-page
            "J"  'image-forward-hscroll
            "K"  'image-backward-hscroll
            "gg"  'pdf-view-first-page
            "G"  'pdf-view-last-page
            "gt"  'pdf-view-goto-page
            "gl"  'pdf-view-goto-label
            "u" 'pdf-view-scroll-down-or-previous-page
            "d" 'pdf-view-scroll-up-or-next-page
            "-"  'pdf-view-shrink
            "+"  'pdf-view-enlarge
            "="  'pdf-view-fit-page-to-window
            (kbd "C-u") 'pdf-view-scroll-down-or-previous-page
            (kbd "C-d") 'pdf-view-scroll-up-or-next-page
            (kbd "``")  'pdf-history-backward
            ;; Search
            "/" 'isearch-forward
            "?" 'isearch-backward
            ;; Actions
            "r"   'pdf-view-revert-buffer
            "o"   'pdf-links-action-perform
            "O"   'pdf-outline
            "!"   'bms/pdf-no-filter
            "#"   'bms/pdf-midnight-original
            )
        (general-define-key :states '(insert) :keymaps 'pdf-view-mode-map
            "y" 'pdf-view-kill-ring-save )

       ;; midnite mode
       (setq pdf-view-midnight-colors '("#839496" . "#002b36" )) ; original values

       (defun bms/pdf-no-filter ()
       "View pdf without colour filter."
       (interactive)
       (pdf-view-midnight-minor-mode -1)
       )

      ;; change midnite mode colours functions
      (defun bms/pdf-midnite-original ()
        "Set pdf-view-midnight-colors to original colours."
        (interactive)
        (setq pdf-view-midnight-colors '("#839496" . "#002b36" )) ; original values
        (pdf-view-midnight-minor-mode)
        )

      (defun bms/pdf-midnite-amber ()
        "Set pdf-view-midnight-colors to amber on dark slate blue."
        (interactive)
        (setq pdf-view-midnight-colors '("#ff9900" . "#0a0a12" )) ; amber
        (pdf-view-midnight-minor-mode)
        )

      (defun bms/pdf-midnite-green ()
        "Set pdf-view-midnight-colors to green on black."
        (interactive)
        (setq pdf-view-midnight-colors '("#00B800" . "#000000" )) ; green
        (pdf-view-midnight-minor-mode)
        )

      (defun bms/pdf-midnite-colour-schemes ()
        "Midnight mode colour schemes bound to keys"
              (local-set-key (kbd "!") (quote bms/pdf-no-filter))
              (local-set-key (kbd "@") (quote bms/pdf-midnite-amber))
              (local-set-key (kbd "#") (quote bms/pdf-midnite-green))
                  (local-set-key (kbd "$") (quote bms/pdf-midnite-original))
       )

      (defun cpm/pdf-color-theme ()
        (if (eq active-theme 'solarized-light)
            (bms/pdf-no-filter)
          (bms/pdf-midnite-original)))

        ;; midnite mode hook
        (add-hook 'pdf-view-mode-hook (lambda ()
                                        ; automatically turns on midnight-mode for pdfs
                                        (pdf-view-midnight-minor-mode)
                                        (cpm/pdf-color-theme)
                                        (bms/pdf-midnite-colour-schemes)
                                        ; fixes blinking pdf in evil
                                        (blink-cursor-mode -1)
                                        (beacon-mode -1)))

  ))

#+END_SRC
** Org PDF View
 For annotation and jumping to file
#+BEGIN_SRC emacs-lisp
  (use-package org-pdfview
    :commands (org-pdfview-open)
    :after pdf-tools
    :init
    (add-to-list 'org-file-apps 
               '("\\.pdf\\'" . (lambda (file link)
                                  (org-pdfview-open link))))
   )
#+END_SRC
** Extract annotations
#+BEGIN_SRC emacs-lisp
  (use-package pdf-tools-org 
    :ensure nil
    :commands (pdf-tools-org-export-to-org pdf-tools-org-import-from-org))

      ;; Extracting annotations using pdf-tools
      ;; modified from https://github.com/politza/pdf-tools/pull/133 
      ;; taken from http://matt.hackinghistory.ca/2015/11/11/note-taking-with-pdf-tools/

      (defun mwp/pdf-multi-extract (sources)
      "Helper function to print highlighted text from a list of pdf's, with one org header per pdf, 
      and links back to page of highlight."
      (let (
            (output ""))
        (dolist (thispdf sources)
          (setq output (concat output (pdf-annot-markups-as-org-text thispdf nil level ))))
        (princ output))
      )

      (defun cpm/pdf-summary-extract (sources)
      "Helper function to print underlined text from a list of pdf's, with one org header per pdf, 
      and links back to page of highlight."
      (let (
            (output ""))
        (dolist (thispdf sources)
          (setq output (concat output (pdf-annot-summary-as-org-text thispdf nil level ))))
        (princ output))
      )

      ;; this is stolen from https://github.com/pinguim06/pdf-tools/commit/22629c746878f4e554d4e530306f3433d594a654
      (defun pdf-annot-edges-to-region (edges)
      "Attempt to get 4-entry region \(LEFT TOP RIGHT BOTTOM\) from several edges.
      We need this to import annotations and to get marked-up text, because annotations
      are referenced by its edges, but functions for these tasks need region."

      (let ((left0 (nth 0 (car edges)))
            (top0 (nth 1 (car edges)))
            (bottom0 (nth 3 (car edges)))
            (top1 (nth 1 (car (last edges))))
            (right1 (nth 2 (car (last edges))))
            (bottom1 (nth 3 (car (last edges))))
            (n (safe-length edges)))
        ;; we try to guess the line height to move
        ;; the region away from the boundary and
        ;; avoid double lines
        (list left0
              (+ top0 (/ (- bottom0 top0) 2))
              right1
              (- bottom1 (/ (- bottom1 top1) 2 )))))

      (defun pdf-annot-markups-as-org-text (pdfpath &optional title level)
      "Acquire highligh annotations as text, and return as org-heading"

      (interactive "fPath to PDF: ")  
      (let* ((outputstring "") ;; the text to be returned
              (title (or title (replace-regexp-in-string "-" " " (file-name-base pdfpath ))))
              (level (or level (1+ (org-current-level)))) ;; I guess if we're not in an org-buffer this will fail
              (levelstring (make-string level ?*)) ;; set headline to proper level
              (annots (sort (pdf-info-getannots nil pdfpath)  ;; get and sort all annots
                            'pdf-annot-compare-annotations)))
        ;; create the header
        (setq outputstring (concat levelstring " Quotes From " title "\n\n")) ;; create heading

        ;; extract text
        (mapc
          (lambda (annot) ;; traverse all annotations
            (if (eq 'highlight (assoc-default 'type annot))
                (let* ((page (assoc-default 'page annot))
                      ;; use pdf-annot-edges-to-region to get correct boundaries of annotation
                      (real-edges (pdf-annot-edges-to-region
                                    (pdf-annot-get annot 'markup-edges)))
                      (text (or (assoc-default 'subject annot) (assoc-default 'content annot)
                                (replace-regexp-in-string "\n" " " (pdf-info-gettext page real-edges nil pdfpath))))

                      (height (nth 1 real-edges)) ;; distance down the page
                      ;; use pdfview link directly to page number
                      (linktext (concat "[[pdfview:" pdfpath "::" (number-to-string page) 
                                        "++" (number-to-string height) "][" title  "]]" )))
                  (setq outputstring (concat outputstring text " ("
                                            linktext ", " (number-to-string page) ")\n\n"))
                  ))

            (if (eq 'text (assoc-default 'type annot))
                (let* ((page (assoc-default 'page annot))
                      ;; use pdf-annot-edges-to-region to get correct boundaries of annotation
                      (real-edges (pdf-annot-edges-to-region
                                    (pdf-annot-get annot 'markup-edges)))
                      (text (or (assoc-default 'subject annot) (assoc-default 'content annot)
                                (replace-regexp-in-string "\n" " " (pdf-info-gettext page real-edges nil pdfpath))))

                      (height (nth 1 real-edges)) ;; distance down the page
                      ;; use pdfview link directly to page number
                      (linktext (concat "[[pdfview:" pdfpath "::" (number-to-string page) 
                                        "++" (number-to-string height) "][" title  "]]" )))
                  (setq outputstring (concat outputstring text " ("
                                            linktext ", " (number-to-string page) ")\n\n"))
                  ))

              (if (eq 'underline (assoc-default 'type annot))
                  (let* ((page (assoc-default 'page annot))
                        ;; use pdf-annot-edges-to-region to get correct boundaries of highlight
                        (real-edges (pdf-annot-edges-to-region
                                      (pdf-annot-get annot 'markup-edges)))
                        (text (or (assoc-default 'subject annot) (assoc-default 'content annot)
                                  (replace-regexp-in-string "\n" " " (pdf-info-gettext page real-edges nil pdfpath))))

                        (height (nth 1 real-edges)) ;; distance down the page
                        ;; use pdfview link directly to page number
                        (linktext (concat "[[pdfview:" pdfpath "::" (number-to-string page) 
                                          "++" (number-to-string height) "][" title  "]]" )))
                    (setq outputstring (concat outputstring text " ("
                                              linktext ", " (number-to-string page) ")\n\n"))
                    ))
                  )
          annots)
        outputstring ;; return the header
        )
      )

      (defun pdf-annot-summary-as-org-text (pdfpath &optional title level)
      "Acquire underlined annotations as text, and return as org-heading"

      (interactive "fPath to PDF: ")  
      (let* ((outputstring "") ;; the text to be returned
              (title (or title (replace-regexp-in-string "-" " " (file-name-base pdfpath ))))
              (level (or level (1+ (org-current-level)))) ;; I guess if we're not in an org-buffer this will fail
              (levelstring (make-string level ?*)) ;; set headline to proper level
              (annots (sort (pdf-info-getannots nil pdfpath)  ;; get and sort all annots
                            'pdf-annot-compare-annotations)))
        ;; create the header
        (setq outputstring (concat levelstring " Summary from " title "\n\n")) ;; create heading

        ;; extract text
        (mapc
          (lambda (annot) ;; traverse all annotations
              (if (eq 'underline (assoc-default 'type annot))
                  (let* ((page (assoc-default 'page annot))
                        ;; use pdf-annot-edges-to-region to get correct boundaries of annotation
                        (real-edges (pdf-annot-edges-to-region
                                      (pdf-annot-get annot 'markup-edges)))
                        (text (or (assoc-default 'subject annot) (assoc-default 'content annot)
                                  (replace-regexp-in-string "\n" " " (pdf-info-gettext page real-edges nil pdfpath))))

                        (height (nth 1 real-edges)) ;; distance down the page
                        ;; use pdfview link directly to page number
                        (linktext (concat "[[pdfview:" pdfpath "::" (number-to-string page) 
                                          "++" (number-to-string height) "][" title  "]]" )))
                    (setq outputstring (concat outputstring text " ("
                                              linktext ", " (number-to-string page) ")\n\n"))
                    ))
                  )
          annots)
        outputstring ;; return the header
        )
      )

#+END_SRC
** TESTING Remember
A built-in [[info:remember][remember]] buffer
#+BEGIN_SRC emacs-lisp
(use-package remember
 :ensure nil
 :commands (remember remember-notes)
 :config
 (setq remember-data-dir (concat cpm-cache-dir "remember")
       remember-data-file (concat cpm-cache-dir "remember/notes"))
 (unless (file-directory-p remember-data-dir)
         (make-directory remember-data-dir t)))
 
#+END_SRC

* Miscellaneous Packages
** Restart emacs
#+BEGIN_SRC emacs-lisp
(use-package restart-emacs
  :commands restart-emacs)
#+END_SRC
** Autorevert
Auto-revert buffers of changed files
#+BEGIN_SRC emacs-lisp
  (use-package autorevert                 
    :ensure nil
    :defer 2
    :init
    (setq auto-revert-interval 1)
    (global-auto-revert-mode 1)
    :config
    (progn 
      (setq auto-revert-verbose nil ; Shut up, please!
            revert-without-query '(".*") ;; disable revert query
            ;; Revert Dired buffers, too
            global-auto-revert-non-file-buffers t)))
#+END_SRC
** URL & Request
#+BEGIN_SRC emacs-lisp
(use-package request
  :defer t
  :ensure nil
  :config
  (setq request-storage-directory (concat cpm-cache-dir "request"))
)
#+END_SRC
** Multi-compile
Like the [[https://github.com/ReanGD/emacs-multi-compile][name says]]
#+begin_src emacs-lisp
    (use-package multi-compile
      :ensure t
      :defer 3
      :config
      (setq multi-compile-completion-system 'helm)
      (setq multi-compile-alist '(
            ;; commands for pandoc 
            (markdown-mode . (
                              ("pandoc-pdf & Open" . "pandoc -s -V mainfont=Optima --pdf-engine=xelatex --bibliography=/Users/Roambot/Dropbox/Work/bibfile.bib --lua-filter=/Users/roambot/dotfiles/pandoc/cuthead.lua --lua-filter=/Users/roambot/dotfiles/pandoc/date.lua --lua-filter=/Users/roambot/dotfiles/pandoc/cutsection.lua --template=/Users/roambot/dotfiles/pandoc/pandoc-templates/default.latex --metadata-file=/Users/roambot/dotfiles/pandoc/metadata.yml -o %file-sans.pdf %file-name && open %file-sans.pdf")
                              ("pandoc-handout & Open" . "pandoc -s -V mainfont=Optima --pdf-engine=xelatex --bibliography=/Users/Roambot/Dropbox/Work/bibfile.bib --lua-filter=/Users/roambot/dotfiles/pandoc/cuthead.lua --lua-filter=/Users/roambot/dotfiles/pandoc/cutsection.lua --lua-filter=/Users/roambot/dotfiles/pandoc/cutsection.lua --lua-filter=/Users/roambot/dotfiles/pandoc/date.lua --template=/Users/Roambot/.pandoc/pandoc-templates/tufte.tex --metadata-file=/Users/roambot/dotfiles/pandoc/metadata.yml -o %file-sans.pdf %file-name && open %file-sans.pdf")
                              ("pandoc-docx & Open" . "pandoc -s --bibliography=/Users/Roambot/Dropbox/Work/bibfile.bib --reference-doc=/Users/Roambot/.pandoc/custom-reference.docx --lua-filter=/Users/roambot/dotfiles/pandoc/cutsection.lua --lua-filter=/Users/roambot/dotfiles/pandoc/cuthead.lua --lua-filter=/Users/roambot/dotfiles/pandoc/date.lua --metadata-file=/Users/roambot/dotfiles/pandoc/metadata.yml -o %file-sans.docx %file-name && open %file-sans.docx")
                              ("pandoc-html & Open" . "pandoc -f markdown -t html5 -s --bibliography=/Users/roambot/Dropbox/Work/bibfile.bib --lua-filter=/Users/roambot/dotfiles/pandoc/date.lua --lua-filter=/Users/roambot/dotfiles/pandoc/cutsection.lua --lua-filter=/Users/roambot/dotfiles/pandoc/cuthead.lua --template=/Users/roambot/.pandoc/pandoc-templates/default.html5 --css=/Users/roambot/.pandoc/pandoc.css --metadata-file=/Users/roambot/dotfiles/pandoc/metadata.yml -o %file-sans.html %file-name && open %file-sans.html")
                              ("pandoc-pdf" . "pandoc -s -V mainfont=Optima --pdf-engine=xelatex --bibliography=/Users/Roambot/Dropbox/Work/bibfile.bib --lua-filter=/Users/roambot/dotfiles/pandoc/cutsection.lua --lua-filter=/Users/roambot/dotfiles/pandoc/date.lua --lua-filter=/Users/roambot/dotfiles/pandoc/cuthead.lua --template=/Users/Roambot/.pandoc/pandoc-templates/default.latex --metadata-file=/Users/roambot/dotfiles/pandoc/metadata.yml -o %file-sans.pdf %file-name")
                              ("pandoc-docx" . "pandoc -s --bibliography=/Users/Roambot/Dropbox/Work/bibfile.bib --reference-doc=/Users/Roambot/.pandoc/custom-reference.docx --lua-filter=/Users/roambot/dotfiles/pandoc/cutsection.lua --lua-filter=/Users/roambot/dotfiles/pandoc/cuthead.lua --lua-filter=/Users/roambot/dotfiles/pandoc/date.lua --metadata-file=/Users/roambot/dotfiles/pandoc/metadata.yml -o %file-sans.docx %file-name")
                              ("pandoc-html" . "pandoc -f markdown -t html5 -s --bibliography=/Users/roambot/Dropbox/Work/bibfile.bib --lua-filter=/Users/roambot/dotfiles/pandoc/date.lua --lua-filter=/Users/roambot/dotfiles/pandoc/cutsection.lua --lua-filter=/Users/roambot/dotfiles/pandoc/cuthead.lua --template=/Users/roambot/.pandoc/pandoc-templates/default.html5 --css=/Users/roambot/.pandoc/pandoc.css --metadata-file=/Users/roambot/dotfiles/pandoc/metadata.yml -o %file-sans.html %file-name")
                              ("pandoc-handout" . "pandoc -s -V mainfont=Optima --pdf-engine=xelatex --bibliography=/Users/Roambot/Dropbox/Work/bibfile.bib --lua-filter=/Users/roambot/dotfiles/pandoc/cutsection.lua --lua-filter=/Users/roambot/dotfiles/pandoc/cuthead.lua --lua-filter=/Users/roambot/dotfiles/pandoc/date.lua --template=/Users/Roambot/.pandoc/pandoc-templates/tufte.tex --metadata-file=/Users/roambot/dotfiles/pandoc/metadata.yml -o %file-sans.pdf %file-name")
                              ("test pdf" . "pandoc -s -V mainfont=Optima --pdf-engine=xelatex --bibliography=/Users/Roambot/Dropbox/Work/bibfile.bib --lua-filter=/Users/roambot/dotfiles/pandoc/cuthead.lua --lua-filter=/Users/roambot/dotfiles/pandoc/date.lua --lua-filter=/Users/roambot/dotfiles/pandoc/cutsection.lua --template=/Users/roambot/dotfiles/pandoc/pandoc-templates/default.latex --metadata-file=/Users/roambot/dotfiles/pandoc/metadata.yml -o %file-sans.pdf %file-name && open %file-sans.pdf")))
            ((string/starts-with buffer-file-name "/Users/roambot/Dropbox/Work/projects/Book-Projects/rationality-book/") . (("compile rationality book" . "cd %make-dir && make -k && open %make-dirbuild/pdf/book.pdf")))

)))

(defun string/starts-with (string prefix)
    "Return t if STRING starts with prefix."
    (and (stringp string) (string-match (rx-to-string `(: bos ,prefix) t) string)))
#+end_src
* Private
#+BEGIN_SRC emacs-lisp
(let ((private (expand-file-name "private.el" cpm-cache-dir))) 
  (if (file-exists-p private)
	  (load-file private)))
#+END_SRC


* Post-Initialization
** Server
Start server. For the proper way to check whether a server is running see [[http://emacshorrors.com/posts/determining-if-the-server-is-started-or-the-wonders-of-server-running-p.html][this post]]. 
#+BEGIN_SRC emacs-lisp
  (use-package server
   :defer 5
   :config
    (if (display-graphic-p)
        (unless (and (boundp server-process) server-process)
           (message "Starting server...")
           (server-start)))
    )
#+END_SRC
** Page Breaks
Dashboard depends on this. 
#+BEGIN_SRC emacs-lisp
(use-package page-break-lines
  :defer t
  :diminish "")
#+END_SRC
** Dashboard
Startup with a [[https://github.com/rakanalh/emacs-dashboard][dashboard]] listing recent files, bookmarks, and projects.
#+BEGIN_SRC emacs-lisp
(use-package dashboard
  ;; :commands (dashboard-insert-startupify-lists cpm/dashboard)
 :if (< (length command-line-args) 2)
 :preface
 ;; from https://www.reddit.com/r/emacs/comments/8jaflq/tip_how_to_use_your_dashboard_properly/
 (defun cpm/dashboard-banner ()
   "Sets a dashboard banner including information on package initialization
 time and garbage collections."
   (setq dashboard-banner-logo-title
      (format "Emacs ready in %.2f seconds with %d garbage collections."
              (float-time
               (time-subtract after-init-time before-init-time)) gcs-done)))
  :init
  (add-hook 'after-init-hook 'dashboard-refresh-buffer)
  (add-hook 'dashboard-mode-hook 'cpm/dashboard-banner)
  :custom (dashboard-startup-banner "~/.emacs.d/.local/icons/64x64@2x.png")
  :config
  (set-frame-name "Dashboard")
  (evil-set-initial-state 'dashboard-mode 'motion)
  (setq dashboard-center-content t)
  (setq dashboard-items '((agenda . 5)
                          (recents  . 5)
                          (bookmarks . 5)
                          (projects . 5)))
    (dashboard-setup-startup-hook)
    (map! (:map dashboard-mode-map
      :ni     "TAB" 'widget-forward
      :ni     "C-i" 'widget-forward
      :ni     "backtab" 'widget-backward
      :ni     "RET" 'widget-button-press
      :ni     "down-mouse-1" 'widget-button-click
      :ni     "g" #'dashboard-insert-startupify-lists
      :ni     "a" (dashboard-insert-shortcut "a" "Agenda for today:")
      :ni     "r" (dashboard-insert-shortcut "r" "Recent Files:")
      :ni     "m" (dashboard-insert-shortcut "m" "Bookmarks:")
      :ni     "p" (dashboard-insert-shortcut "p" "Projects:"))))

    ;; functions to call dashboard when it kas been killed or not loaded
    (defun cpm/dashboard ()
     "load dashboard and swith to buffer"
    (interactive)
    (let ((buffer "*dashboard*"))
      (when (not (get-buffer buffer))
        (dashboard-insert-startupify-lists))
      (switch-to-buffer buffer)))

    (defun goto-dashboard ()
      "goto the dashboard"
      (interactive)
      (switch-to-buffer "*dashboard*"))
#+END_SRC
** Startup time
Display Startup time
#+BEGIN_SRC emacs-lisp

(message "Start up time %.2fs" (float-time (time-subtract (current-time) my-start-time)))

#+END_SRC
* Test
** Elisp Demos
[[https://github.com/xuchunyang/elisp-demos/][Elisp demos]] in help buffers and the like.
#+BEGIN_SRC emacs-lisp
  (use-package elisp-demos
    :ensure t
    :config
    ;; inject demos into helpful
    (advice-add 'helpful-update :after #'elisp-demos-advice-helpful-update))
#+END_SRC
** Ligatures
#+BEGIN_SRC emacs-lisp
  (defun my-correct-symbol-bounds (pretty-alist)
    "Prepend a TAB character to each symbol in this alist,
this way compose-region called by prettify-symbols-mode
will use the correct width of the symbols
instead of the width measured by char-width."
    (mapcar (lambda (el)
              (setcdr el (string ?\t (cdr el)))
              el)
            pretty-alist))

  (defun my-ligature-list (ligatures codepoint-start)
    "Create an alist of strings to replace with
codepoints starting from codepoint-start."
    (let ((codepoints (-iterate '1+ codepoint-start (length ligatures))))
      (-zip-pair ligatures codepoints)))

  ; list can be found at https://github.com/i-tu/Hasklig/blob/master/GlyphOrderAndAliasDB#L1588
  (setq my-hasklig-ligatures
    (let* ((ligs '("&&" "***" "*>" "\\\\" "||" "|>" "::"
                   "==" "===" "==>" "=>" "=<<" "!!" ">>"
                   ">>=" ">>>" ">>-" ">-" "->" "-<" "-<<"
                   "<*" "<*>" "<|" "<|>" "<$>" "<>" "<-"
                   "<<" "<<<" "<+>" ".." "..." "++" "+++"
                   "/=" ":::" ">=>" "->>" "<=>" "<=<" "<->")))
      (my-correct-symbol-bounds (my-ligature-list ligs #Xe100))))

  ;; nice glyphs for haskell with hasklig
  (defun my-set-hasklig-ligatures ()
    "Add hasklig ligatures for use with prettify-symbols-mode."
    (setq prettify-symbols-alist
          (append my-hasklig-ligatures prettify-symbols-alist))
    (prettify-symbols-mode))

  (add-hook 'text-mode-hook 'my-set-hasklig-ligatures)
#+END_SRC
** Typography
Make some writing elements easier with [[https://melpa.org/#/typo][typo.el]]
#+BEGIN_SRC emacs-lisp
  (use-package typo
    :ensure t
    :defer 5
    :config
    (typo-global-mode))
#+END_SRC
** Sunrise Commander
[[https://github.com/escherdragon/sunrise-commander][Sunrise Commander]] is an "[[https://medium.com/@enzuru/sunrise-commander-an-orthodox-file-manager-for-emacs-2f92fd08ac9e][orthodox file manager]]"
#+begin_src emacs-lisp
  (use-package sunrise-commander
    :ensure nil
    :load-path "~/.emacs.d/.local/elisp/sunrise-commander/"
    :commands (sunrise sunrise-cd)
    :bind
    (("C-x d" . sr-dired)
     :map sr-mode-map
     ("J" . sr-goto-dir)
     ("j" . dired-next-line)
     ("k" . dired-previous-line)
     ("n" . sr-goto-dir)
     ("C-k" . dired-do-kill-lines))
    :init
      (progn
        (defun cb-sunrise-commander/dired-this-dir ()
          (interactive)
          (sr-dired default-directory))

      (evil-ex-define-cmd "sr" #'sunrise)
      (evil-ex-define-cmd "sd" #'cb-sunrise-commander/dired-this-dir))

     :config
      (progn
        (setq sr-windows-locked nil)
        (setq sr-cursor-follows-mouse nil)
        (setq sr-windows-default-ratio 75)
        (setq sr-use-commander-keys nil)
        (setq dired-auto-revert-buffer t)))
#+end_src
** Insert weather
From [[https://www.baty.blog/2019/insert-weather-into-emacs-buffer][Jack Baty]] with some slight modifications for formatting. See also [[https://github.com/chubin/wttr.in][wttr.in]]. 
#+begin_src emacs-lisp
(defun cpm/insert-weather ()
  (interactive)
  (let ((w (shell-command-to-string "curl -s 'wttr.in/?0qT'")))
  (insert (mapconcat (function (lambda (x) (format ": %s" x)))
           (split-string w "\n")
           "\n")))
  (newline))
#+end_src
** Reveal in MacOS Finder
Like the [[https://github.com/kaz-yos/reveal-in-osx-finder][name says]]
#+begin_src emacs-lisp
  (use-package reveal-in-osx-finder
    :ensure t
    :defer 2)
#+end_src
** Diff-hl
VC status in [[https://github.com/dgutov/diff-hl][fringe]]. Use it only for dired tho (git gutter covers everything else).
#+begin_src emacs-lisp
  (use-package diff-hl
    :ensure t
    :defer 1
    :config
    (add-hook 'magit-post-refresh-hook 'diff-hl-magit-post-refresh)
    (add-hook 'dired-mode-hook 'diff-hl-dired-mode))
#+end_src
** FIXME Org Recur
Define [[https://github.com/m-cat/org-recur][recurring tasks]] in org
#+begin_src emacs-lisp :tangle no
  (use-package org-recur
    :ensure t
    :hook ((org-mode . org-recur-mode)
           (org-agenda-mode . org-recur-agenda-mode)
           (org-super-agenda-mode . org-recur-agenda-mode))
    :demand t
    :config
    (define-key org-recur-mode-map (kbd "C-c d") 'org-recur-finish)

    ;; Rebind the 'd' key in org-agenda (default: `org-agenda-day-view').
    (define-key org-recur-agenda-mode-map (kbd "d") 'org-recur-finish)
    (define-key org-recur-agenda-mode-map (kbd "C-c d") 'org-recur-finish)

    (setq org-recur-finish-done t
          org-recur-finish-archive t))

  ;; Refresh org-agenda after rescheduling a task.
  (defun org-agenda-refresh ()
    "Refresh all `org-agenda' buffers."
    (dolist (buffer (buffer-list))
      (with-current-buffer buffer
        (when (derived-mode-p 'org-agenda-mode)
          (org-agenda-maybe-redo)))))

  (defadvice org-schedule (after refresh-agenda activate)
    "Refresh org-agenda."
    (org-agenda-refresh))

  ;; Keep the task metadata clean:

#+end_src
