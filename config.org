#+TITLE: Emacs Literate Configuration
#+AUTHOR: Colin McLear
#+PROPERTY: header-args :tangle yes
#+COLUMNS: %35ITEM %15NAME %35DEPENDS %15TAGS %TODO
#+TODO: FIXME TESTING | DISABLED 
#+STARTUP: overview

This is my emacs configuration file. I use [[http://orgmode.org][org-mode]] to organize it and then
"tangle" the file using [[http://orgmode.org/worg/org-contrib/babel/][org-babel]]. You can find a helpful discussion of this
method [[http://stackoverflow.com/questions/17416738/emacs-initialization-as-org-file-how-can-i-get-the-right-version-of-org-mode][here]].

I use emacs for all my academic work. The configuration tends in that
direction. It also uses [[http://www.vim.org][vim]] keybindings. I used vim (or [[https://neovim.io][neovim]]) previously. I
think vim's modal editing is the best way to use a text-editor. If you like
vim bindings but don't tend to want to think about configuring emacs, I
strongly recommend [[http://spacemacs.org][spacemacs]] or [[https://github.com/hlissner/doom-emacs][doom-emacs]] as a way of managing your
configuration. For a more traditional emacs feel there are also the
configurations of [[https://github.com/purcell/emacs.d][purcell]] and [[https://github.com/bbatsov/prelude][batsov (prelude)]] and [[https://github.com/caisah/emacs.dz][many others]]. For a
minimally sane setup you might also look at some [[https://github.com/hrs/sensible-defaults.el][sensible defaults]]. This file
is also influenced by the [[https://github.com/gilbertw1/bmacs][bmacs]] configuration of Bryan Gilbert (see also his
[[https://github.com/gilbertw1/emacs-literate-starter][literate starter kit]]) and [[https://github.com/novoid/dot-emacs][Karl Voit's]] config. Use this along with my emacs
[[https://github.com/mclear-tools/dotemacs/blob/master/init.el][init file]].

* Table of Contents                                                             :TOC_2_gh:
- [[#personal-information][Personal Information]]
- [[#variables][Variables]]
  - [[#font][Font]]
  - [[#leader-keys][Leader Keys]]
  - [[#directories][Directories]]
- [[#security][Security]]
- [[#emacs-initialization][Emacs Initialization]]
  - [[#garbage-collection][Garbage Collection]]
  - [[#byte-compilation-warnings][Byte Compilation Warnings]]
  - [[#package-settings][Package Settings]]
  - [[#use-package-settings][Use-Package Settings]]
  - [[#manually-set-load-path][Manually Set Load Path]]
  - [[#initialize-package-management][Initialize Package Management]]
  - [[#paradox][Paradox]]
- [[#useful-libraries][Useful Libraries]]
- [[#functions--macros][Functions & Macros]]
  - [[#useful-functions][Useful Functions]]
  - [[#doom-macros][DOOM! Macros]]
  - [[#other-macros][Other Macros]]
- [[#emacs-settings][Emacs Settings]]
  - [[#system-defaults][System Defaults]]
  - [[#backups][Backups]]
  - [[#auto-save][Auto Save]]
  - [[#custom-file][Custom file]]
  - [[#desktop-save][Desktop save]]
  - [[#macosx][Mac/OSX]]
  - [[#time-and-date-stamps][Time and Date Stamps]]
  - [[#location][Location]]
- [[#core-packages][Core Packages]]
  - [[#modal-editing][Modal Editing]]
  - [[#session--project-management][Session & Project Management]]
  - [[#appearance--ui][Appearance & UI]]
  - [[#org-mode][Org Mode]]
  - [[#search][Search]]
  - [[#shell][Shell]]
  - [[#completion][Completion]]
  - [[#programming][Programming]]
  - [[#version-control][Version Control]]
- [[#research--writing][Research & Writing]]
  - [[#spelling][Spelling]]
  - [[#spelling-autocorrect][Spelling Autocorrect]]
  - [[#helm-bibtex][Helm-Bibtex]]
  - [[#markdown-mode][Markdown mode]]
  - [[#writeroom-distraction-free-mode][Writeroom (Distraction free mode)]]
  - [[#deft-notes][Deft Notes]]
  - [[#interleave][Interleave]]
  - [[#lorem-ipsum][Lorem ipsum]]
  - [[#palimpsest-mode][Palimpsest mode]]
  - [[#latex][LaTeX]]
  - [[#pdf-tools][PDF-Tools]]
  - [[#zotero][Zotero]]
- [[#private][Private]]
- [[#miscellaneous-packages][Miscellaneous Packages]]
  - [[#restart-emacs][Restart emacs]]
  - [[#autorevert][Autorevert]]
  - [[#url--request][URL & Request]]
- [[#post-initialization][Post-Initialization]]
  - [[#remember][Remember]]
  - [[#server][Server]]
  - [[#page-breaks][Page Breaks]]
  - [[#dashboard][Dashboard]]
  - [[#startup-time][Startup time]]
- [[#test][Test]]
  - [[#tabs][Tabs]]
  - [[#academic-phrases][Academic Phrases]]
  - [[#org-projectile][Org Projectile]]
  - [[#eterm-256-color][Eterm-256 Color]]
  - [[#quelpa][Quelpa]]
  - [[#github-stars][Github Stars]]
  - [[#mixed-pitch][Mixed-Pitch]]
  - [[#shell-path][Shell Path]]
  - [[#ligatures][Ligatures]]
  - [[#emacs-anywhere][Emacs Anywhere]]
  - [[#neotree][Neotree]]

* Personal Information
Let's set some variables with basic user information.

#+BEGIN_SRC emacs-lisp
(setq user-full-name "Colin McLear"
      user-mail-address "mclear@fastmail.com")
#+END_SRC
* Variables
** Font
 [[http://levien.com/type/myfonts/inconsolata.html][Inconsolata]] is a nice monospaced font. I've useed a version, Inconsolata-LGC,
 that also has bold and italic fonts. I'm currently using [[https://github.com/i-tu/Hasklig/issues/84][hasklig]], which is a
 fork of [[https://github.com/adobe-fonts/source-code-pro][Source Code Pro]] with ligatures added.  
 
 To install a font on OS X, you can use Homebrew with [[http://caskroom.io/][Homebrew Cask]].

 #+begin_src sh :tangle no

 # You may need to run these two lines if you haven't set up Homebrew
 # Cask and its fonts formula.
 brew install caskroom/cask/brew-cask
 brew tap caskroom/fonts
 brew cask install font-inconsolata-lgc

 #+END_SRC

 Here I set the variable values, including a variable font face for themes
 that use that for headings, such as [[*Solarized][solarized]]. The settings are called [[git:~/.emacs.d/config.org::master@{2018-04-09}::2426][below]].

 #+BEGIN_SRC emacs-lisp
 (defvar cpm-font (font-spec :family "Hasklig" :size 13))
 (defvar cpm-vari-font (font-spec :family "Avenir"))
 (defvar cpm-unicode-font (font-spec :family "STIXGeneral"))
 #+END_SRC
** FIXME Leader Keys

 Define the leader and local leader keys. These are the basis for some of the
 custom keybinds using the DOOM! mappings. # NOTE: not really using this anymore

 #+BEGIN_SRC emacs-lisp
 (eval-and-compile
   (defvar cmacs-leader-key "SPC"
     "The leader prefix key, for global commands.")

   (defvar cmacs-localleader-key "SPC m"
     "The localleader prefix key, for major-mode specific commands."))
 #+END_SRC
** Directories

 We're going to define a number of directories that are used throughout this
 configuration to store different types of files.

 #+BEGIN_SRC emacs-lisp
   (eval-and-compile
     (defvar cpm-emacs-dir (expand-file-name user-emacs-directory)
       "The path to the emacs.d directory.")

     (defvar cpm-local-dir (concat cpm-emacs-dir ".local/")
       "Root directory for local Emacs files. Use this as permanent
     storage for files that are safe to share across systems (if
     this config is symlinked across several computers).")

     (defvar cpm-host-dir (concat cpm-local-dir "@" (system-name))
       "Directory for hostname-specific file storage. Used by `cpm-etc-dir' and
     `cpm-cache-dir'.")

     (defvar cpm-etc-dir (concat cpm-host-dir "/etc/")
       "Host-namespaced directory for non-volatile storage. These are not deleted or
     tampored with by emacs functions. Use this for dependencies like servers or
     config files that are stable (i.e. it should be unlikely that you need to delete
     them if something goes wrong).")

     (defvar cpm-cache-dir (concat cpm-host-dir "/cache/")
       "Host-namespaced directory for volatile storage. Deleted when `cpm/reset' is
     called. Use this for transient files that are generated on the fly like caches
     and temporary files. Anything that may need to be cleared if there are
     problems.")

     (defvar cpm-elisp-dir (concat cpm-local-dir "/elisp/")
       "Where personal elisp packages and scripts are stored.")


     (dolist (dir (list cpm-local-dir cpm-etc-dir cpm-cache-dir cpm-elisp-dir))
       (unless (file-directory-p dir)
     (make-directory dir t))))
 #+END_SRC

* Security 
Properly verify outgoing ssl connections.

#+BEGIN_SRC emacs-lisp
(setq gnutls-verify-error t
      tls-checktrust gnutls-verify-error
      tls-program (list "gnutls-cli --x509cafile %t -p %p %h"
                        ;; compatibility fallbacks
                        "gnutls-cli -p %p %h"
                        "openssl s_client -connect %h:%p -no_ssl2 -no_ssl3 -ign_eof")
      nsm-settings-file (expand-file-name "network-security.data" cpm-cache-dir))
#+END_SRC
* Emacs Initialization
** Garbage Collection 
We increase the gc-cons-threshold to a very high number to decrease the load
and compile time. We'll lower this value significantly after initialization
has completed. We don't want to keep this value too high or it will result in
long GC pauses during normal usage.

#+BEGIN_SRC emacs-lisp 
(defun cpm/config-setup-hook ()
  (eval-and-compile
  (setq gc-cons-threshold most-positive-fixnum
        gc-cons-percentage 0.6)))

(defun cpm/config-exit-hook ()
  (setq gc-cons-threshold 80000
      gc-cons-percentage 0.1))

(add-hook 'before-init-hook #'cpm/config-setup-hook)
(add-hook 'after-init-hook  #'cpm/config-exit-hook)

#+END_SRC
** Byte Compilation Warnings
Disable certain byte compiler warnings to cut down on the noise. This is a
personal choice and can be removed if you would like to see any and all byte
compiler warnings.

#+BEGIN_SRC emacs-lisp
(setq byte-compile-warnings '(not free-vars unresolved noruntime lexical make-local))
#+END_SRC
** Package Settings
We're going to set the =load-path= ourselves and avoid calling
=(package-initilize)= (for performance reasons) so we need to set
=package--init-file-ensured= to true to tell =package.el= to not automatically
call it on our behalf. Additionally we're setting =package-enable-at-startup= to
nil so that packages will not automatically be loaded for us since =use-package=
will be handling that.

#+BEGIN_SRC emacs-lisp
  (eval-and-compile
    (setq load-prefer-newer t
          package-user-dir (concat cpm-local-dir "/elpa/") 
          package--init-file-ensured t
          package-enable-at-startup nil)

    (unless (file-directory-p package-user-dir)
      (make-directory package-user-dir t)))
#+END_SRC

** Use-Package Settings
I used to tell =use-package= to always defer loading packages unless explicitly
told otherwise. This speeds up initialization significantly as many packages
are only loaded later when they are explicitly used. But it can also [[https://github.com/jwiegley/use-package#loading-packages-in-sequence][cause
problems]]. I've since revised all my defer settings. I explicitly
defer/demand, and put a lot of loading of packages off until after about 10
secs of idle. The latter means package loading stays out of my way if I'm
doing, e.g., a quick restart-and-check of something in emacs. But I still
use always-defer, as it seems to shave another .4 secs off load time. 

#+BEGIN_SRC emacs-lisp
  (setq use-package-always-defer t
        use-package-verbose t)
#+END_SRC


** Manually Set Load Path
We're going to set the load path ourselves so that we don't have to call
=package-initialize= at runtime and incur a large performance hit. This
load-path will actually be faster than the one created by =package-initialize=
because it appends the elpa packages to the end of the load path. Otherwise
any time a builtin package was required it would have to search all of third
party paths first.

#+BEGIN_SRC emacs-lisp
  (eval-and-compile
    (setq load-path (append load-path (directory-files package-user-dir t "^[^.]" t))))
#+END_SRC

** Initialize Package Management
Next we are going to require =package.el= and add our additional package
archives, 'melpa' and 'org'. Afterwards we need to initialize our packages and
then ensure that =use-package= is installed, which we promptly install if it's
missing. Finally we load =use-package= and tell it to always install any missing
packages.

Note that this entire block is wrapped in =eval-when-compile=. The effect of
this is to perform all of the package initialization during compilation so
that when byte compiled, all of this time consuming code is skipped. This can
be done because the result of byte compiling =use-package= statements results in
the macro being fully expanded at which point =use-package= isn't actually
required any longer.

Since the code is automatically compiled during runtime, if the configuration
hasn't already been previously compiled manually then all of the package
initialization will still take place at startup.

#+BEGIN_SRC emacs-lisp
  (eval-when-compile
    (require 'package)

    (unless (assoc-default "melpa" package-archives)
      (add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/") t))
    (unless (assoc-default "gnu" package-archives)
      (add-to-list 'package-archives '("gnu" . "https://elpa.gnu.org/packages/") t))
    (unless (assoc-default "org" package-archives)
      (add-to-list 'package-archives '("org" . "https://orgmode.org/elpa/") t))
    ;; https://github.com/emacs-china/emacswiki-elpa
    (unless (assoc-default "emacswiki" package-archives)
      (add-to-list 'package-archives '("emacswiki" . "https://mirrors.tuna.tsinghua.edu.cn/elpa/emacswiki/") t))


    (package-initialize)
    (unless (package-installed-p 'use-package)
      (package-refresh-contents)
      (package-install 'use-package))
    (require 'use-package)
    (setq use-package-always-ensure t))
#+END_SRC

** Paradox
#+BEGIN_SRC emacs-lisp
(use-package paradox
  :commands (paradox-list-packages paradox-upgrade-packages)
  :config
  (add-to-list 'evil-emacs-state-modes 'paradox-menu-mode)
  (setq paradox-execute-asynchronously nil
         ;; Show all possible counts
        paradox-display-download-count t
        paradox-display-star-count t
        ;; Don't star automatically
        paradox-automatically-star nil))
#+END_SRC

* Useful Libraries

[[https://github.com/jwiegley/emacs-async][async]], [[https://github.com/magnars/s.el][s]], [[https://github.com/magnars/dash.el][dash]], and [[http://elpa.gnu.org/packages/cl-lib.html][cl-lib]] are libraries for asynchronous processing,
string manipulation, list manipulation and backward compatibility
respectively. The git package is also a library.

#+BEGIN_SRC emacs-lisp
(use-package async   :defer 10)
(use-package dash    :defer 10)
(use-package s       :defer 10)
(use-package f       :defer 10)
(use-package git     :defer 10)
(use-package subr-x  :defer 10 :ensure nil)
; lots of packages depend on these libraries
(use-package cl-lib  :demand t :ensure nil)
(use-package cl      :demand t :ensure nil)
#+END_SRC

* Functions & Macros
** Useful Functions 
Various useful functions and macros I've written or pilfered from others. 
*** Archive All Done Tasks
Useful function for archiving done tasks. From [[https://stackoverflow.com/a/27043756][stack overflow]].
#+BEGIN_SRC emacs-lisp
(defun cpm/org-archive-done-tasks ()
  (interactive)
  (org-map-entries
   (lambda ()
     (org-archive-subtree)
     (setq org-map-continue-from (outline-previous-heading)))
   "/DONE" 'agenda))
#+END_SRC
*** Blank Buffer New Frame
Make a blank buffer when opening a new frame. From
https://stackoverflow.com/a/25792276. I added a call to persp-mode since I
only ever want new frames to use new perspectives
#+BEGIN_SRC emacs-lisp
(defun cpm/new-buffer-new-frame ()
  "Create a new frame with a new empty buffer & turn on persp-mode."
  (interactive)
  (persp-mode 1)
  (let ((buffer (generate-new-buffer "untitled")))
    (set-buffer-major-mode buffer)
    (display-buffer buffer '(display-buffer-pop-up-frame . nil))))
#+END_SRC
*** Built-in Functions
These are useful built-in functions, but you have to enable them
#+BEGIN_SRC emacs-lisp
  (put 'erase-buffer 'disabled nil)
  (put 'downcase-region 'disabled nil)
  (put 'upcase-region 'disabled nil)
  (put 'narrow-to-region 'disabled nil)
  (put 'dired-find-alternate-file 'disabled nil)
#+END_SRC
*** Call an emacs instance
Call an emacs instance for testing
#+BEGIN_SRC emacs-lisp
  (defun cpm/call-emacs ()
    (interactive)
    (start-process "Emacs" nil
                   (executable-find "/Applications/Emacs.app/Contents/MacOS/Emacs")))
#+END_SRC
*** Clipboard to/from Buffer
#+BEGIN_SRC emacs-lisp
  ;; http://stackoverflow.com/a/10216338/4869
  (defun cpm/copy-whole-buffer-to-clipboard ()
    "Copy entire buffer to clipboard"
    (interactive)
    (clipboard-kill-ring-save (point-min) (point-max)))

  (defun cpm/copy-clipboard-to-whole-buffer ()
    "Copy clipboard and replace buffer"
    (interactive)
    (delete-region (point-min) (point-max))
    (clipboard-yank)
    (deactivate-mark))
#+END_SRC
*** Config functions
Useful functions for calling config files
#+BEGIN_SRC emacs-lisp
  (defun goto-init.el ()
    "Open init.el file"
    (interactive)
    (find-file "~/.emacs.d/init.el"))
  (defun goto-custom.el ()
    "Open custom.el file"
    (interactive)
    (find-file "~/.emacs.d/custom.el"))
  (defun goto-config.org ()
    "Open config.org file"
    (interactive)
    (find-file "~/.emacs.d/config.org"))
  (defun cpm/compile-dotemacs ()
    "Byte compile all files in the .emacs.d base directory"
    (interactive)
    (byte-recompile-directory cpm-emacs-dir 0 t))
  (defun load-config ()
    "Load config "
    (interactive)
    (cpm/tangle-emacs-config)
    (load-file "~/.emacs.d/init.el"))
  (defun goto-dotfiles.org ()
    "Open dotfiles.org file"
    (interactive)
    (find-file "~/dotfiles/dotfiles.org"))
  (defun goto-emacs-dir ()
    "Open dotfiles.org file"
    (interactive)
    (require 'ranger)
     (find-file "~/.emacs.d"))
  (defun goto-org-files ()
    "Open directory with org files"
    (interactive)
    (require 'ranger)
    (find-file org-directory))


#+END_SRC
*** Copy formatted org-mode text to rtf
Via the always resourceful [[http://kitchingroup.cheme.cmu.edu/blog/2016/06/16/Copy-formatted-org-mode-text-from-Emacs-to-other-applications/][John Kitchin]].
#+BEGIN_SRC emacs-lisp
  (defun formatted-copy ()
  "Export region to HTML, and copy it to the clipboard."
  (interactive)
  (save-window-excursion
    (let* ((buf (org-export-to-buffer 'html "*Formatted Copy*" nil nil t t))
           (html (with-current-buffer buf (buffer-string))))
      (with-current-buffer buf
        (shell-command-on-region
         (point-min)
         (point-max)
         "textutil -stdin -format html -convert rtf -stdout | pbcopy")) 
      (kill-buffer buf))))

(global-set-key (kbd "H-w") 'formatted-copy)

#+END_SRC
*** Crux
A collection of ridiculously useful extensions. Indeed.
#+BEGIN_SRC emacs-lisp
(use-package crux :defer 10)
#+END_SRC
*** Cycle Through Useful Buffers
From a [[http://ergoemacs.org/emacs/elisp_next_prev_user_buffer.html][useful post]] by Xah. 
#+BEGIN_SRC emacs-lisp
(defun cpm/user-buffer-q ()
  "Return t if current buffer is a user buffer, else nil.
Typically, if buffer name starts with *, it's not considered a user buffer.
This function is used by buffer switching command and close buffer command, so that next buffer shown is a user buffer.
You can override this function to get your idea of “user buffer”.
version 2016-06-18"
  (interactive)
  (if (string-equal "*" (substring (buffer-name) 0 1))
      nil
    (if (string-equal major-mode "dired-mode")
        nil
      t
      )))

(defun cpm/next-user-buffer ()
  "Switch to the next user buffer.
“user buffer” is determined by `cpm/user-buffer-q'.
URL `http://ergoemacs.org/emacs/elisp_next_prev_user_buffer.html'
Version 2016-06-19"
  (interactive)
  (next-buffer)
  (let ((i 0))
    (while (< i 20)
      (if (not (cpm/user-buffer-q))
          (progn (next-buffer)
                 (setq i (1+ i)))
        (progn (setq i 100))))))

(defun cpm/previous-user-buffer ()
  "Switch to the previous user buffer.
“user buffer” is determined by `cpm/user-buffer-q'.
URL `http://ergoemacs.org/emacs/elisp_next_prev_user_buffer.html'
Version 2016-06-19"
  (interactive)
  (previous-buffer)
  (let ((i 0))
    (while (< i 20)
      (if (not (cpm/user-buffer-q))
          (progn (previous-buffer)
                 (setq i (1+ i)))
        (progn (setq i 100))))))
#+END_SRC
*** Delete Current File
#+BEGIN_SRC emacs-lisp
  ;; from magnars
  (defun cpm/delete-current-buffer-file ()
    "Removes file connected to current buffer and kills buffer."
    (interactive)
    (let ((filename (buffer-file-name))
          (buffer (current-buffer))
          (name (buffer-name)))
      (if (not (and filename (file-exists-p filename)))
          (ido-kill-buffer)
        (when (yes-or-no-p "Are you sure you want to delete this file? ")
          (delete-file filename t)
          (kill-buffer buffer)
          (message "File '%s' successfully removed" filename)))))
#+END_SRC
*** Delete Dotemacs Byte Files
#+BEGIN_SRC emacs-lisp
(defun cpm/delete-byte-compiled-files ()
  (interactive)
  (shell-command-to-string "trash ~/.emacs.d/*.elc"))
#+END_SRC
*** Duplicate file
Duplicate a file in dired or deer
#+BEGIN_SRC emacs-lisp
(defun cpm/duplicate-file ()
  (interactive)
  (dired-do-copy-regexp "\\(.*\\)\\.\\(.*\\)" "\\1 (copy).\\2"))
#+END_SRC
*** Eval emacs buffer until error
#+BEGIN_SRC emacs-lisp
  (defun cpm/eval-buffer-until-error ()
  "Evaluate emacs buffer until error occured."
  (interactive)
  (goto-char (point-min))
  (while t (eval (read (current-buffer)))))
#+END_SRC
*** Fill/Unfill Paragraphs
Artur Malabarba has a [[http://endlessparentheses.com/fill-and-unfill-paragraphs-with-a-single-key.html][useful discussion]] of how to fill/unfill
paragraphs with the same command.
#+BEGIN_SRC emacs-lisp
(defun cpm/fill-or-unfill ()
  "Like `fill-paragraph', but unfill if used twice."
  (interactive)
  (let ((fill-column
         (if (eq last-command 'cpm/fill-or-unfill)
             (progn (setq this-command nil)
                    (point-max))
           fill-column)))
    (call-interactively #'fill-paragraph)))

(global-set-key [remap fill-paragraph]
                #'cpm/fill-or-unfill)
#+END_SRC
*** Goto journal 
#+BEGIN_SRC emacs-lisp
  (defun cpm/goto-journal ()
    (interactive)
    (find-file "/Users/Roambot/Dropbox/org-files/journal.org"))
#+END_SRC
*** Jump in buffer
I got the inspiration for this from the [[https://github.com/syl20bnr/spacemacs/blob/5f26b82e1abdde81cdf7cd17ba06f64db2343667/layers/%2Bdistribution/spacemacs-base/funcs.el][spacemacs config]]. Useful for
navigating in tagged buffers.
#+BEGIN_SRC emacs-lisp
(defun cpm/jump-in-buffer ()
  (interactive)
    (cond
     ((eq major-mode 'org-mode)
      (call-interactively 'counsel-org-goto))
     (t
      (call-interactively 'helm-semantic-or-imenu))))
#+END_SRC
*** Jump to sexp
#+BEGIN_SRC emacs-lisp
(defun cpm/forward-or-backward-sexp (&optional arg)
  "Go to the matching parenthesis character if one is adjacent to point."
  (interactive "^p")
  (cond ((looking-at "\\s(") (forward-sexp arg))
        ((looking-back "\\s)" 1) (backward-sexp arg))
        ;; Now, try to succeed from inside of a bracket
        ((looking-at "\\s)") (forward-char) (backward-sexp arg))
        ((looking-back "\\s(" 1) (backward-char) (forward-sexp arg))))
#+END_SRC
*** Make move
#+BEGIN_SRC emacs-lisp
(defun cpm/make-move ()
  "move files to project web directory"
   (interactive)
   (evil-ex "!make move"))
#+END_SRC
*** Make parent directory
 Create a directory – or a hierarchy of them – while finding a file in a
 nonexistent directory. From [[http://mbork.pl/2016-07-25_Making_directories_on_the_fly][mbork]]. 
#+BEGIN_SRC emacs-lisp
  (defun make-parent-directory ()
    "Make sure the directory of `buffer-file-name' exists."
    (make-directory (file-name-directory buffer-file-name) t))

  (add-hook 'find-file-not-found-functions #'make-parent-directory)
#+END_SRC
*** Move File
#+BEGIN_SRC emacs-lisp
(defun cpm/move-file ()
  "Write this file to a new location, and delete the old one."
  (interactive)
  (let ((old-location (buffer-file-name)))
    (call-interactively #'write-file)
    (when old-location
      (delete-file old-location))))
#+END_SRC
*** Narrow or Widen
Narrow a region, or if narrowed, widen. Courtesy of the ever
resourceful [[http://endlessparentheses.com/emacs-narrow-or-widen-dwim.html][Artur Malabarba]].
#+BEGIN_SRC emacs-lisp
(defun cpm/narrow-or-widen-dwim (p)
  "Widen if buffer is narrowed, narrow-dwim otherwise.
Dwim means: region, org-src-block, org-subtree, or
defun, whichever applies first. Narrowing to
org-src-block actually calls `org-edit-src-code'.

With prefix P, don't widen, just narrow even if buffer
is already narrowed."
  (interactive "P")
  (declare (interactive-only))
  (cond ((and (buffer-narrowed-p) (not p)) (widen))
        ((region-active-p)
         (narrow-to-region (region-beginning)
                           (region-end)))
        ((derived-mode-p 'org-mode)
         ;; `org-edit-src-code' is not a real narrowing
         ;; command. Remove this first conditional if
         ;; you don't want it.
         (cond ((ignore-errors (org-edit-src-code) t)
                (delete-other-windows))
               ((ignore-errors (org-narrow-to-block) t))
               (t (org-narrow-to-subtree))))
        ((derived-mode-p 'latex-mode)
         (LaTeX-narrow-to-environment))
        (t (narrow-to-defun))))


#+END_SRC
*** New Git Project
Courtesy of a helpful [[https://www.reddit.com/r/emacs/comments/70ke5w/help_fix_my_workflow_to_create_a_new_gitmanaged/][reddit post]]
#+BEGIN_SRC emacs-lisp
(defun cpm/git-new-project ()
  "Initializes a new git repo and adds it to projectile's known projects."
  (interactive)
  (let ((project-dir (expand-file-name
                      (read-directory-name "New project root:"))))
    (magit-init project-dir)
    (projectile-add-known-project project-dir)
    (setq default-directory project-dir)))
#+END_SRC
*** Open projects directory
#+BEGIN_SRC emacs-lisp
  (defun cpm/goto-projects ()
      "Open projects dir"
      (interactive)
      (require 'ranger)
      (find-file "~/Dropbox/Work/projects"))

#+END_SRC
*** Org Tree to File
Send an org tree to its own file. Inspiration from [[https://superuser.com/a/659823][this]] superuser answer.
#+begin_src emacs-lisp
(defun cpm/subtree-to-new-file ()
  (interactive)
  "Move an org subtree to a new file"
  (org-copy-subtree nil t)
  (find-file-other-window  
    (read-file-name "Move subtree to file:" "$HOME"))
(org-paste-subtree))
#+end_src
*** Org wrap in block template
A helpful function I found [[http://pragmaticemacs.com/emacs/wrap-text-in-an-org-mode-block/][here]] for wrapping text in a block template. 
#+begin_src emacs-lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; function to wrap blocks of text in org templates                       ;;
;; e.g. latex or src etc                                                  ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun org-block-wrap ()
  "Make a template at point."
  (interactive)
  (if (org-at-table-p)
      (call-interactively 'org-table-rotate-recalc-marks)
    (let* ((choices '(
                      ("a" . "ASCII")
                      ("c" . "COMMENT")
                      ("C" . "CENTER")
                      ("e" . "EXAMPLE")
                      ("E" . "SRC emacs-lisp")
                      ("h" . "HTML")
                      ("l" . "LaTeX")
                      ("n" . "NOTES")
                      ("q" . "QUOTE")
                      ("s" . "SRC")
                      ("v" . "VERSE")
                      ))
           (key
            (key-description
             (vector
              (read-key
               (concat (propertize "Template type: " 'face 'minibuffer-prompt)
                       (mapconcat (lambda (choice)
                                    (concat (propertize (car choice) 'face 'font-lock-type-face)
                                            ": "
                                            (cdr choice)))
                                  choices
                                  ", ")))))))
      (let ((result (assoc key choices)))
        (when result
          (let ((choice (cdr result)))
            (cond
             ((region-active-p)
              (let ((start (region-beginning))
                    (end (region-end)))
                (goto-char end)
                (insert "#+END_" choice "\n")
                (goto-char start)
                (insert "#+BEGIN_" choice "\n")))
             (t
              (insert "#+BEGIN_" choice "\n")
              (save-excursion (insert "#+END_" choice))))))))))

#+end_src
*** Pandoc conversion from clipboard
#+BEGIN_SRC emacs-lisp
  (defun cpm/org-to-markdown ()
    "convert clipboard contents from org to markdown and paste"
    (interactive)
    (kill-new (shell-command-to-string "osascript -e 'the clipboard as unicode text' | pandoc --atx-headers -f org -t markdown"))
    (yank))

  (defun cpm/markdown-to-org ()
    "convert clipboard contents from markdown to org and paste"
    (interactive)
    (kill-new (shell-command-to-string "osascript -e 'the clipboard as unicode text' | pandoc -f markdown -t org"))
    (yank))

  (defun cpm/tex-to-org ()
    "convert clipboard contents from markdown to org and paste"
    (interactive)
    (kill-new (shell-command-to-string "osascript -e 'the clipboard as unicode text' | pandoc -f latex -t org --atx-headers"))
    (yank))

  (defun cpm/tex-to-markdown ()
    "convert clipboard contents from markdown to org and paste"
    (interactive)
    (kill-new (shell-command-to-string "osascript -e 'the clipboard as unicode text' | pandoc -f latex -t markdown --atx-headers"))
    (yank))
    
  (defun cpm/markdown-to-tex ()
    "convert clipboard contents from markdown to org and paste"
    (interactive)
    (kill-new (shell-command-to-string "osascript -e 'the clipboard as unicode text' | pandoc -f markdown -t latex"))
    (yank))

  (defun cpm/cite-to-org ()
    "convert clipboard contents from markdown to org with citations and paste"
    (interactive)
    (kill-new (shell-command-to-string "osascript -e 'the clipboard as unicode text' | pandoc --bibliography=/Users/Roambot/Dropbox/Work/Master.bib -s -t markdown-native_divs-raw_html-citations | pandoc -f markdown -t org"))
    (yank))

  (defun cpm/cite-to-markdown ()
    "convert clipboard contents to markdown with citations and paste"
    (interactive)
    (kill-new (shell-command-to-string "osascript -e 'the clipboard as unicode text' | pandoc --bibliography=/Users/Roambot/Dropbox/Work/Master.bib -s -t markdown-native_divs-raw_html-citations --atx-headers"))
    (yank))


#+END_SRC
*** Projectile Find File Other Window
Find a file in a project and open in a vertical split
#+BEGIN_SRC emacs-lisp
  (defun cpm/helm-projectile-find-file-other-window ()
   "Find a file in a project and open in a vertical split"
   (interactive)
   (cpm/split-window-right-and-focus)
   (helm-projectile-find-file))

#+END_SRC
*** Resume last search
#+BEGIN_SRC emacs-lisp
  (defun cpm/last-search-buffer ()
        "open last helm-ag or hgrep buffer."
        (interactive)
        (cond ((get-buffer "*helm ag results*")
               (switch-to-buffer-other-window "*helm ag results*"))
              ((get-buffer "*helm-ag*")
               (helm-resume "*helm-ag*"))
              ((get-buffer "*hgrep*")
               (switch-to-buffer-other-window "*hgrep*"))
              (t
               (message "No previous search buffer found"))))
#+END_SRC
*** Reveal in Finder
#+BEGIN_SRC emacs-lisp
(defun cpm/browse-file-directory ()
  "Open the current file's directory however the OS would."
  (interactive)
  (if default-directory
      (browse-url-of-file (expand-file-name default-directory))
    (error "No `default-directory' to open")))
#+END_SRC
*** Reveal to PDF
#+BEGIN_SRC emacs-lisp
  (defun cpm/reveal-to-pdf ()
  "print reveal.js slides to pdf"
  (interactive)
  (async-shell-command "phantomjs ~/bin/print-pdf.js 'file:///Users/roambot/Dropbox/Work/projects/phil105/content/slides/phil105_lecture_outline.html?print-pdf'")
  (delete-windows-on "*Async Shell Command*" t)) 
#+END_SRC
*** Rotate windows
#+BEGIN_SRC emacs-lisp
;; from magnars modified by ffevotte for dedicated windows support
(defun cpm/rotate-windows (count)
  "Rotate your windows.
Dedicated windows are left untouched. Giving a negative prefix
argument takes the kindows rotate backwards."
  (interactive "p")
  (let* ((non-dedicated-windows (remove-if 'window-dedicated-p (window-list)))
         (num-windows (length non-dedicated-windows))
         (i 0)
         (step (+ num-windows count)))
    (cond ((not (> num-windows 1))
           (message "You can't rotate a single window!"))
          (t
           (dotimes (counter (- num-windows 1))
             (let* ((next-i (% (+ step i) num-windows))

                    (w1 (elt non-dedicated-windows i))
                    (w2 (elt non-dedicated-windows next-i))

                    (b1 (window-buffer w1))
                    (b2 (window-buffer w2))

                    (s1 (window-start w1))
                    (s2 (window-start w2)))
               (set-window-buffer w1 b2)
               (set-window-buffer w2 b1)
               (set-window-start w1 s2)
               (set-window-start w2 s1)
               (setq i next-i)))))))

(defun cpm/rotate-windows-backward (count)
  "Rotate your windows backward."
  (interactive "p")
  (rotate-windows (* -1 count)))
#+END_SRC
*** Search directories with ag
#+BEGIN_SRC emacs-lisp
(defun cpm/helm-files-do-ag (&optional dir)
  "Search in files with `ag' using a default input."
    (interactive)
    (helm-do-ag dir))
        
(defun cpm/helm-files-search-current-directory ()
  "search in files with `ag' in current buffer's directory"
    (interactive)
    (helm-do-ag (file-name-directory buffer-file-name)))
#+END_SRC
*** Show Filename of Buffer
#+BEGIN_SRC emacs-lisp
  ;; http://camdez.com/blog/2013/11/14/emacs-show-buffer-file-name/
  (defun cpm/show-and-copy-buffer-filename ()
    "Show the full path to the current file in the minibuffer."
    (interactive)
    (let ((file-name (buffer-file-name)))
      (if file-name
          (progn
            (message file-name)
            (kill-new file-name))
        (error "Buffer not visiting a file"))))
#+END_SRC
*** Show Next Spelling Error
Go to the next spelling error using flyspell and ispell. From the [[https://www.emacswiki.org/emacs/FlySpell#toc3][Wiki]]. 
#+BEGIN_SRC emacs-lisp
(defun cpm/flyspell-ispell-goto-next-error ()
  "Custom function to spell check next highlighted word"
  (interactive)
  (flyspell-goto-next-error)
  (ispell-word)
  )
#+END_SRC
*** Sticky Buffer/Window
Stick/Lock buffer to window, courtesy of [[https://gist.github.com/ShingoFukuyama/8797743][ShingoFukuyama]].
#+BEGIN_SRC emacs-lisp
;; http://lists.gnu.org/archive/html/help-gnu-emacs/2007-05/msg00975.html

(defvar sticky-buffer-previous-header-line-format)
(define-minor-mode sticky-buffer-mode
  "Make the current window always display this buffer."
  nil " sticky" nil
  (if sticky-buffer-mode
      (progn
        (set (make-local-variable 'sticky-buffer-previous-header-line-format)
             header-line-format)
        (set-window-dedicated-p (selected-window) sticky-buffer-mode))
    (set-window-dedicated-p (selected-window) sticky-buffer-mode)
    (setq header-line-format sticky-buffer-previous-header-line-format)))
#+END_SRC
*** Swap windows
Swap buffers in windows and leave the cursor in the original window.
Courtesy of Mike Zamansky's [[http://cestlaz.github.io/posts/using-emacs-36-touch-of-elisp/#.WX5Wg0czpcx][video]].
#+BEGIN_SRC emacs-lisp
(defun cpm/window-exchange ()
"Swap buffer windows and leave focus in original window"
(interactive)
(ace-swap-window)
(aw-flip-window)
)
#+END_SRC 
*** Switch to previous buffer
#+BEGIN_SRC emacs-lisp
  (defun switch-to-previous-buffer ()
    (interactive)
    (switch-to-buffer (other-buffer (current-buffer) 1)))
#+END_SRC
*** Tangle file on save
#+BEGIN_SRC emacs-lisp
  (defun cpm/tangle-emacs-config ()
    "If the current file is in '~/.emacs.d/', the code blocks are tangled"
    (when (equal (file-name-directory (directory-file-name buffer-file-name))
                 (concat (getenv "HOME") "/.emacs.d/"))
      (org-babel-tangle)
      (message "%s tangled" buffer-file-name)))

  ;; (add-hook 'after-save-hook #'cpm/tangle-emacs-config)
#+END_SRC
*** Toggle Window Split
Move from a horizontal to a vertical split and vice versa
#+BEGIN_SRC emacs-lisp
(defun cpm/toggle-window-split ()
  (interactive)
  (if (= (count-windows) 2)
      (let* ((this-win-buffer (window-buffer))
         (next-win-buffer (window-buffer (next-window)))
         (this-win-edges (window-edges (selected-window)))
         (next-win-edges (window-edges (next-window)))
         (this-win-2nd (not (and (<= (car this-win-edges)
                     (car next-win-edges))
                     (<= (cadr this-win-edges)
                     (cadr next-win-edges)))))
         (splitter
          (if (= (car this-win-edges)
             (car (window-edges (next-window))))
          'split-window-horizontally
        'split-window-vertically)))
    (delete-other-windows)
    (let ((first-win (selected-window)))
      (funcall splitter)
      (if this-win-2nd (other-window 1))
      (set-window-buffer (selected-window) this-win-buffer)
      (set-window-buffer (next-window) next-win-buffer)
      (select-window first-win)
      (if this-win-2nd (other-window 1))))))

#+END_SRC
*** Search TODO Markers
Make an equivalent of vim's quickfix buffer using [[git:~/.emacs.d/config.org::master@{2018-02-18}::3795][helm-ag]] and [[git:~/.emacs.d/config.org::master@{2018-02-18}::2947][highlight-todo]]
#+BEGIN_SRC emacs-lisp
(defun cpm/search-file-todo-markers ()
    "Search for any TODO markers as specified in hl-todo-keyword-faces.

Note that this uses the word boundary \\b to avoid matching these
within other words, but this means that non-word keywords such as
???, which is in the list by default, will not be matched."
    (interactive)
    (require 'projectile)

    (let* ((grouped (funcall #'regexp-opt (--map (car it) hl-todo-keyword-faces)))
           (unescaped (s-replace-all '(("\\(" . "(") ("\\)" . ")") ("\\|" . "|"))
                                     grouped))
           (bounded (concat "\\b" unescaped "\\b"))
           (helm-follow-mode-persistent t))
      (helm-do-ag-this-file bounded)))

(defun cpm/search-todo-markers ()
    "Search for any TODO markers as specified in hl-todo-keyword-faces.

Note that this uses the word boundary \\b to avoid matching these
within other words, but this means that non-word keywords such as
???, which is in the list by default, will not be matched."
    (interactive)
    (require 'projectile)

    (let* ((grouped (funcall #'regexp-opt (--map (car it) hl-todo-keyword-faces)))
           (unescaped (s-replace-all '(("\\(" . "(") ("\\)" . ")") ("\\|" . "|"))
                                     grouped))
           (bounded (concat "\\b" unescaped "\\b"))
           (helm-follow-mode-persistent t))
      (helm-do-ag (projectile-project-root) nil bounded)))
#+END_SRC
** DOOM! Macros

A set of fantastic macros written by [[https://github.com/hlissner][hlissner]]. There won't be much
documentation around these because the comments for each macro does a great
job explaining their function. For more information you can also look at the
[[https://github.com/hlissner/doom-emacs/wiki][wiki]] and the [[https://github.com/hlissner/doom-emacs/wiki/Modules#macros][entry on macros]] in particular.
*** after!

#+BEGIN_SRC emacs-lisp
(defmacro after! (feature &rest forms)
  "A smart wrapper around `with-eval-after-load'. Supresses warnings during
compilation."
  (declare (indent defun) (debug t))
  `(,(if (or (not (bound-and-true-p byte-compile-current-file))
             (if (symbolp feature)
                 (require feature nil :no-error)
               (load feature :no-message :no-error)))
         #'progn
       #'with-no-warnings)
    (with-eval-after-load ',feature ,@forms)))
#+END_SRC
*** map!

 #+BEGIN_SRC emacs-lisp
 (eval-and-compile
   (defun cmacs-enlist (exp)
     "Return EXP wrapped in a list, or as-is if already a list."
     (if (listp exp) exp (list exp)))

   (defun doom-unquote (exp)
     "Return EXP unquoted."
     (while (memq (car-safe exp) '(quote function))
       (setq exp (cadr exp)))
     exp)

   (defvar cmacs-evil-state-alist
     '((?n . normal)
       (?v . visual)
       (?i . insert)
       (?e . emacs)
       (?o . operator)
       (?m . motion)
       (?r . replace))
     "A list of cons cells that map a letter to a evil state symbol.")

   ;; Register keywords for proper indentation (see `map!')
   (put ':after        'lisp-indent-function 'defun)
   (put ':desc         'lisp-indent-function 'defun)
   (put ':leader       'lisp-indent-function 'defun)
   (put ':local        'lisp-indent-function 'defun)
   (put ':localleader  'lisp-indent-function 'defun)
   (put ':map          'lisp-indent-function 'defun)
   (put ':map*         'lisp-indent-function 'defun)
   (put ':mode         'lisp-indent-function 'defun)
   (put ':prefix       'lisp-indent-function 'defun)
   (put ':textobj      'lisp-indent-function 'defun)
   (put ':unless       'lisp-indent-function 'defun)
   (put ':when         'lisp-indent-function 'defun)

 ;; specials
   (defvar cmacs--keymaps nil)
   (defvar cmacs--prefix  nil)
   (defvar cmacs--defer   nil)
   (defvar cmacs--local   nil)

 (defun cmacs--keybind-register (key desc &optional modes)
   "Register a description for KEY with `which-key' in MODES.

   KEYS should be a string in kbd format.
   DESC should be a string describing what KEY does.
   MODES should be a list of major mode symbols."
   (if modes
       (dolist (mode modes)
         (which-key-add-major-mode-key-based-replacements mode key desc))
     (which-key-add-key-based-replacements key desc)))

 (defun cmacs--keyword-to-states (keyword)
   "Convert a KEYWORD into a list of evil state symbols.

 For example, :nvi will map to (list 'normal 'visual 'insert). See
 `cmacs-evil-state-alist' to customize this."
   (cl-loop for l across (substring (symbol-name keyword) 1)
            if (cdr (assq l cmacs-evil-state-alist))
              collect it
            else
              do (error "not a valid state: %s" l)))

 (defmacro map! (&rest rest)
   "A nightmare of a key-binding macro that will use `evil-define-key*',
 `define-key', `local-set-key' and `global-set-key' depending on context and
 plist key flags (and whether evil is loaded or not). It was designed to make
 binding multiple keys more concise, like in vim.

 If evil isn't loaded, it will ignore evil-specific bindings.

 States
     :n  normal
     :v  visual
     :i  insert
     :e  emacs
     :o  operator
     :m  motion
     :r  replace

     These can be combined (order doesn't matter), e.g. :nvi will apply to
     normal, visual and insert mode. The state resets after the following
     key=>def pair.

     If states are omitted the keybind will be global.

     This can be customized with `cmacs-evil-state-alist'.

     :textobj is a special state that takes a key and two commands, one for the
     inner binding, another for the outer.

 Flags
     (:mode [MODE(s)] [...])    inner keybinds are applied to major MODE(s)
     (:map [KEYMAP(s)] [...])   inner keybinds are applied to KEYMAP(S)
     (:map* [KEYMAP(s)] [...])  same as :map, but deferred
     (:prefix [PREFIX] [...])   assign prefix to all inner keybindings
     (:after [FEATURE] [...])   apply keybinds when [FEATURE] loads
     (:local [...])             make bindings buffer local; incompatible with keymaps!

 Conditional keybinds
     (:when [CONDITION] [...])
     (:unless [CONDITION] [...])

 Example
     (map! :map magit-mode-map
           :m \"C-r\" 'do-something           ; assign C-r in motion state
           :nv \"q\" 'magit-mode-quit-window  ; assign to 'q' in normal and visual states
           \"C-x C-r\" 'a-global-keybind

           (:when IS-MAC
            :n \"M-s\" 'some-fn
            :i \"M-o\" (lambda (interactive) (message \"Hi\"))))"
   (let ((cmacs--keymaps cmacs--keymaps)
         (cmacs--prefix  cmacs--prefix)
         (cmacs--defer   cmacs--defer)
         (cmacs--local   cmacs--local)
         key def states forms desc modes)
     (while rest
       (setq key (pop rest))
       (cond
	;; it's a sub expr
	((listp key)
         (push (macroexpand `(map! ,@key)) forms))

	;; it's a flag
	((keywordp key)
         (cond ((eq key :leader)
		(push 'cmacs-leader-key rest)
		(setq key :prefix
                      desc "<leader>"))
               ((eq key :localleader)
		(push 'cmacs-localleader-key rest)
		(setq key :prefix
                      desc "<localleader>")))
         (pcase key
           (:when    (push `(if ,(pop rest)       ,(macroexpand `(map! ,@rest))) forms) (setq rest '()))
           (:unless  (push `(if (not ,(pop rest)) ,(macroexpand `(map! ,@rest))) forms) (setq rest '()))
           (:after   (push `(after! ,(pop rest)   ,(macroexpand `(map! ,@rest))) forms) (setq rest '()))
           (:desc    (setq desc (pop rest)))
           (:map*    (setq cmacs--defer t) (push :map rest))
           (:map
             (setq cmacs--keymaps (cmacs-enlist (pop rest))))
           (:mode
             (setq modes (cmacs-enlist (pop rest)))
             (unless cmacs--keymaps
               (setq cmacs--keymaps
                     (cl-loop for m in modes
                              collect (intern (format "%s-map" (symbol-name m)))))))
           (:textobj
             (let* ((key (pop rest))
                    (inner (pop rest))
                    (outer (pop rest)))
               (push (macroexpand `(map! (:map evil-inner-text-objects-map ,key ,inner)
                                         (:map evil-outer-text-objects-map ,key ,outer)))
                     forms)))
           (:prefix
             (let ((def (pop rest)))
               (setq cmacs--prefix `(vconcat ,cmacs--prefix (kbd ,def)))
               (when desc
                 (push `(cmacs--keybind-register ,(key-description (eval cmacs--prefix))
                                                 ,desc ',modes)
                       forms)
                 (setq desc nil))))
           (:local
            (setq cmacs--local t))
           (_ ; might be a state cmacs--prefix
            (setq states (cmacs--keyword-to-states key)))))

	;; It's a key-def pair
	((or (stringp key)
             (characterp key)
             (vectorp key)
             (symbolp key))
         (unwind-protect
             (catch 'skip
               (when (symbolp key)
                 (setq key `(kbd ,key)))
               (when (stringp key)
                 (setq key (kbd key)))
               (when cmacs--prefix
                 (setq key (append cmacs--prefix (list key))))
               (unless (> (length rest) 0)
                 (user-error "map! has no definition for %s key" key))
               (setq def (pop rest))
               (when desc
                 (push `(cmacs--keybind-register ,(key-description (eval key))
                                               ,desc ',modes)
                       forms))
               (cond ((and cmacs--local cmacs--keymaps)
                      (push `(lwarn 'cmacs-map :warning
                                    "Can't local bind '%s' key to a keymap; skipped"
                                    ,key)
                            forms)
                      (throw 'skip 'local))
                     ((and cmacs--keymaps states)
                      (dolist (keymap cmacs--keymaps)
			(push `(,(if cmacs--defer 'evil-define-key 'evil-define-key*)
				',states ,keymap ,key ,def)
                              forms)))
                     (states
                      (dolist (state states)
			(push `(define-key
                                 ,(intern (format "evil-%s-state-%smap" state (if cmacs--local "local-" "")))
                                 ,key ,def)
                              forms)))
                     (cmacs--keymaps
                      (dolist (keymap cmacs--keymaps)
			(push `(define-key ,keymap ,key ,def) forms)))
                     (t
                      (push `(,(if cmacs--local 'local-set-key 'global-set-key) ,key ,def)
                            forms))))
           (setq states '()
                 cmacs--local nil
                 desc nil)))

	(t (user-error "Invalid key %s" key))))
     `(progn ,@(nreverse forms)))))
 #+END_SRC
*** add-hook!
 A macro that makes adding hooks easy

 #+BEGIN_SRC emacs-lisp
 (eval-and-compile
   (defun cmacs--resolve-hook-forms (hooks)
     (cl-loop with quoted-p = (eq (car-safe hooks) 'quote)
              for hook in (cmacs-enlist (doom-unquote hooks))
              if (eq (car-safe hook) 'quote)
               collect (cadr hook)
              else if quoted-p
               collect hook
              else collect (intern (format "%s-hook" (symbol-name hook)))))

   (defvar cmacs--transient-counter 0)
   (defmacro add-transient-hook! (hook &rest forms)
     "Attaches transient forms to a HOOK.

   HOOK can be a quoted hook or a sharp-quoted function (which will be advised).

   These forms will be evaluated once when that function/hook is first invoked,
   then it detaches itself."
     (declare (indent 1))
     (let ((append (eq (car forms) :after))
           (fn (intern (format "cmacs-transient-hook-%s" (cl-incf cmacs--transient-counter)))))
       `(when ,hook
          (fset ',fn
		(lambda (&rest _)
                  ,@forms
                  (cond ((functionp ,hook) (advice-remove ,hook #',fn))
			((symbolp ,hook)   (remove-hook ,hook #',fn)))
                  (unintern ',fn nil)))
          (cond ((functionp ,hook)
                 (advice-add ,hook ,(if append :after :before) #',fn))
		((symbolp ,hook)
                 (add-hook ,hook #',fn ,append)))))))

 (defmacro add-hook! (&rest args)
   "A convenience macro for `add-hook'. Takes, in order:

   1. Optional properties :local and/or :append, which will make the hook
      buffer-local or append to the list of hooks (respectively),
   2. The hooks: either an unquoted major mode, an unquoted list of major-modes,
      a quoted hook variable or a quoted list of hook variables. If unquoted, the
      hooks will be resolved by appending -hook to each symbol.
   3. A function, list of functions, or body forms to be wrapped in a lambda.

 Examples:
     (add-hook! 'some-mode-hook 'enable-something)
     (add-hook! some-mode '(enable-something and-another))
     (add-hook! '(one-mode-hook second-mode-hook) 'enable-something)
     (add-hook! (one-mode second-mode) 'enable-something)
     (add-hook! :append (one-mode second-mode) 'enable-something)
     (add-hook! :local (one-mode second-mode) 'enable-something)
     (add-hook! (one-mode second-mode) (setq v 5) (setq a 2))
     (add-hook! :append :local (one-mode second-mode) (setq v 5) (setq a 2))

 Body forms can access the hook's arguments through the let-bound variable
 `args'."
   (declare (indent defun) (debug t))
   (let ((hook-fn 'add-hook)
         append-p local-p)
     (while (keywordp (car args))
       (pcase (pop args)
         (:append (setq append-p t))
         (:local  (setq local-p t))
         (:remove (setq hook-fn 'remove-hook))))
     (let ((hooks (cmacs--resolve-hook-forms (pop args)))
           (funcs
            (let ((val (car args)))
              (if (memq (car-safe val) '(quote function))
                  (if (cdr-safe (cadr val))
                      (cadr val)
                    (list (cadr val)))
		(list args))))
           forms)
       (dolist (fn funcs)
         (setq fn (if (symbolp fn)
                      `(function ,fn)
                    `(lambda (&rest _) ,@args)))
         (dolist (hook hooks)
           (push (cond ((eq hook-fn 'remove-hook)
			`(remove-hook ',hook ,fn ,local-p))
                       (t
			`(add-hook ',hook ,fn ,append-p ,local-p)))
                 forms)))
       `(progn ,@(nreverse forms)))))

 (defmacro remove-hook! (&rest args)
   "Convenience macro for `remove-hook'. Takes the same arguments as
 `add-hook!'."
   `(add-hook! :remove ,@args))
 #+END_SRC
*** quiet!
 A simple macro that prevents code from making any noise

 #+BEGIN_SRC emacs-lisp
 (defmacro quiet! (&rest forms)
   "Run FORMS without making any noise."
   `(if nil
	(progn ,@forms)
      (fset 'doom--old-write-region-fn (symbol-function 'write-region))
      (cl-letf ((standard-output (lambda (&rest _)))
		((symbol-function 'load-file) (lambda (file) (load file nil t)))
		((symbol-function 'message) (lambda (&rest _)))
		((symbol-function 'write-region)
                 (lambda (start end filename &optional append visit lockname mustbenew)
                   (unless visit (setq visit 'no-message))
                   (doom--old-write-region-fn
                    start end filename append visit lockname mustbenew)))
		(inhibit-message t)
		(save-silently t))
	,@forms)))
 #+END_SRC
*** def-memoized!
 Creates a memoized function

 #+BEGIN_SRC emacs-lisp
 (defvar doom-memoized-table (make-hash-table :test 'equal :size 10)
   "A lookup table containing memoized functions. The keys are argument lists,
 and the value is the function's return value.")

 (defun doom-memoize (name)
   "Memoizes an existing function. NAME is a symbol."
   (let ((func (symbol-function name)))
     (put name 'function-documentation
          (concat (documentation func) " (memoized)"))
     (fset name
           `(lambda (&rest args)
              (let ((key (cons ',name args)))
		(or (gethash key doom-memoized-table)
                    (puthash key (apply ',func args)
                             doom-memoized-table)))))))

 (defmacro def-memoized! (name arglist &rest body)
   "Create a memoize'd function. NAME, ARGLIST, DOCSTRING and BODY
 have the same meaning as in `defun'."
   (declare (indent defun) (doc-string 3))
   `(,(if (bound-and-true-p byte-compile-current-file)
          'with-no-warnings
	'progn)
      (defun ,name ,arglist ,@body)
      (doom-memoize ',name)))


 #+END_SRC
*** λ!

 #+BEGIN_SRC emacs-lisp
 (defmacro λ! (&rest body)
   "A shortcut for inline interactive lambdas."
   (declare (doc-string 1))
   `(lambda () (interactive) ,@body))

 #+END_SRC

** Other Macros
#+BEGIN_SRC emacs-lisp

(defmacro find-file-in! (path &optional project-p)
  "Returns a interactive function for searching files"
  `(lambda () (interactive)
     (let ((default-directory ,path))
       (call-interactively
        ',(if project-p
              (command-remapping 'projectile-find-file)
            (command-remapping 'find-file))))))
#+END_SRC
* Emacs Settings
** System Defaults
Let's use sane defaults. Sources for this section include [[https://github.com/magnars/.emacs.d/blob/master/settings/sane-defaults.el][Magnars Sveen]] and [[http://pages.sachachua.com/.emacs.d/Sacha.html][Sacha Chua]].
*** Apropos Everything
apropos commands perform more extensive searches than default
#+BEGIN_SRC emacs-lisp
(setq apropos-do-all t)
#+END_SRC
*** Clipboard
#+BEGIN_SRC emacs-lisp
; Merge system's and Emacs' clipboard
(setq select-enable-clipboard t)
;; Save whatever’s in the current (system) clipboard before
;; replacing it with the Emacs’ text.
(setq save-interprogram-paste-before-kill t)
;; Copy/Paste functions 
;; https://github.com/dakrone/eos/blob/master/eos-core.org#mac-osx
(defun copy-from-osx ()
    "Handle copy/paste intelligently on osx."
    (let ((pbpaste (purecopy "/usr/bin/pbpaste")))
      (if (and (eq system-type 'darwin)
               (file-exists-p pbpaste))
          (let ((tramp-mode nil)
                (default-directory "~"))
            (shell-command-to-string pbpaste)))))

  (defun paste-to-osx (text &optional push)
    (let ((process-connection-type nil))
      (let ((proc (start-process "pbcopy" "*Messages*" "/usr/bin/pbcopy")))
        (process-send-string proc text)
        (process-send-eof proc))))
  (setq interprogram-cut-function 'paste-to-osx
        interprogram-paste-function 'copy-from-osx)
#+END_SRC
*** Cursor Movement
Per [[https://emacs.stackexchange.com/a/28746/11934][this]] post on stack overflow
#+BEGIN_SRC emacs-lisp
(setq auto-window-vscroll nil)
#+END_SRC
*** Dired settings
#+BEGIN_SRC emacs-lisp
(use-package dired
  :ensure nil
  :commands (dired dired-jump dired-jump-other-window)
  :config
  (setq insert-directory-program "gls" dired-use-ls-dired t)
  (setq diredp-toggle-find-file-reuse-dir 1)
  ;; list directories first
  ;; (setq dired-listing-switches "-al --group-directories-first")
  (setq dired-listing-switches "-laGh1v --group-directories-first")
  ;; stop asking about recurisve actions
  (setq dired-recursive-copies 'always)
  (setq dired-recursive-deletes 'always))
#+END_SRC
*** Dired Copy Large Files & Directories
Lets you copy huge files and directories without Emacs freezing up and
with convenient progress bar updates. Courtesy of [[https://oremacs.com/2016/02/24/dired-rsync/][Or Emacs]]. 
#+BEGIN_SRC emacs-lisp
;;;###autoload
(defun ora-dired-rsync (dest)
  (interactive
   (list
    (expand-file-name
     (read-file-name
      "Rsync to:"
      (dired-dwim-target-directory)))))
  ;; store all selected files into "files" list
  (let ((files (dired-get-marked-files
                nil current-prefix-arg))
        ;; the rsync command
        (tmtxt/rsync-command
         "rsync -arvz --progress "))
    ;; add all selected file names as arguments
    ;; to the rsync command
    (dolist (file files)
      (setq tmtxt/rsync-command
            (concat tmtxt/rsync-command
                    (shell-quote-argument file)
                    " ")))
    ;; append the destination
    (setq tmtxt/rsync-command
          (concat tmtxt/rsync-command
                  (shell-quote-argument dest)))
    ;; run the async shell command
    (async-shell-command tmtxt/rsync-command "*rsync*")
    ;; finally, switch to that window
    (other-window 1)))


#+END_SRC
*** Disable Welcome Screen

#+BEGIN_SRC emacs-lisp
; Disable start-up screen
(setq-default inhibit-startup-screen t)                         
(setq inhibit-splash-screen t)
(setq inhibit-startup-message t)
(setq initial-scratch-message "")
;; And bury the scratch buffer, don't kill it
(defadvice kill-buffer (around kill-buffer-around-advice activate)
  (let ((buffer-to-kill (ad-get-arg 0)))
    (if (equal buffer-to-kill "*scratch*")
        (bury-buffer)
      ad-do-it)))
#+END_SRC
*** Environment Path
Make sure emacs correctly sets up your PATH.
#+BEGIN_SRC emacs-lisp
  (defvar cpm-local-bin (concat (getenv "HOME") "/bin") "Local execs.")
  (defvar usr-local-bin "/usr/local/bin")
  (defvar usr-local-sbin "/usr/local/sbin")
  (setenv "PATH" (concat usr-local-bin ":" usr-local-sbin ":" (getenv "PATH") ":" cpm-local-bin))
  (setq exec-path (append exec-path (list cpm-local-bin usr-local-sbin usr-local-bin)))
#+END_SRC 
*** File Endings
Make all files [[http://stackoverflow.com/questions/729692/why-should-text-files-end-with-a-newline][POSIX compliant for newlines]]
#+BEGIN_SRC emacs-lisp
;; Make sure your text files end in a newline
(setq require-final-newline t)
#+END_SRC
*** Give buffers unique names
#+BEGIN_SRC emacs-lisp
  (setq uniquify-buffer-name-style 'forward)
#+END_SRC
*** Help Buffers
#+BEGIN_SRC emacs-lisp
;; Keep focus while navigating help buffers
(setq help-window-select 't)
#+END_SRC
*** Large Files
Warn only for files over 100MB
#+BEGIN_SRC emacs-lisp
(setq large-file-warning-threshold 100000000)
#+END_SRC
*** Paragraphs
From the [[https://www.emacswiki.org/emacs/FillParagraph][Emacs Wiki]] on fill paragraph.
#+BEGIN_SRC emacs-lisp
;; The original value is "\f\\|[      ]*$", so we add the bullets (-), (+), and (*).
    ;; There is no need for "^" as the regexp is matched at the beginning of line.
    (setq paragraph-start "\f\\|[ \t]*$\\|[ \t]*[-+*] ")
#+END_SRC
*** Pretty symbols
#+BEGIN_SRC emacs-lisp
(setq prettify-symbols-unprettify-at-point t)
(global-prettify-symbols-mode +1)
#+END_SRC
*** Startup Message
#+BEGIN_SRC emacs-lisp
  ;; Change the echo message
(defun display-startup-echo-area-message ()
  (message ""))
#+END_SRC
*** Start scratch in fundamental mode 
Useful to get a faster Emacs load time because it avoids autoloads of
elisp modes or other minor modes
#+BEGIN_SRC emacs-lisp
  (setq initial-major-mode 'fundamental-mode)
#+END_SRC
*** Text Settings
General Text settings and hooks
**** Sentence endings
#+BEGIN_SRC emacs-lisp
;; Single space between sentences is more widespread than double
(setq-default sentence-end-double-space nil)
#+END_SRC
**** Subwords and CamelCase
#+BEGIN_SRC emacs-lisp
; Iterate through CamelCase words
(global-subword-mode 1)                           
#+END_SRC
**** Only use spaces
#+BEGIN_SRC emacs-lisp
(setq-default indent-tabs-mode nil)
(setq-default tab-width 4)
(setq-default indicate-empty-lines nil)
#+END_SRC
**** Line wrap
#+BEGIN_SRC emacs-lisp
(global-visual-line-mode)
(setq line-move-visual t) ;; move via visual lines
#+END_SRC
**** Fill column
#+BEGIN_SRC emacs-lisp
(setq-default fill-column 78)
#+END_SRC
**** Visual replace
This is the [[https://github.com/benma/visual-regexp.el][good old search and replace]] as opposed to the fancy alternatives
such as [[https://github.com/victorhge/iedit][iedit]] and [[https://github.com/magnars/multiple-cursors.el][multiple cursors]]. You search for a word in the
buffer/region, type in the replacement and confirm each one by pressing =y= or =n=
or just press =!= to apply this to everything.

#+BEGIN_SRC emacs-lisp
(use-package visual-regexp
  :commands (vr/query-replace)
  :config
  (use-package visual-regexp-steroids
    :commands (vr/select-query-replace)))
#+END_SRC
**** Show Matching Brackets
Show matching brackets, parenthesis, etc.
#+BEGIN_SRC emacs-lisp
(show-paren-mode t)
(setq show-paren-delay 0) 
#+END_SRC
*** Turn off the blinking cursor
#+BEGIN_SRC emacs-lisp
(blink-cursor-mode 0)
#+END_SRC
*** UTF-8 please
#+BEGIN_SRC emacs-lisp
  (setq locale-coding-system 'utf-8) 
  (set-terminal-coding-system 'utf-8) 
  (set-keyboard-coding-system 'utf-8) 
  (set-selection-coding-system 'utf-8)
  (prefer-coding-system 'utf-8) 
#+END_SRC
*** Warnings
No bells and no visible "bell" either!
#+BEGIN_SRC emacs-lisp
  (setq visible-bell nil) ;; The default
  (setq ring-bell-function 'ignore)
  ;; Silence warnings generated by a function's being redefine by =defadvice=.
  (setq ad-redefinition-action 'accept)
#+END_SRC
*** Yes or No
#+BEGIN_SRC emacs-lisp
  (defalias 'yes-or-no-p 'y-or-n-p)
#+END_SRC

** Backups
#+BEGIN_SRC emacs-lisp
  (let ((backup-dir (concat cpm-cache-dir "backup")))
    ;; Move backup file to `~/.emacs.d/.cache/backup'
    (setq backup-directory-alist `(("." . ,backup-dir)))
    ;; Makesure backup directory exist
    (when (not (file-exists-p backup-dir))
      (make-directory backup-dir t)))

  (setq make-backup-files t               ; backup of a file the first time it is saved.
        backup-by-copying t               ; don't clobber symlinks
        version-control t                 ; version numbers for backup files
        delete-old-versions t             ; delete excess backup files silently
        delete-by-moving-to-trash t
        kept-old-versions 6               ; oldest versions to keep when a new numbered backup is made
        kept-new-versions 6               ; newest versions to keep when a new numbered backup is made
        )
  (setq vc-make-backup-files t) ;;  backup versioned files, which Emacs does not do by default


#+END_SRC
*** Backup Walker
Traverse backups with [[https://github.com/lewang/backup-walker][backup-walker]]
#+BEGIN_SRC emacs-lisp
(use-package backup-walker
  :commands backup-walker-start)
#+END_SRC
** Auto Save
I make sure Emacs auto-saves often but the result is that it messes up my file tree. So, let's ask Emacs to store its backups in the cache directory.

#+BEGIN_SRC emacs-lisp
(setq auto-save-list-file-prefix
      (concat cpm-cache-dir "auto-save-list/.saves-"))

(setq auto-save-default t               ; auto-save every buffer that visits a file
      auto-save-timeout 20              ; number of seconds idle time before auto-save (default: 30)
      auto-save-interval 200            ; number of keystrokes between auto-saves (default: 300)
      auto-save-visited-file-name nil
      delete-auto-save-files t
      create-lockfiles nil)
#+END_SRC
*** Full Auto Save
I also make emacs just outright save all buffers. 
#+BEGIN_SRC emacs-lisp
  (defun full-auto-save ()
    (interactive)
    (save-excursion
      (dolist (buf (buffer-list))
        (set-buffer buf)
        (if (and (buffer-file-name) (buffer-modified-p))
            (basic-save-buffer)))))
  (add-hook 'auto-save-hook 'full-auto-save)
#+END_SRC
** Custom file 
Set up the customize file to its own [[file:$HOME/.emacs.d/custom.el][separate file]], instead of saving
customize settings in [[file:init.el][init.el]].

#+begin_src emacs-lisp
(setq custom-file (expand-file-name "custom.el" user-emacs-directory))
(when (file-exists-p custom-file)
  (load custom-file))
#+end_src
** Desktop save
Save your frame/window/buffer config
#+BEGIN_SRC emacs-lisp
  (setq desktop-dirname             (concat cpm-cache-dir "desktops")
        desktop-base-file-name      "emacs.desktop"
        desktop-base-lock-name      "lock"
        desktop-path                (list desktop-dirname)
        desktop-save                'ask-if-new
        desktop-files-not-to-save   (concat "^$" ".*magit$")
        desktop-restore-eager 4
        desktop-load-locked-desktop t)

  (when (not (file-exists-p desktop-dirname))
  (make-directory desktop-dirname t))
  
  (setq desktop-buffers-not-to-save
          (concat "\\("
                  "^nn\\.a[0-9]+\\|\\.log\\|(ftp)\\|^tags\\|^TAGS"
                  "\\|\\.emacs.*\\|\\.diary\\|\\.newsrc-dribble\\|\\.bbdb"
	          "\\)$"))

  (desktop-save-mode 0)

  (defun cpm/my-desktop ()
    "Load the desktop and enable autosaving"
    (interactive)
    (let ((desktop-load-locked-desktop "ask"))
      (desktop-read)
      (desktop-save-mode 1)))

  (defun cpm/save-desktop-save-buffers-kill-emacs ()
    "Save buffers and current desktop every time when quitting emacs."
    (interactive)
    (desktop-save-in-desktop-dir)
    (save-buffers-kill-emacs))
#+END_SRC
** Mac/OSX
There is some configuration to do when running Emacs on OS X (hence the
"darwin" system-type check).

First we can define some general system checks
#+BEGIN_SRC emacs-lisp
(setq IS-LINUX (eq system-type 'gnu/linux)
      IS-MAC (eq system-type 'darwin))
#+END_SRC


#+begin_src emacs-lisp
    (when IS-MAC
      ;; make fonts look better with anti-aliasing
      (setq mac-allow-anti-aliasing t)
      ;; delete files by moving them to the trash
      (setq delete-by-moving-to-trash t)
      (setq trash-directory "~/.Trash")

      ;; Don't make new frames when opening a new file with Emacs
      (setq ns-pop-up-frames nil)

      ;; fullscreen (disable for non-space full screen)
      (setq ns-use-native-fullscreen t)

      ;; disable emacs-mac smooth scrolling because it is seriously janky
      (setq mac-mouse-wheel-smooth-scroll nil)

      ;; Set modifier keys
      (setq mac-option-modifier 'meta) ;; Bind meta to ALT
      (setq mac-command-modifier 'super) ;; Bind apple/command to super if you want
      (setq mac-function-modifier 'hyper) ;; Bind function key to hyper if you want 
      (setq mac-right-option-modifier 'none) ;; unbind right key for accented input

      ;; Make forward delete work 
      (global-set-key (kbd "<H-backspace>") 'delete-forward-char)

      ;; Keybindings
      (global-set-key (kbd "s-q") 'save-buffers-kill-terminal)
      (global-set-key (kbd "s-v") 'yank)
      (global-set-key (kbd "s-c") 'evil-yank)
      (global-set-key (kbd "s-a") 'mark-whole-buffer)
      (global-set-key (kbd "s-x") 'kill-region)
      (global-set-key (kbd "s-w") 'delete-window)
      (global-set-key (kbd "s-W") 'delete-frame)
      (global-set-key (kbd "s-n") 'make-frame)
      (global-set-key (kbd "s-N") 'nameframe-create-frame)
      (global-set-key (kbd "s-z") 'undo-tree-undo)
      (global-set-key (kbd "s-s")
                      (lambda ()
                        (interactive)
                        (call-interactively (key-binding "\C-x\C-s"))))
      (global-set-key (kbd "s-Z") 'undo-tree-redo)
      (global-set-key (kbd "C-s-f") 'toggle-frame-fullscreen)
      ;; Emacs sometimes registers C-s-f as this weird keycode
      (global-set-key (kbd "<C-s-268632070>") 'toggle-frame-fullscreen)
  )

      (defun open-dir-in-iterm ()
        "Open the current directory of the buffer in iTerm."
        (interactive)
        (let* ((iterm-app-path "/Applications/iTerm.app")
               (iterm-brew-path "/opt/homebrew-cask/Caskroom/iterm2/2.1.4/iTerm.app")
               (iterm-path (if (file-directory-p iterm-app-path)
                               iterm-app-path
                             iterm-brew-path)))
          (shell-command (concat "open -a " iterm-path " ."))))
          (global-set-key (kbd "C-x t") 'open-dir-in-iterm)

      ;; Not going to use these commands
      (put 'ns-print-buffer 'disabled t)
      (put 'suspend-frame 'disabled t)

      ;; -- This is for TextExpander
      ;; (setq ns-alternate-modifier 'alt)
      ;; (define-key global-map [(alt ?v)] 'scroll-down)
      ;; (define-key global-map [(meta ?v)] 'yank)
#+end_src
** Time and Date Stamps
*** Emacs buffer timestamp settings
#+BEGIN_SRC emacs-lisp
  (setq 
    time-stamp-active t          ; do enable time-stamps
    time-stamp-line-limit 10     ; check first 10 buffer lines for Time-stamp: 
    time-stamp-format "Last modified on %02m-%02d-%04y %02H:%02M:%02S (%U)") ; date format
  (add-hook 'write-file-hooks 'time-stamp) ; update when saving
#+END_SRC
*** Insert time or date
The code below sets the correct value for system-time-locale, and binds
keys for insert-date/long and insert-date/short. Courtesy of [[https://ebzzry.github.io/emacs-hacks-2.html#desktop][emacs-hacks]].
#+BEGIN_SRC emacs-lisp
  (defun format-date (format)
  (let ((system-time-locale "en_US.UTF-8"))
    (insert (format-time-string format))))

(defun insert-date ()
  (interactive)
  (format-date "%A, %B %d %Y"))

(defun insert-date-and-time ()
  (interactive)
  (format-date "%m-%d-%Y %H:%M:%S"))
#+END_SRC
** Location
(I only need this if I'm using [[https://github.com/guidoschmidt/circadian.el][circadian]], which I'm not)
Make Emacs watch and respond to changes in [[https://github.com/purcell/osx-location][geographical location]] on OS X
#+BEGIN_SRC emacs-lisp
(use-package osx-location
  :if (eq system-type 'darwin)
  :defer 10
  :commands osx-location-watch
  :config
  (osx-location-watch)
  (add-hook 'osx-location-changed-hook
               (lambda ()
                 (setq calendar-latitude osx-location-latitude
                       calendar-longitude osx-location-longitude
                       calendar-location-name (format "%s, %s" osx-location-latitude osx-location-longitude)))))
#+END_SRC


* Core Packages
** Modal Editing
*** General  (Evil)
A [[https://github.com/noctuid/general.el][convenient way]] to bind keys. Compatible with evil. For helpful
discussion of setting up evil with general see [[https://sam217pa.github.io/2016/09/02/how-to-build-your-own-spacemacs/][this post]].
#+BEGIN_SRC emacs-lisp
  (use-package general
    :demand t
    :config
    (general-override-mode)
    )
#+END_SRC

*** Vim Emulation
I'm coming from vim, and want modal keybidings in emacs. There are other, less
radical ways of getting modal editing in emacs. For example, [[https://github.com/mrkkrp/modalka][modalka]] is a nice
package for modal editing (see also [[https://github.com/Kungsgeten/ryo-modal][ryo-modal]]). But nothing beats full vim
keybindings. And that is what [[https://bitbucket.org/lyro/evil/wiki/Home][evil]] is for.
Install, automatically load, and enable evil. It's like vim, but better!
**** Evil Mode
#+BEGIN_SRC emacs-lisp
  (use-package evil
    :demand t
    :config
    (progn
    ;; Cursor shape and color
      (defcustom dotemacs-evil/emacs-cursor
      "red"
      "The color of the cursor when in Emacs state."
      :type 'color
      :group 'dotemacs-evil)

      (defcustom dotemacs-evil/emacs-insert-mode
      nil
      "If non-nil, insert mode will act as Emacs state."
      :type 'boolean
      :group 'dotemacs-evil)

      ;; move over visual lines like normal lines
      (general-define-key :states '(motion normal)
             "j"   #'evil-next-visual-line
             "k"   #'evil-previous-visual-line)

      (setq evil-search-module 'evil-search)
      (setq evil-magic 'very-magic)
      ;; (setq evil-want-C-i-jump nil)
      (setq evil-emacs-state-cursor `(,dotemacs-evil/emacs-cursor box))
      (setq evil-normal-state-cursor '("DarkGoldenrod2" box))
      (setq evil-visual-state-cursor '("gray" box)) 
      (setq evil-insert-state-cursor '("chartreuse3" (bar . 2)))
      (setq evil-replace-state-cursor '("red" hbar))
      (setq evil-operator-state-cursor '("red" hollow))
      (setq evil-visual-state-tag "VISUAL")
      ;use insert in commits automatically 
      (add-hook 'git-commit-mode-hook 'evil-insert-state)
      (evil-set-initial-state 'messages-buffer-mode 'normal)
      (evil-set-initial-state 'magit-log-edit-mode 'insert)
      ;; evil-normal-state is preferred, so revert when idle
      ;; (run-with-idle-timer 60 t 'evil-normal-state)
      ;; don't echo evil state
      (setq evil-echo-state nil)
      ;; evil everywhere
      (evil-mode 1)))
#+END_SRC
**** Evil Related Packages & Settings
There are some other useful setup packages for evil
***** Evil indent
#+BEGIN_SRC emacs-lisp
(use-package evil-indent-textobject :commands (evil-indent))
#+END_SRC
***** Change Cursor In Terminal
#+begin_src emacs-lisp
(defun my-send-string-to-terminal (string)
  (unless (display-graphic-p) (send-string-to-terminal string)))

(defun my-evil-terminal-cursor-change ()
  (when (string= (getenv "TERM_PROGRAM") "iTerm.app")
    (add-hook 'evil-insert-state-entry-hook (lambda () (my-send-string-to-terminal "\e]50;CursorShape=1\x7")))
    (add-hook 'evil-insert-state-exit-hook  (lambda () (my-send-string-to-terminal "\e]50;CursorShape=0\x7"))))
  (when (and (getenv "TMUX") (string= (getenv "TERM_PROGRAM") "iTerm.app"))
    (add-hook 'evil-insert-state-entry-hook (lambda () (my-send-string-to-terminal "\ePtmux;\e\e]50;CursorShape=1\x7\e\\")))
    (add-hook 'evil-insert-state-exit-hook  (lambda () (my-send-string-to-terminal "\ePtmux;\e\e]50;CursorShape=0\x7\e\\")))))

(add-hook 'after-make-frame-functions (lambda (frame) (my-evil-terminal-cursor-change)))
(my-evil-terminal-cursor-change)
#+end_src
***** Evil Surround Commands Like Vim-Surround
#+begin_src emacs-lisp
  (use-package evil-surround
    :commands (evil-surround-region evil-surround-change evil-surround-delete)
    :hook ((LaTeX-mode org-mode markdown-mode prog-mode) . evil-surround-mode)
    :general
    (:states '(visual)
    "s" 'evil-surround-region
    "S" 'evil-substitute)
    ;; :config (global-evil-surround-mode 1)
    )

  (use-package embrace 
    :after evil-surround
    :demand t
    :hook ((LaTeX-mode . embrace-LaTeX-mode-hook)
           (org-mode-hook . embrace-org-mode-hook)
           (markdown-mode . embrace-markdown-mode-hook)))
           
  (use-package evil-embrace
   :after evil-surround
   :demand t
   :config
   (setq evil-embrace-show-help-p nil)
   (evil-embrace-enable-evil-surround-integration)
   (defun embrace-markdown-mode-hook ()
   (dolist (lst '((?* "*" . "*")  
                  (?\ "\\" . "\\")
                  (?$ "$" . "$")
                  (?/ "/" . "/")))
    (embrace-add-pair (car lst) (cadr lst) (cddr lst))))
    )
#+end_src 

***** Commenting 
#+begin_src emacs-lisp
  (use-package evil-commentary
    :commands (evil-commentary evil-commentary-line)
    ;; :diminish evil-commentary-mode
    :config
    (evil-commentary-mode))
#+end_src
***** Graphical undo
#+begin_src emacs-lisp
  (use-package undo-tree
    :commands (undo-tree-undo undo-tree-redo undo-tree-visualize)
    :init
    ;; (global-undo-tree-mode)
    (setq undo-tree-visualizer-timestamps t)
    (setq undo-tree-visualizer-diff t)
    ;; supposedly causes errors in undo read
    ;; see https://emacs.stackexchange.com/a/34214/11934
    (setq undo-tree-enable-undo-in-region nil)
    ;; stop littering - set undo directory 
    (let ((undo-dir (concat cpm-cache-dir "undo")))
      (setq undo-tree-history-directory-alist `(("." . ,undo-dir)))
      (unless (file-directory-p undo-dir)
        (make-directory undo-dir t)))
    (setq undo-tree-auto-save-history nil))
#+end_src
***** Evil Multiedit
A version of multiple cursors for use with evil. Courtesy of [[https://github.com/hlissner/evil-multiedit][hlissner]]. 
#+BEGIN_SRC emacs-lisp
(use-package evil-multiedit
 :ensure t
 :after evil-visualstar
 :demand t
 :config
 ;; Default keybindings
 ;; Highlights all matches of the selection in the buffer.
(define-key evil-visual-state-map "R" 'evil-multiedit-match-all)

;; Match the word under cursor (i.e. make it an edit region). Consecutive presses will
;; incrementally add the next unmatched match.
(define-key evil-normal-state-map (kbd "M-d") 'evil-multiedit-match-and-next)
;; Match selected region.
(define-key evil-visual-state-map (kbd "M-d") 'evil-multiedit-and-next)
;; Insert marker at point
(define-key evil-insert-state-map (kbd "M-d") 'evil-multiedit-toggle-marker-here)

;; Same as M-d but in reverse.
(define-key evil-normal-state-map (kbd "M-D") 'evil-multiedit-match-and-prev)
(define-key evil-visual-state-map (kbd "M-D") 'evil-multiedit-and-prev)

;; OPTIONAL: If you prefer to grab symbols rather than words, use
;; `evil-multiedit-match-symbol-and-next` (or prev).

;; Restore the last group of multiedit regions.
(define-key evil-visual-state-map (kbd "C-M-D") 'evil-multiedit-restore)

;; RET will toggle the region under the cursor
(define-key evil-multiedit-state-map (kbd "RET") 'evil-multiedit-toggle-or-restrict-region)

;; ...and in visual mode, RET will disable all fields outside the selected region
(define-key evil-motion-state-map (kbd "RET") 'evil-multiedit-toggle-or-restrict-region)

;; For moving between edit regions
(define-key evil-multiedit-state-map (kbd "C-n") 'evil-multiedit-next)
(define-key evil-multiedit-state-map (kbd "C-p") 'evil-multiedit-prev)
(define-key evil-multiedit-insert-state-map (kbd "C-n") 'evil-multiedit-next)
(define-key evil-multiedit-insert-state-map (kbd "C-p") 'evil-multiedit-prev)

;; Ex command that allows you to invoke evil-multiedit with a regular expression, e.g.
(evil-ex-define-cmd "ie[dit]" 'evil-multiedit-ex-match)
)
#+END_SRC
***** Evil Multiple Cursors
[[https://github.com/gabesoft/evil-mc][Multiple cursors]] implementation for evil-mode
#+BEGIN_SRC emacs-lisp
  (use-package evil-mc
    :ensure t
    :commands (evil-mc-make-all-cursors evil-mc-make-and-goto-next-match))
#+END_SRC
***** Evil Numbers
Increment an decrement numbers 
#+BEGIN_SRC emacs-lisp
  (use-package evil-numbers
    :commands (evil-numbers/inc-at-pt evil-numbers/dec-at-pt)
    :init
    (general-define-key
      :states '(normal visual insert emacs)
      "H-s" 'evil-numbers/inc-at-pt
      "H-a" 'evil-numbers/dec-at-pt))
#+END_SRC
***** Evil Visualstar
From bling: https://github.com/bling/evil-visualstar
#+BEGIN_SRC emacs-lisp
(use-package evil-visualstar
  :commands (evil-visualstar/begin-search-forward evil-visualstar/begin-search-backward)
  :config
  (global-evil-visualstar-mode t))
#+END_SRC

** Session & Project Management
*** Hydra
#+BEGIN_SRC emacs-lisp
(use-package hydra
  :commands (cpm/hydra-desktop/body))
  
  ;; hydra for TODOs
  (with-eval-after-load 'hydra
  (defhydra hydra-todo (:pre
                  (hl-todo-mode 1)
              :post
             (hl-todo-mode -1))
  "Todo"
  ("n" hl-todo-next "Next")
  ("p" hl-todo-previous "Previous")
  ("o" hl-todo-occur "Occur")
  ("q" nil "Quit" :color blue :exit t)))
#+END_SRC
*** Projectile
#+BEGIN_SRC emacs-lisp
  (use-package projectile
   :init
   ;; save projectile-known-projects-file in cache folder
    (setq projectile-known-projects-file
       (concat cpm-cache-dir "projectile-bookmarks.eld"))
    (setq projectile-cache-file
       (concat cpm-cache-dir "projectile.cache"))
    (setq projectile-enable-caching t
          projectile-files-cache-expire 60)
    :config
    (projectile-global-mode t))
#+END_SRC
*** Perspectives
Yet another attempt to manage buffers/workspaces
#+BEGIN_SRC emacs-lisp 
  (use-package perspective
    ;; :load-path "~/.emacs.d/.local/elisp/perspective"
    :commands (persp-switch persp-add-buffer persp-set-buffer)
    ;; :init
    ;; (when (not (fboundp 'make-variable-frame-local))
    ;; (defun make-variable-frame-local (variable) variable))
    :config
    (persp-mode 1))

  (use-package persp-projectile
      :commands projectile-persp-switch-project
      :config
      (defhydra hydra-persp (:columns 4
                             :color blue)
        "Perspective"
        ("a" persp-add-buffer "Add Buffer")
        ("i" persp-import "Import")
        ("c" persp-kill "Close")
        ("n" persp-next "Next")
        ("p" persp-prev "Prev")
        ("k" persp-remove-buffer "Kill Buffer")
        ("r" persp-rename "Rename")
        ("A" persp-set-buffer "Set Buffer")
        ("s" persp-switch "Switch")
        ("C-x" persp-switch-last "Switch Last")
        ("b" persp-switch-to-buffer "Switch to Buffer")
        ("P" projectile-persp-switch-project "Switch Project")
        ("q" nil "Quit")))

  (defhydra cpm/hydra-desktop (:columns 4
                               :color blue)
    "Desktops"
    ("c" desktop+-create "Create desktop")
    ("l" desktop+-load "Load desktop")) 

    ;; (defun helm-persp-projectile-switch-project ()
    ;; (interactive)
    ;; (persp-switch (let ((temp-charset "1234567890abcdefghijklmnopqrstuvwxyz")
    ;;                     (random-string ""))
    ;;                 (dotimes (i 6 random-string)
    ;;                   (setq random-string
    ;;                         (concat
    ;;                          random-string
    ;;                          (char-to-string (elt temp-charset (random (length temp-charset)))))
    ;;                         ))
    ;;                 ))
    ;; (helm-projectile-switch-project)
    ;; (persp-rename (projectile-project-name)))
#+END_SRC
*** Desktop Perspective Integration
A [[https://github.com/nex3/perspective-el/issues/19][useful set of functions]] for loading perspectives via desktop-save
#+BEGIN_SRC emacs-lisp
(defun perspectives-buffer-name-p (buffer)
    (if (and buffer
         (buffer-name buffer)
         (not (string-prefix-p "*" (buffer-name buffer)))
         (not (string-suffix-p "*" (buffer-name buffer))))
    t
      nil))

  (defun perspectives-hash-filter (current filtered parameters saving)
    (let ((value (cdr current))
      (result ())
      (keys (hash-table-keys (cdr current))))
      ;; for every perspective...
      (dolist (key keys)
    (let ((persp (gethash key value)))
      ;; that isn't killed...
      (if (not (persp-killed persp))
          (add-to-list
           'result
           (cons key
             ;; save the list of buffers
             (list (cons "buffers"
             (list
              (mapcar 'buffer-name (seq-filter 'perspectives-buffer-name-p (persp-buffers persp)))))))))))
    ;; return a different variable name so perspectives doesn't clobber it
    (cons 'perspectives-hash-serialized result)))

  ;; serialize perspectives hash
  (add-to-list 'frameset-filter-alist '(perspectives-hash . perspectives-hash-filter))
  ;; don't serialize anything else
  (add-to-list 'frameset-filter-alist '(persp-modestring . :never))
  (add-to-list 'frameset-filter-alist '(persp-recursive . :never))
  (add-to-list 'frameset-filter-alist '(persp-last . :never))
  (add-to-list 'frameset-filter-alist '(persp-curr . :never))

  (defun perspectives-restore-state ()
    (dolist (frame (frame-list))
      ;; get the serialized state off of the frame
      (let ((state (frame-parameter frame 'perspectives-hash-serialized)))
    (if state (progn
            (message "Found state, attempting restore")
            ;; delete it so we don't end up in a loop
            (set-frame-parameter frame 'perspectives-hash-serialized nil)
            (with-selected-frame frame
              (dolist (elem state)
            ;; recreate the perspective
            (with-perspective (car elem)
              (dolist (buffer-name (car (cdr (assoc "buffers" (cdr elem)))))
                ;; add the buffer back to the perspective
                (persp-add-buffer buffer-name)
                )))
              ))
      (message "No state found")
      )
    )))

  (add-hook 'desktop-after-read-hook 'perspectives-restore-state)

#+END_SRC
*** Eyebrowse Workspace & Window Management
Easy workspace creation and switching
#+BEGIN_SRC emacs-lisp
(use-package eyebrowse
  :commands (eyebrowse-switch-to-window-config-1 eyebrowse-switch-to-window-config-2) 
  :init
  (general-define-key :states '(insert normal) :keymaps 'override
    "s-1" 'eyebrowse-switch-to-window-config-1
    "s-2" 'eyebrowse-switch-to-window-config-2
    "s-3" 'eyebrowse-switch-to-window-config-3
    "s-4" 'eyebrowse-switch-to-window-config-4)
  :config 
  (setq eyebrowse-new-workspace t)
  (eyebrowse-mode t))  
#+END_SRC


*** TESTING Nameframe
[[https://github.com/john2x/nameframe][Nameframe]] provides utility functions to manage frames by their names.
#+BEGIN_SRC emacs-lisp
   (use-package nameframe
     :commands (nameframe-create-frame)
     :general
     ("s-p" 'nameframe-switch-frame)
     :after (:any perspective projectile)
     :demand t
     :config
     (nameframe-projectile-mode t)
     (nameframe-perspective-mode t))


  ;; functions for named work frames
  (defun cpm/load-org-agenda-todo ()
    (interactive)
    (persp-mode 1)
    (nameframe-create-frame "Org Agenda")
    (toggle-frame-maximized)
    (cpm/jump-to-org-agenda)
    (split-window-right)
    (find-file "~/Dropbox/org-files/todo.org"))
   (defun cpm/load-phil101 ()
     (interactive)
     (persp-mode 1)
     (nameframe-create-frame "PHIL 101")
     (toggle-frame-maximized)
     (find-file "~/Dropbox/Work/projects/phil101/content/slides/lecture_outline.org")
     (split-window-right)
     (find-file "~/Dropbox/Work/projects/phil101/content/pages/schedule.org"))
   (defun cpm/load-phil105 ()
     (interactive)
     (persp-mode 1)
     (nameframe-create-frame "PHIL 105")
     (toggle-frame-maximized)
     (find-file "~/Dropbox/Work/projects/phil105/content/slides/phil105_lecture_outline.org")
     (split-window-right)
     (find-file "~/Dropbox/Work/projects/phil105/content/pages/schedule.org"))
   (defun cpm/load-phil232 ()
     (interactive)
     (persp-mode 1)
     (nameframe-create-frame "PHIL 232")
     (toggle-frame-maximized)
     (find-file "~/Dropbox/Work/projects/phil232/phil232_lecture_outline.org")
     (split-window-right)
     (find-file "~/Dropbox/Work/projects/phil232/content/pages/schedule.org"))
    (defun cpm/load-phil871 ()
      (interactive)
      (persp-mode 1)
      (nameframe-create-frame "PHIL 871")
      (toggle-frame-maximized)
      (find-file "~/Dropbox/Work/projects/phil871/phil871-lecture-outline.org")
      (split-window-right)
      (find-file "~/Dropbox/Work/projects/phil871/content/pages/schedule.org"))
   (defun cpm/load-kant-apperception-substance ()
     (interactive)
     (persp-mode 1)
     (nameframe-create-frame "Apperception & Substance")
     (toggle-frame-maximized)
     (org-open-link-from-string "[[file:~/Dropbox/org-files/todo.org::*Apperception%20&%20Substance]]")
     (find-file "~/Dropbox/Work/projects/KantApperception/Introspection-and-self-consciousness.org")
     (find-file "~/Dropbox/Work/projects/KantApperception/ApperceptionNotes.org")
     (find-file "~/Dropbox/Work/projects/KantApperception/KantSelf.md")
     (magit-status))
   (defun cpm/load-kant-reflection ()
     (interactive)
     (persp-mode 1)
     (nameframe-create-frame "Kant on Reflection")
     (toggle-frame-maximized)
     (find-file "~/Dropbox/Work/projects/KantReflection/KantReflection.md")
     (split-window-right)
     (find-file "~/Dropbox/Work/projects/KantReflection/Kant_reflection_notes.org"))
   (defun cpm/load-kant-agency-book ()
     (interactive)
     (persp-mode 1)
     (nameframe-create-frame "Kant on Rational Agency")
     (toggle-frame-maximized)
     (find-file "~/Dropbox/Work/projects/Kant-Agency-Book/Kant-Rational-Agency-Notes.org")
     (magit-status))
   (defun cpm/load-emacs-config ()
     (interactive)
     (persp-mode 1)
     (nameframe-create-frame "Emacs Config")
     (toggle-frame-maximized)
     (find-file "~/.emacs.d/config.org")
     (magit-status))
   (defun cpm/load-kant-free-thought ()
     (interactive)
     (persp-mode 1)
     (nameframe-create-frame "Kant on Free Intellect")
     (toggle-frame-maximized)
     (find-file "~/Dropbox/Work/projects/KantFreeThought/KantFreeThought.md")
     (split-window-right)
     (find-file "~/Dropbox/Work/projects/KantFreeThought/kant-notes-intellectual-freedom.org"))

#+END_SRC


** Appearance & UI
Various settings to make Emacs (mostly the GUI version) look better or
make interaction smoother. 
   
*** Appearance
**** Frame Title 
 Show the filepath in the frame title (disabled due to text color issues).
 #+BEGIN_SRC emacs-lisp
   (setq frame-title-format '('nil))
     ;; (setq-default frame-title-format
     ;;           '((buffer-file-name "%f" "%b")))
 #+END_SRC
**** Frame Defaults
 I like the frame either centered and approximately 2/3 of a 13inch
 laptop screen or maximized.
#+BEGIN_SRC emacs-lisp
(if (display-graphic-p)
  (progn
  ;; start frame of emacs maximized
  (add-to-list 'initial-frame-alist '(fullscreen . maximized))

  ;; new frames
  (setq default-frame-alist
            '(
              (top . 25)
              (left . 275)
              (width . 106) ;; chars
              (height . 60) ;; lines
              ))))
#+END_SRC
**** Transparent titlebar
#+BEGIN_SRC emacs-lisp
;; https://github.com/d12frosted/homebrew-emacs-plus/blob/master/Formula/emacs-plus.rb#L98
;; https://github.com/d12frosted/homebrew-emacs-plus/issues/55
;; https://www.gnu.org/software/emacs/manual/html_node/elisp/Properties-in-Mode.html#Properties-in-Mode
(when (memq window-system '(mac ns))
  (add-to-list 'default-frame-alist '(ns-appearance . dark))
  (add-to-list 'default-frame-alist '(ns-transparent-titlebar . t)))
#+END_SRC

**** Borderless Frame
#+BEGIN_SRC emacs-lisp
  ;; (setq default-frame-alist '((undecorated . t)))
#+END_SRC

**** Get rid of UI cruft
 Turn off all of the GUI cruft.
 #+BEGIN_SRC emacs-lisp
   ;; Turn off mouse interface early in startup to avoid momentary display
   (when (display-graphic-p)
     (menu-bar-mode -1)
     (tool-bar-mode -1)
     (scroll-bar-mode -1)
     (tooltip-mode -1))
 #+END_SRC
**** No menu bar in terminal
 Ditto for the terminal.
 #+BEGIN_SRC emacs-lisp
   (when (not (display-graphic-p))
     (menu-bar-mode -1))
 #+END_SRC
**** Font Value
 Here we tell emacs to use the fonts set in the variables [[*Font][above]]. 
 #+BEGIN_SRC emacs-lisp
 (set-face-attribute 'default nil :font cpm-font)
 (set-face-attribute 'variable-pitch nil :font cpm-vari-font)
 (set-fontset-font t 'unicode cpm-unicode-font nil 'prepend)
 #+END_SRC

**** Font Size
 #+BEGIN_SRC emacs-lisp
 (when IS-MAC
   (global-set-key (kbd "s-=") 'scale-up-font)
   (global-set-key (kbd "s--") 'scale-down-font)
   (global-set-key (kbd "s-0") 'reset-font-size))
 #+END_SRC
**** Native Line Numbers (Emacs 26)
Emacs now has native line number support in the C source code, rather
than the other packages, which utilize elisp hacks, making it /much/
faster.
#+BEGIN_SRC emacs-lisp
  (use-package line-numbers
    :ensure nil
    ;; :hook (markdown-mode prog-mode)
    :commands display-line-numbers-mode
    :init
    (setq-default display-line-numbers-type 'visual)) 
#+END_SRC



**** Highlight numbers
 Highlight numbers in [[https://github.com/Fanael/highlight-numbers][source code]]
 #+BEGIN_SRC emacs-lisp
 (use-package highlight-numbers
   :defer t
   :init
   (add-hook 'prog-mode-hook #'highlight-numbers-mode))
 #+END_SRC
**** Highlight TODOs
 highlight TODO statements in comments 
 #+BEGIN_SRC emacs-lisp
 (use-package hl-todo
   :defer t
   :init
   (add-hook 'org-mode-hook #'hl-todo-mode)
   (add-hook 'prog-mode-hook #'hl-todo-mode)
   (add-hook 'markdown-mode-hook #'hl-todo-mode))
 #+END_SRC
**** All the icons
 Like the title says...
 #+BEGIN_SRC emacs-lisp
   ;;dependency
   (use-package font-lock+
     :after all-the-icons
     :demand t
     :ensure nil
     :load-path "~/.emacs.d/.local/elisp")
   (use-package all-the-icons
     :after (ranger deer dired)
     :load-path "~/.emacs.d/.local/elisp/all-the-icons-3.1.1")
   ;; icons for dired
   (use-package all-the-icons-dired
     :init
     (add-hook 'dired-mode-hook 'all-the-icons-dired-mode))
 #+END_SRC
**** Beacon
 Useful for letting you know where the cursor is
 #+BEGIN_SRC emacs-lisp
 (use-package beacon
   :defer 10
   :init (beacon-mode 1)
   :config
   (add-to-list 'beacon-dont-blink-major-modes 'eshell-mode))
 #+END_SRC
**** Emoji
Add emoji support. This is useful when working with html.
#+BEGIN_SRC emacs-lisp
  (use-package emojify
   :commands (emojify-mode emojify-apropos-emoji)
   :hook ((prog-mode markdown-mode) . emojify-mode)
   :config
   (setq emojify-emojis-dir (concat cpm-etc-dir "emojis")))

#+END_SRC

**** Theme
***** Toggle OSX Menubar Dark Mode
A dark mode [[https://github.com/sindresorhus/dark-mode][toggle]] for osx menubar. 
#+BEGIN_SRC emacs-lisp
  (defun cpm/osx-toggle-menubar-theme ()
    (interactive)
    (shell-command "dark-mode"))
  (defun cpm/osx-menubar-theme-light ()
    (interactive)
    (shell-command "dark-mode off"))
  (defun cpm/osx-menubar-theme-dark ()
    (interactive)
    (shell-command "dark-mode on"))
#+END_SRC
***** Solarized
 The best low-contrast theme out there.
 #+BEGIN_SRC emacs-lisp
   (use-package solarized-theme
     :if (display-graphic-p)
     :init
       (progn
       (setq org-todo-keyword-faces
            '(("TODO" . (:foreground "orange" :weight bold)) ("STARTED" . "yellow")
              ("WAITING" . (:weight bold))
              ("SUBMITTED-C" . "green") ("SUBMITTED-J" . "green")
              ("ACCEPTED-C" . "silver") ("ACCEPTED-J" . "silver")
              ("REVISE" . (:foreground "violet" :weight bold))))

           ;; don't make the fringe stand out from the background
           (setq solarized-distinct-fringe-background nil)

           ;; change the font for some headings and titles
           (setq solarized-use-variable-pitch t)

           ;; make the modeline high contrast
           (setq solarized-high-contrast-mode-line nil)
           ;; use this setting without hi contrast modeline
           (setq x-underline-at-descent-line t)

           ;; Use bolding
           (setq solarized-use-less-bold nil)

           ;; Use more italics
           (setq solarized-use-more-italic t)

           ;; Use colors for indicators such as git:gutter, flycheck and similar
           (setq solarized-emphasize-indicators t)

           ;; Set to nil of you don't want to change size of org-mode headlines (but keep other size-changes)
           (setq solarized-scale-org-headlines t)

           ;; Theme & menubar toggle
           (setq active-theme 'solarized-dark)
           (defun toggle-dark-light-theme ()
           (interactive)
           (if (eq active-theme 'solarized-light) 
               (progn (setq active-theme 'solarized-dark) 
                     (cpm/osx-menubar-theme-dark))
               (progn (setq active-theme 'solarized-light) 
                      (cpm/osx-menubar-theme-light)))
           (load-theme active-theme)))
           ;; (powerline-reset)))

            (progn
            (defvar after-load-theme-hook nil
            "Hook run after a color theme is loaded using `load-theme'.")
            (defadvice load-theme (after run-after-load-theme-hook activate)
            "Run `after-load-theme-hook'."
            (run-hooks 'after-load-theme-hook))
            (defun customize-solarized-dark ()
            "Customize solarized theme"
            (if (member 'solarized-dark custom-enabled-themes)
                  (custom-theme-set-faces
                  'solarized-dark
                  ;; make bg darker for higher contrast
                  ;; '(default ((t (:inherit nil :stipple nil :background "#002833" :foreground "#839496" :inverse-video nil :box nil :strike-through nil :overline nil :underline nil :slant normal :weight normal :height 130 :width normal :foundry "nil" :family "Inconsolata LGC"))))
                  '(default ((t (:background "#002833" :foreground "#839496"))))
                  ;; matching fringe
                  '(fringe ((t (:background "#002833" :foreground "#586e75"))))
                  ;; fix modeline underline
                   '(mode-line ((t (:background "#073642" :foreground "#839496" :box (:line-width 1 :color "#073642" :style unspecified) :overline "#073642" :underline "#073642"))))
                  ;; terminal
                  '(term ((t (:background "#002833" :foreground "#839496"))))
                  ;; org faces
                  '(org-block ((t (:foreground "#2E8B57"))))
                  '(org-block-begin-line ((t (:foreground "#74a8a4" :weight bold :slant normal))))
                  '(org-block-end-line ((t (:foreground "#74a8a4" :weight bold :slant normal))))
                  '(org-level-1 ((t (:inherit variable-pitch :foreground "#268bd2" :height 1.5))))
                  '(org-level-2 ((t (:inherit variable-pitch :foreground "medium sea green" :height 1.3))))
                  '(org-level-3 ((t (:inherit variable-pitch :foreground "#cb4b16" :height 1.2))))
                  '(org-level-8 ((t (:inherit variable-pitch :foreground "#9e1e86" :height 1.1))))
                  '(org-quote ((t (:inherit org-block :slant normal :weight normal))))
                  ;; markdown faces
                  '(markdown-comment-face ((t (:weight normal :slant italic :strike-through nil))))
                  '(markdown-header-face-1 ((t (:inherit variable-pitch :foreground "#268bd2" :height 1.75))))
                  '(markdown-header-face-2 ((t (:inherit variable-pitch :foreground "medium sea green" :height 1.45))))
                  '(markdown-header-face-3 ((t (:inherit variable-pitch :foreground "#cb4b16" :height 1.2))))
                  ;; helm faces
                  '(helm-selection ((t (:background "#073642" :underline nil))))
                  '(helm-match ((t (:foreground "#b58900"))))
                  ;; line number highlighting 
                  '(line-number-current-line ((t (:inherit default :foreground "goldenrod1"))))
                  ;; '(nlinum-current-line ((t (:inherit default :foreground "goldenrod1"))))
                  '(linum-highlight-face ((t (:inherit default :foreground "goldenrod1"))))
                   ;; '(nlinum-hl-face ((t (:inherit default :foreground "goldenrod1"))))
                  ;; battery faces
                  '(fancy-battery-charging ((t (:foreground "dark blue" :weight bold))))
                  '(fancy-battery-critical ((t (:foreground "dark red" :weight bold))))
                  '(fancy-battery-discharging ((t (:foreground "dark magenta" :weight bold)))))))

             (add-hook 'after-load-theme-hook 'customize-solarized-dark)

        (defun customize-solarized-light ()
        "Customize solarized theme"
        (if (member 'solarized-light custom-enabled-themes)
              (custom-theme-set-faces
              'solarized-light
              ;; org faces
              '(org-block ((t (:foreground "#2E8B57"))))
              '(org-block-begin-line ((t (:foreground "#74a8a4" :weight bold :slant normal))))
              '(org-block-end-line ((t (:foreground "#74a8a4" :weight bold :slant normal))))
              '(org-level-1 ((t (:inherit variable-pitch :foreground "#268bd2" :height 1.3))))
              '(org-level-2 ((t (:inherit variable-pitch :foreground "medium sea green" :height 1.2))))
              '(org-level-3 ((t (:inherit variable-pitch :foreground "#cb4b16" :height 1.15))))
              '(org-level-8 ((t (:inherit variable-pitch :foreground "#9e1e86" :height 1.1))))
              '(org-quote ((t (:inherit org-block :slant normal :weight normal))))
              ;; markdown faces
              '(markdown-comment-face ((t (:weight normal :slant italic :strike-through nil))))
              '(markdown-header-face-1 ((t (:inherit variable-pitch :foreground "#268bd2" :height 1.75))))
              '(markdown-header-face-2 ((t (:inherit variable-pitch :foreground "medium sea green" :height 1.45))))
              '(markdown-header-face-3 ((t (:inherit variable-pitch :foreground "#cb4b16" :height 1.2))))

              ;; helm faces
              '(helm-selection ((t (:background "#eee8d5" :underline nil :weight bold))))
              '(helm-match ((t (:foreground "#cb4b16" :weight bold))))

              ;; '(helm-selection ((t (:foreground "#f7f438" :background "#64b5ea" :underline nil :weight bold))))
              ;; line size 
              '(set-face-attribute 'linum nil :inherit 'fixed-pitch)
              ;; line highlighting 
              '(linum-highlight-face ((t (:inherit default :foreground "#002b36"))))
              ;; '(nlinum-hl-face ((t (:inherit default :foreground "#002b36"))))
              '(line-number-current-line ((t (:inherit default :foreground "#002b36"))))
              ;; '(nlinum-current-line ((t (:inherit default :foreground "#002b36"))))
              ;; battery faces
              '(fancy-battery-charging ((t (:foreground "dark blue" :weight bold))))
              '(fancy-battery-critical ((t (:foreground "dark red" :weight bold))))
              '(fancy-battery-discharging ((t (:foreground "dark magenta" :weight bold))))))
                  )

             (add-hook 'after-load-theme-hook 'customize-solarized-light))
             (load-theme 'solarized-dark t))
 #+END_SRC

***** Gruvbox
 This is a great general-purpose theme. Use it in terminal.

 #+BEGIN_SRC emacs-lisp
 (use-package gruvbox-theme
   :if (not (display-graphic-p))
   :init
   (load-theme 'gruvbox t)
   )
 #+END_SRC 
 

***** Other Themes
Make sure that other themes I like are downloaded and available (not
that I use anything other than solarized :)
#+BEGIN_SRC emacs-lisp
  (defvar packages-appearance '(doom-themes nord-theme solarized-theme
    zenburn-theme molokai-theme darktooth-theme gotham-theme
    ample-theme material-theme leuven-theme
    spacemacs-theme gruvbox-theme forest-blue-theme flatland-theme
    afternoon-theme cyberpunk-theme darkmine-theme
    tao-theme darkokai-theme jazz-theme suscolors-theme
    omtose-phellack-theme atom-one-dark-theme nubox
    color-theme-sanityinc-tomorrow alect-themes kaolin-themes)
  "A list of themes to ensure are installed at launch.")

  (defun appearance-packages-installed-p ()
    (loop for p in packages-appearance
          when (not (package-installed-p p)) do (return nil)
          finally (return t)))

  (unless (appearance-packages-installed-p)
    ;; check for new packages (package versions)
    (message "%s" "Emacs is now refreshing its package themes...")
    (package-refresh-contents)
    (message "%s" " done.")
    ;; install the missing packages
    (dolist (p packages-appearance)
      (when (not (package-installed-p p))
        (package-install p))))

  (provide 'packages-appearance)

#+END_SRC



**** Modeline
***** Another Doom Modeline
[[https://github.com/torgeir/.emacs.d/blob/master/site-lisp/t-doom-modeline/t-doom-modeline.el][Torgeir's version]] of the [[https://github.com/hlissner/doom-emacs][doom mode line]]. 
#+BEGIN_SRC emacs-lisp
  ;;; ui/doom-modeline/config.el -*- lexical-binding: t; -*-

  (defun t/project-root ()
    "Get project root without throwing"
    (let (projectile-require-project-root strict-p)
      (projectile-project-root)))

  ;; TODO torgeir added this
  (defun doom-project-root ()
    (require 'projectile)
    (t/project-root))


  (defmacro def-modeline-segment! (name &rest forms)
    "Defines a modeline segment and byte compiles it."
    (declare (indent defun) (doc-string 2))
    (let ((sym (intern (format "doom-modeline-segment--%s" name))))
      `(progn
         (defun ,sym () ,@forms)
         ,(unless (bound-and-true-p byte-compile-current-file)
            `(let (byte-compile-warnings)
               (byte-compile #',sym))))))

  (defsubst doom--prepare-modeline-segments (segments)
    (cl-loop for seg in segments
             if (stringp seg)
             collect seg
             else
             collect (list (intern (format "doom-modeline-segment--%s" (symbol-name seg))))))

  (defmacro def-modeline! (name lhs &optional rhs)
    "Defines a modeline format and byte-compiles it. NAME is a symbol to identify
  it (used by `doom-modeline' for retrieval). LHS and RHS are lists of symbols of
  modeline segments defined with `def-modeline-segment!'.
  Example:
    (def-modeline! minimal
      (bar matches \" \" buffer-info)
      (media-info major-mode))
    (doom-set-modeline 'minimal t)"
    (let ((sym (intern (format "doom-modeline-format--%s" name)))
          (lhs-forms (doom--prepare-modeline-segments lhs))
          (rhs-forms (doom--prepare-modeline-segments rhs)))
      `(progn
         (defun ,sym ()
           (let ((lhs (list ,@lhs-forms))
                 (rhs (list ,@rhs-forms)))
             (let ((rhs-str (format-mode-line rhs)))
               (list lhs
                     (propertize
                      " " 'display
                      `((space :align-to (- (+ right right-fringe right-margin)
                                            ,(+ 1 (string-width rhs-str))))))
                     rhs-str))))
         ,(unless (bound-and-true-p byte-compile-current-file)
            `(let (byte-compile-warnings)
               (byte-compile #',sym))))))

  (defun doom-modeline (key)
    "Returns a mode-line configuration associated with KEY (a symbol). Throws an
  error if it doesn't exist."
    (let ((fn (intern (format "doom-modeline-format--%s" key))))
      (when (functionp fn)
        `(:eval (,fn)))))

  (defun doom-set-modeline (key &optional default)
    "Set the modeline format. Does nothing if the modeline KEY doesn't exist. If
  DEFAULT is non-nil, set the default mode-line for all buffers."
    (let ((modeline (doom-modeline key)))
      (when modeline
        (setf (if default
                  (default-value 'mode-line-format)
                (buffer-local-value 'mode-line-format (current-buffer)))
              modeline))))

  ;; TODO /torgeir added this

  ;; Keep `+doom-modeline-current-window' up-to-date
  (defvar +doom-modeline-current-window (frame-selected-window))
  (defun +doom-modeline|set-selected-window (&rest _)
    "Sets `+doom-modeline-current-window' appropriately"
    (let ((win (frame-selected-window)))
      (unless (minibuffer-window-active-p win)
        (setq +doom-modeline-current-window win))))

  (add-hook 'window-configuration-change-hook #'+doom-modeline|set-selected-window)
  (add-hook 'focus-in-hook #'+doom-modeline|set-selected-window)
  (advice-add #'handle-switch-frame :after #'+doom-modeline|set-selected-window)
  (advice-add #'select-window :after #'+doom-modeline|set-selected-window)



  ;;
  ;; Variables
  ;;

  (defvar +doom-modeline-height 40
    "How tall the mode-line should be (only respected in GUI emacs).")

  (defvar +doom-modeline-bar-width 5
    "How wide the mode-line bar should be (only respected in GUI emacs).")

  (defvar +doom-modeline-vspc
    (propertize " " 'face 'variable-pitch)
    "TODO")

  ;; externs
  (defvar anzu--state nil)
  (defvar evil-mode nil)
  (defvar evil-state nil)
  (defvar evil-visual-selection nil)
  (defvar iedit-mode nil)
  (defvar all-the-icons-scale-factor)
  (defvar all-the-icons-default-adjust)


  ;;
  ;; Custom faces
  ;;

  (defgroup +doom-modeline nil
    ""
    :group 'doom)

  (defface doom-modeline-buffer-path
    '((t (:inherit mode-line-emphasis :bold t)))
    "Face used for the dirname part of the buffer path."
    :group '+doom-modeline)

  (defface doom-modeline-buffer-file
    '((t (:inherit mode-line-buffer-id)))
    "Face used for the filename part of the mode-line buffer path."
    :group '+doom-modeline)

  (defface doom-modeline-buffer-modified
    '((t (:inherit error :background nil :bold t)))
    "Face used for the 'unsaved' symbol in the mode-line."
    :group '+doom-modeline)

  (defface doom-modeline-buffer-major-mode
    '((t (:inherit mode-line-emphasis :bold t)))
    "Face used for the major-mode segment in the mode-line."
    :group '+doom-modeline)

  (defface doom-modeline-highlight
    '((t (:inherit mode-line-emphasis)))
    "Face for bright segments of the mode-line."
    :group '+doom-modeline)

  (defface doom-modeline-panel
    '((t (:inherit mode-line-highlight)))
    "Face for 'X out of Y' segments, such as `+doom-modeline--anzu', `+doom-modeline--evil-substitute' and
  `iedit'"
    :group '+doom-modeline)

  (defface doom-modeline-info
    `((t (:inherit success :bold t)))
    "Face for info-level messages in the modeline. Used by `*vc'."
    :group '+doom-modeline)

  (defface doom-modeline-warning
    `((t (:inherit warning :bold t)))
    "Face for warnings in the modeline. Used by `*flycheck'"
    :group '+doom-modeline)

  (defface doom-modeline-urgent
    `((t (:inherit error :bold t)))
    "Face for errors in the modeline. Used by `*flycheck'"
    :group '+doom-modeline)

  ;; Bar
  (defface doom-modeline-bar '((t (:inherit highlight :background "#268bd2")))
    "The face used for the left-most bar on the mode-line of an active window."
    :group '+doom-modeline)

  (defface doom-modeline-eldoc-bar '((t (:inherit shadow)))
    "The face used for the left-most bar on the mode-line when eldoc-eval is
  active."
    :group '+doom-modeline)

  (defface doom-modeline-inactive-bar '((t (:inherit warning :inverse-video t)))
    "The face used for the left-most bar on the mode-line of an inactive window."
    :group '+doom-modeline)


  ;;
  ;; Bootstrap
  ;;

  ;; Show version string for multi-version managers like rvm, rbenv, pyenv, etc.
  (defvar-local +doom-modeline-env-version nil)
  (defvar-local +doom-modeline-env-command nil)
  (add-hook! '(focus-in-hook find-file-hook) #'+doom-modeline|update-env)
  (defun +doom-modeline|update-env ()
    (when +doom-modeline-env-command
      (let* ((default-directory (doom-project-root))
             (s (shell-command-to-string +doom-modeline-env-command)))
        (setq +doom-modeline-env-version (if (string-match "[ \t\n\r]+\\'" s)
                                             (replace-match "" t t s)
                                           s)))))

  ;; Only support python and ruby for now

  ;; TODO torgeir
  (add-hook! 'python-mode-hook (setq +doom-modeline-env-command "python --version 2>&1 | cut -d' ' -f2"))
  (add-hook! 'ruby-mode-hook   (setq +doom-modeline-env-command "ruby   --version 2>&1 | cut -d' ' -f2"))


  ;;
  ;; Modeline helpers
  ;;

  (defsubst active ()
    (eq (selected-window) +doom-modeline-current-window))

  ;; Inspired from `powerline's `pl/make-xpm'.
  (def-memoized! +doom-modeline--make-xpm (color height width)
    "Create an XPM bitmap."
    (propertize
     " " 'display
     (let ((data (make-list height (make-list width 1)))
           (color (or color "None")))
       (create-image
        (concat
         (format "/* XPM */\nstatic char * percent[] = {\n\"%i %i 2 1\",\n\". c %s\",\n\"  c %s\","
                 (length (car data))
                 (length data)
                 color
                 color)
         (apply #'concat
                (cl-loop with idx = 0
                         with len = (length data)
                         for dl in data
                         do (cl-incf idx)
                         collect
                         (concat "\""
                                 (cl-loop for d in dl
                                          if (= d 0) collect (string-to-char " ")
                                          else collect (string-to-char "."))
                                 (if (eq idx len) "\"};" "\",\n")))))
        'xpm t :ascent 'center))))

  (defsubst +doom-modeline--buffer-file ()
    "Display the base of the current buffer's filename."
    (if buffer-file-name
        (file-name-nondirectory (or buffer-file-truename (file-truename buffer-file-name)))
      "%b"))

  (defsubst +doom-modeline--buffer-path ()
    "Displays the buffer's full path relative to the project root (includes the
  project root). Excludes the file basename. See `doom-buffer-name' for that."
    (when buffer-file-name
      (let ((buffer-path
             (file-relative-name (file-name-directory
                                  (or buffer-file-truename (file-truename buffer-file-name)))
                                 (doom-project-root))))
        (unless (equal buffer-path "./")
          (let ((max-length (truncate (* (window-body-width) 0.4))))
            (if (> (length buffer-path) max-length)
                (let ((path (nreverse (split-string buffer-path "/" t)))
                      (output ""))
                  (when (and path (equal "" (car path)))
                    (setq path (cdr path)))
                  (while (and path (<= (length output) (- max-length 4)))
                    (setq output (concat (car path) "/" output)
                          path (cdr path)))
                  (when path
                    (setq output (concat "../" output)))
                  (unless (string-suffix-p "/" output)
                    (setq output (concat output "/")))
                  output)
              buffer-path))))))


  ;;
  ;; Segments
  ;;

  (def-modeline-segment! buffer-project
    "Displays `doom-project-root'. This is for special buffers like the scratch
  buffer where knowing the current project directory is important."
    (let ((face (if (active) 'doom-modeline-buffer-path)))
      (concat (if (display-graphic-p) " ")
              (all-the-icons-octicon
               "file-directory"
               :face face
               :v-adjust -0.05
               :height 1.25)
              (propertize (concat " " (abbreviate-file-name (doom-project-root)))
                          'face face))))

  ;;
  (def-modeline-segment! buffer-info
    "Combined information about the current buffer, including the current working
  directory, the file name, and its state (modified, read-only or non-existent)."
    (let* ((all-the-icons-scale-factor 1.2)
           (modified-p (buffer-modified-p))
           (active (active))
           (faces (if modified-p 'doom-modeline-buffer-modified)))
      (concat (cond (buffer-read-only
                     (concat (all-the-icons-octicon
                              "lock"
                              :face 'doom-modeline-warning
                              :v-adjust -0.05)
                             " "))
                    (modified-p
                     (concat (all-the-icons-faicon
                              "floppy-o"
                              :face 'doom-modeline-buffer-modified
                              :v-adjust -0.0575)
                             " "))
                    ((and buffer-file-name
                          (not (file-exists-p buffer-file-name)))
                     (concat (all-the-icons-octicon
                              "circle-slash"
                              :face 'doom-modeline-urgent
                              :v-adjust -0.05)
                             " ")))
              (when-let (dir-path (+doom-modeline--buffer-path))
                (if-let (faces (or faces (if active 'doom-modeline-buffer-path)))
                    (propertize dir-path 'face `(:inherit ,faces))
                  dir-path))
              (when-let (file-path (+doom-modeline--buffer-file))
                (if-let (faces (or faces (if active 'doom-modeline-buffer-file)))
                    (propertize file-path 'face `(:inherit ,faces))
                  file-path)))))

  ;;
  (def-modeline-segment! buffer-info-simple
    "Return the current buffer name only, but with fontification."
    (propertize "%b" 'face (if (active) 'doom-modeline-buffer-file)))

  ;;
  (def-modeline-segment! buffer-encoding
    "Displays the encoding and eol style of the buffer the same way Atom does."
    (concat (let ((eol-type (coding-system-eol-type buffer-file-coding-system)))
              (cond ((eq eol-type 0) "LF  ")
                    ((eq eol-type 1) "CRLF  ")
                    ((eq eol-type 2) "CR  ")))
            (let* ((sys (coding-system-plist buffer-file-coding-system))
                   (sys-name (plist-get sys :name))
                   (sys-cat (plist-get sys :category)))
              (cond ((memq sys-cat '(coding-category-undecided coding-category-utf-8))
                     "UTF-8")
                    (t (upcase (symbol-name sys-name)))))
            "  "))

  ;;
  (def-modeline-segment! major-mode
    "The major mode, including process, environment and text-scale info."
    (propertize
     (concat (format-mode-line mode-name)
             (if (stringp mode-line-process) mode-line-process)
             (if +doom-modeline-env-version (concat " " +doom-modeline-env-version))
             (and (featurep 'face-remap)
                  (/= text-scale-mode-amount 0)
                  (format " (%+d)" text-scale-mode-amount)))
     'face (if (active) 'doom-modeline-buffer-major-mode)))

  ;;
  (def-modeline-segment! vcs
    "Displays the current branch, colored based on its state."
    (when vc-mode
      (let ((backend (when buffer-file-name (vc-backend buffer-file-name)))
            (state   (when buffer-file-name (vc-state buffer-file-name)))
            (face    'mode-line-inactive)
            (active  (active))
            (all-the-icons-scale-factor 1.0)
            (all-the-icons-default-adjust -0.1))
        (concat "  "
                (cond ((memq state '(edited added))
                       (if active (setq face 'doom-modeline-info))
                       (require 'all-the-icons)
                       (all-the-icons-octicon
                        "git-compare"
                        :face face
                        :height 1.2
                        :v-adjust -0.05))
                      ((eq state 'needs-merge)
                       (if active (setq face 'doom-modeline-info))
                       (all-the-icons-octicon "git-merge" :face face))
                      ((eq state 'needs-update)
                       (if active (setq face 'doom-modeline-warning))
                       (all-the-icons-octicon "arrow-down" :face face))
                      ((memq state '(removed conflict unregistered))
                       (if active (setq face 'doom-modeline-urgent))
                       (all-the-icons-octicon "alert" :face face))
                      (t
                       (if active (setq face 'font-lock-doc-face))
                       (all-the-icons-octicon
                        "git-compare"
                        :face face
                        :height 1.2
                        :v-adjust -0.05)))
                " "
                (propertize (substring vc-mode (+ (if (eq backend 'Hg) 2 3) 2))
                            'face (if active face))
                " "))))

  ;;
  (defun +doom-ml-icon (icon &optional text face voffset)
    "Displays an octicon ICON with FACE, followed by TEXT. Uses
  `all-the-icons-octicon' to fetch the icon."
    (concat
     (if vc-mode " " "  ")
     (when icon
       (concat
        (all-the-icons-material icon :face face :height 1.1 :v-adjust (or voffset -0.2))
        ;; (all-the-icons-octicon icon :face face :height 1.0 :v-adjust 0)
        (if text +doom-modeline-vspc)))
     (when text
       (propertize text 'face face))
     (if vc-mode "  " " ")))

  (def-modeline-segment! flycheck
    "Displays color-coded flycheck error status in the current buffer with pretty
  icons."
    (when (boundp 'flycheck-last-status-change)
      (pcase flycheck-last-status-change
        ('finished (if flycheck-current-errors
                       (let-alist (flycheck-count-errors flycheck-current-errors)
                         (let ((sum (+ (or .error 0) (or .warning 0))))
                           (+doom-ml-icon "do_not_disturb_alt"
                                          (number-to-string sum)
                                          (if .error 'doom-modeline-urgent 'doom-modeline-warning)
                                          -0.25)))
                     (+doom-ml-icon "check" nil 'doom-modeline-info)))
        ('running     (+doom-ml-icon "access_time" nil 'font-lock-doc-face -0.25))
        ('no-checker  (+doom-ml-icon "sim_card_alert" "-" 'font-lock-doc-face))
        ('errored     (+doom-ml-icon "sim_card_alert" "Error" 'doom-modeline-urgent))
        ('interrupted (+doom-ml-icon "pause" "Interrupted" 'font-lock-doc-face)))))
  ;; ('interrupted (+doom-ml-icon "x" "Interrupted" 'font-lock-doc-face)))))

  ;;
  (defsubst doom-column (pos)
    (save-excursion (goto-char pos)
                    (current-column)))

  (def-modeline-segment! selection-info
    "Information about the current selection, such as how many characters and
  lines are selected, or the NxM dimensions of a block selection."
    (when (and (active) (or mark-active (eq evil-state 'visual)))
      (let ((reg-beg (region-beginning))
            (reg-end (region-end)))
        (propertize
         (let ((lines (count-lines reg-beg (min (1+ reg-end) (point-max)))))
           (cond ((or (bound-and-true-p rectangle-mark-mode)
                      (eq 'block evil-visual-selection))
                  (let ((cols (abs (- (doom-column reg-end)
                                      (doom-column reg-beg)))))
                    (format "%dx%dB" lines cols)))
                 ((eq 'line evil-visual-selection)
                  (format "%dL" lines))
                 ((> lines 1)
                  (format "%dC %dL" (- (1+ reg-end) reg-beg) lines))
                 (t
                  (format "%dC" (- (1+ reg-end) reg-beg)))))
         'face 'doom-modeline-highlight))))


  ;;
  (defun +doom-modeline--macro-recording ()
    "Display current Emacs or evil macro being recorded."
    (when (and (active) (or defining-kbd-macro executing-kbd-macro))
      (let ((sep (propertize " " 'face 'doom-modeline-panel)))
        (concat sep
                (propertize (if (bound-and-true-p evil-this-macro)
                                (char-to-string evil-this-macro)
                              "Macro")
                            'face 'doom-modeline-panel)
                sep
                (all-the-icons-octicon "triangle-right"
                                       :face 'doom-modeline-panel
                                       :v-adjust -0.05)
                sep))))

  (defsubst +doom-modeline--anzu ()
    "Show the match index and total number thereof. Requires `anzu', also
  `evil-anzu' if using `evil-mode' for compatibility with `evil-search'."
    (when (and anzu--state (not iedit-mode))
      (propertize
       (let ((here anzu--current-position)
             (total anzu--total-matched))
         (cond ((eq anzu--state 'replace-query)
                (format " %d replace " total))
               ((eq anzu--state 'replace)
                (format " %d/%d " here total))
               (anzu--overflow-p
                (format " %s+ " total))
               (t
                (format " %s/%d " here total))))
       'face (if (active) 'doom-modeline-panel))))

  (defsubst +doom-modeline--evil-substitute ()
    "Show number of :s matches in real time."
    (when (and evil-mode
               (or (assq 'evil-ex-substitute evil-ex-active-highlights-alist)
                   (assq 'evil-ex-global-match evil-ex-active-highlights-alist)
                   (assq 'evil-ex-buffer-match evil-ex-active-highlights-alist)))
      (propertize
       (let ((range (if evil-ex-range
                        (cons (car evil-ex-range) (cadr evil-ex-range))
                      (cons (line-beginning-position) (line-end-position))))
             (pattern (car-safe (evil-delimited-arguments evil-ex-argument 2))))
         (if pattern
             (format " %s matches " (how-many pattern (car range) (cdr range)))
           " ... "))
       'face (if (active) 'doom-modeline-panel))))

  (defsubst +doom-modeline--iedit ()
    "Show the number of iedit regions matches + what match you're on."
    (when (and iedit-mode iedit-occurrences-overlays)
      (propertize
       (let ((this-oc (or (let ((inhibit-message t))
                            (iedit-find-current-occurrence-overlay))
                          (progn (iedit-prev-occurrence)
                                 (iedit-find-current-occurrence-overlay))))
             (length (length iedit-occurrences-overlays)))
         (format " %s/%d "
                 (if this-oc
                     (- length
                        (length (cdr
                                 (memq this-oc (sort (append iedit-occurrences-overlays (list))
                                                     (lambda (x y) (< (overlay-start x) (overlay-start y))))))))
                   "-")
                 length))
       'face (if (active) 'doom-modeline-panel))))

  (def-modeline-segment! matches
    "Displays: 1. the currently recording macro, 2. A current/total for the
  current search term (with anzu), 3. The number of substitutions being conducted
  with `evil-ex-substitute', and/or 4. The number of active `iedit' regions."
    (let ((meta (concat (+doom-modeline--macro-recording)
                        (+doom-modeline--anzu)
                        (+doom-modeline--evil-substitute)
                        (+doom-modeline--iedit))))
      (or (and (not (string= meta "")) meta)
          (if buffer-file-name " %I "))))

  ;; TODO Include other information
  (def-modeline-segment! media-info
    "Metadata regarding the current file, such as dimensions for images."
    (cond ((eq major-mode 'image-mode)
           (let ((size (image-size (image-get-display-property) :pixels)))
             (format "  %dx%d  " (car size) (cdr size))))))

  ;;
  (def-modeline-segment! eldoc
    "Display eldoc documentation in the mode-line while using the minibuffer (e.g.
  `eval-expression')."
    (bound-and-true-p str))

  ;; These bars regulate the height of the mode-line in GUI Emacs.
  (def-modeline-segment! bar
    (if (display-graphic-p)
        (+doom-modeline--make-xpm
         (face-background (if (active)
                              'doom-modeline-bar
                            'doom-modeline-inactive-bar)
                          nil t)
         +doom-modeline-height
         +doom-modeline-bar-width)
      ""))

  (def-modeline-segment! eldoc-bar
    "A differently colored bar, to signify an eldoc display."
    (if (display-graphic-p)
        (+doom-modeline--make-xpm
         (face-background 'doom-modeline-eldoc-bar nil t)
         +doom-modeline-height
         +doom-modeline-bar-width)
      ""))


  ;;
  ;; Mode lines
  ;;

  (def-modeline! main
    (bar matches " " buffer-info "  %l:%c %p  " selection-info)
    (buffer-encoding major-mode vcs flycheck))

  (def-modeline! eldoc
    (eldoc-bar " " eldoc)
    (media-info major-mode))

  (def-modeline! minimal
    (bar matches " " buffer-info)
    (media-info major-mode))

  (def-modeline! special
    (bar matches " " buffer-info-simple "  %l:%c %p  " selection-info)
    (buffer-encoding major-mode flycheck))

  (def-modeline! project
    (bar buffer-project)
    (major-mode))

  (def-modeline! media
    (bar " %b  ")
    (media-info major-mode))

  ;;
  (doom-set-modeline 'main t)

  ;; This scratch buffer is already created, and doesn't get a modeline. For the
  ;; love of Emacs, someone give the man a modeline!
  (with-current-buffer "*scratch*"
    (require 'all-the-icons)
    (doom-set-modeline 'main))


  ;;
  ;; Hooks
  ;;

  (defun +doom-modeline|set-special-modeline ()
    (doom-set-modeline 'special))

  (defun +doom-modeline|set-media-modeline ()
    (doom-set-modeline 'media))

  (add-hook 'org-src-mode-hook #'+doom-modeline|set-special-modeline)
  (add-hook 'image-mode-hook #'+doom-modeline|set-media-modeline)
  (add-hook 'circe-mode-hook #'+doom-modeline|set-special-modeline)

  (provide 't-doom-modeline)

#+END_SRC
***** Hide mode line
 Hide mode line. From http://bzg.fr/emacs-hide-mode-line.html

 #+BEGIN_SRC emacs-lisp
 (defvar-local hidden-mode-line-mode nil)
 (defvar-local hide-mode-line nil)
 (define-minor-mode hidden-mode-line-mode
   "Minor mode to hide the mode-line in the current buffer."
   :init-value nil
   :global t
   :variable hidden-mode-line-mode
   :group 'editing-basics
   (if hidden-mode-line-mode
       (setq hide-mode-line mode-line-format
             mode-line-format nil)
     (setq mode-line-format hide-mode-line
           hide-mode-line nil))
   (force-mode-line-update)
   ;; Apparently force-mode-line-update is not always enough to
   ;; redisplay the mode-line
   (redraw-display)
   (when (and (called-interactively-p 'interactive)
              hidden-mode-line-mode)
     (run-with-idle-timer
      0 nil 'message
      (concat "Hidden Mode Line Mode enabled.  "
              "Use M-x hidden-mode-line-mode to make the mode-line appear."))))

 #+END_SRC
 

*** Navigation
**** Bookmarks
Use [[https://www.emacswiki.org/emacs/BookmarkPlus][Bookmark Plus]]. Since it is an emacs wiki package you can't get it from
MELPA. The git mirror is [[https://github.com/emacsmirror/bookmark-plus][here]].
#+BEGIN_SRC emacs-lisp
  (use-package bookmark+
    :load-path "~/.emacs.d/.local/elisp/bookmark+/"
    :commands (bmkp-switch-bookmark-file-create bmkp-set-desktop-bookmark)
    :init
    (setq bookmark-default-file (concat cpm-cache-dir "bookmarks"))
    (setq bmkp-last-as-first-bookmark-file (concat cpm-cache-dir "bookmarks"))
  )
#+END_SRC 

**** Helm
[[https://emacs-helm.github.io/helm/][Helm]] is a robust and well-designed completion framework. It can do [[https://tuhdo.github.io/helm-intro.html][quite a lot]].
***** Helm Settings
#+BEGIN_SRC emacs-lisp 
  (use-package helm
    :general 
    ("M-x" 'helm-M-x)
    ("C-h i" 'helm-info)
    :diminish (helm-mode . "")
    :commands (helm-mini helm-M-x helm-find-files helm-find)
    :init
    (setq helm-locate-fuzzy-match nil
          helm-locate-command "mdfind -interpret -name %s %s")
    :config
    (progn
      ;; Use helm to provide :ls, unless ibuffer is used
      (evil-ex-define-cmd "buffers" 'helm-buffers-list)
      (setq helm-M-x-fuzzy-match t  ;; Use fuzzy match in helm
            helm-apropos-fuzzy-match t
            helm-buffers-fuzzy-matching t
            helm-imenu-fuzzy-match t
            helm-recentf-fuzzy-match t
            helm-adaptive-mode 1 ; learn from selections
            helm-prevent-escaping-from-minibuffer t
            helm-bookmark-show-location t
            helm-ff-file-name-history-use-recentf t
            helm-find-files-sort-directories t
            helm-display-header-line nil
            helm-move-to-line-cycle-in-source t
            helm-always-two-windows t                       
            helm-split-window-in-side-p nil
            ;; helm-split-window-default-side 'other
            helm-echo-input-in-header-line t)
      (setq helm-boring-buffer-regexp-list '("\\*SPEEDBAR" "\\*magit" "\\*Sunshine" "\\*Help" "\\*Shell Command Output" "\\*Flycheck error message" "\\*Compile-Log" "\\` " "\\*helm" "\\*helm-mode" "\\*Echo Area" "\\*Minibuf" "\\*osx-location" "\\*Dired by name" "\\*Deer" "\\*Deer\:name"))
      (helm-autoresize-mode 1)
      (setq helm-autoresize-max-height 40)
      (setq helm-autoresize-min-height 35)
      (define-key helm-map (kbd "C-a") (kbd "RET"))
      ;;; helm vim-bindings in buffer ;;
      (map! (:map helm-map
        "TAB"   'helm-execute-persistent-action ; rebind tab to do persistent action
        "C-i"   'helm-execute-persistent-action ; make TAB works in terminal
        "C-z"   'helm-select-action ; list actions using C-z
        "C-j"   'helm-next-line
        "C-k"   'helm-previous-line
        "C-h"   'helm-next-source
        "C-l"   'helm-previous-source
        "C-S-h" 'describe-key)))
       (helm-mode 1))
 
  ;; use helm follow mode for search
  (with-eval-after-load 'helm-regexp
  (setq helm-source-occur
        (helm-make-source "Occur" 'helm-source-multi-occur
          :follow 1)))

#+END_SRC
***** Hide Mode Lines
Hide modelines of other windows while helm is open, again from
https://github.com/hatschipuh/better-helm.

#+BEGIN_SRC emacs-lisp
  (defvar my-helm-bottom-buffers nil
	"List of bottom buffers before helm session.
	Its element is a pair of `buffer-name' and `mode-line-format'.")

  (defun my-helm-bottom-buffers-init ()
	(setq-local mode-line-format (default-value 'mode-line-format))
	(setq my-helm-bottom-buffers
	  (cl-loop for w in (window-list)
		   when (window-at-side-p w 'bottom)
		   collect (with-current-buffer (window-buffer w)
				 (cons (buffer-name) mode-line-format)))))

  (defun my-helm-bottom-buffers-hide-mode-line ()
	(setq-default cursor-in-non-selected-windows nil)
	(mapc (lambda (elt)
		(with-current-buffer (car elt)
		  (setq-local mode-line-format nil)))
	  my-helm-bottom-buffers))

  (defun my-helm-bottom-buffers-show-mode-line ()
	(setq-default cursor-in-non-selected-windows t)
	(when my-helm-bottom-buffers
	  (mapc (lambda (elt)
		  (with-current-buffer (car elt)
		(setq-local mode-line-format (cdr elt))))
		my-helm-bottom-buffers)
	  (setq my-helm-bottom-buffers nil)))

  (defun my-helm-keyboard-quit-advice (orig-func &rest args)
	(my-helm-bottom-buffers-show-mode-line)
	(apply orig-func args))

  (add-hook 'helm-before-initialize-hook #'my-helm-bottom-buffers-init)
  (add-hook 'helm-after-initialize-hook #'my-helm-bottom-buffers-hide-mode-line)
  (add-hook 'helm-exit-minibuffer-hook #'my-helm-bottom-buffers-show-mode-line)
  (add-hook 'helm-cleanup-hook #'my-helm-bottom-buffers-show-mode-line)
  (advice-add 'helm-keyboard-quit :around #'my-helm-keyboard-quit-advice)
#+END_SRC
***** Hide Minibuffer
Hide minibuffer while helm is active

#+BEGIN_SRC emacs-lisp
  (defun my-helm-hide-minibuffer-maybe ()
	(when (with-helm-buffer helm-echo-input-in-header-line)
	  (let ((ov (make-overlay (point-min) (point-max) nil nil t)))
	(overlay-put ov 'window (selected-window))
	(overlay-put ov 'face (let ((bg-color (face-background 'default nil)))
				`(:background ,bg-color :foreground ,bg-color)))
	(setq-local cursor-type nil))))
  (add-hook 'helm-minibuffer-set-up-hook #'helm-hide-minibuffer-maybe)
#+END_SRC
***** Helm packages
****** Helm ag
#+begin_src emacs-lisp
  (use-package helm-ag  
    :load-path "~/.emacs.d/.local/elisp/emacs-helm-ag"
    :commands (helm-ag helm-ag-buffers helm-ag-this-file helm-do-ag helm-ag-project-root cpm/helm-files-do-ag cpm/helm-files-search-current-directory)
    :custom
    (helm-follow-mode-persistent t)
    :config
    (setq helm-ag-base-command "rg --no-heading")
    (setq helm-ag-fuzzy-match t))
#+end_src
****** Helm descbinds
#+begin_src emacs-lisp 
(use-package helm-descbinds 
  :commands helm-descbinds
  :config
  (setq helm-descbinds-window-style 'same-window)
  (add-hook 'helm-mode-hook 'helm-descbinds-mode))
#+end_src
****** Helm git list
#+begin_src emacs-lisp
(use-package helm-ls-git :commands helm-ls-git-ls)
#+end_src
****** Helm hunks
#+BEGIN_SRC emacs-lisp
  (use-package helm-hunks :commands helm-hunks)

#+END_SRC
****** Helm swoop
[[https://github.com/ShingoFukuyama/helm-swoop][Search]] on steroids
#+begin_src emacs-lisp
  (use-package helm-swoop
    :commands (helm-swoop-without-pre-input helm-swoop-back-to-last-point helm-multi-swoop helm-multi-swoop-all)
    :load-path "~/.emacs.d/.local/elisp/helm-swoop/"
    :config
    (setq helm-swoop-use-fuzzy-match t)
    (setq helm-swoop-split-with-multiple-windows t))
#+end_src
****** DISABLED Helm flyspell
CLOSED: [2018-04-16 Mon 15:08]

Use helm with flyspell
#+begin_src emacs-lisp 
  (use-package helm-flyspell
    :disabled t
    ;; :if (not noninteractive)
    :commands helm-flyspell-correct
    :after flyspell
    :demand t
    :config
    (general-define-key :keymaps 'flyspell-mode-map
       "C-;" 'helm-flyspell-correct))
#+end_src
****** Helm recent directories
Recent directories
#+begin_src emacs-lisp
(use-package helm-dired-recent-dirs
    :commands helm-dired-recent-dirs-view)
#+end_src
****** Helm files
#+begin_src emacs-lisp 
  (use-package helm-files
    :ensure nil
    :defer t
    :config
    (setq helm-ff-skip-boring-files t)
    (setq helm-idle-delay 0.05)
    (setq helm-input-idle-delay 0.05)
    (setq helm-ff-file-name-history-use-recentf t)
    (setq helm-boring-file-regexp-list
    '("\\.git$" "\\.hg$" "\\.svn$" "\\.CVS$" "\\._darcs$" "\\.la$" "\\.o$" "~$"
      "\\.so$" "\\.a$" "\\.elc$" "\\.fas$" "\\.fasl$" "\\.pyc$" "\\.pyo$")))
#+end_src
****** Helm interface for themes (helm-themes)
#+begin_src emacs-lisp
  (use-package helm-themes
    :commands helm-themes)
  (defadvice helm-themes--load-theme (after helm-themes--load-theme-after activate) (require 'powerline) (powerline-reset)) 
  ;; (ad-unadvise 'helm-themes--load-theme)
#+end_src
****** Helm Projectile
#+BEGIN_SRC emacs-lisp
(use-package helm-projectile
 :commands (helm-projectile-switch-to-buffer
            helm-projectile-find-dir
            helm-projectile-dired-find-dir
            helm-projectile-recentf
            helm-projectile-find-file
            helm-projectile-grep
            helm-projectile
            helm-projectile-switch-project)
 :init
 (setq projectile-switch-project-action 'helm-projectile)
 :config 
 (helm-projectile-on))

#+END_SRC
**** Ivy
Generic completion frontend that's similar to helm but less enormous of a code base. Let's install and enable it.

#+BEGIN_SRC emacs-lisp 
(use-package ivy 
  :diminish ivy-mode
  :general
  (:keymaps 'ivy-minibuffer-map
    "C-j" 'ivy-next-line
    "C-k" 'ivy-previous-line)
  :config
  (setq ivy-use-virtual-buffers t
        ;; number of result lines to display
        ivy-height 10
        ;; no regexp by default
        ivy-initial-inputs-alist nil
        ivy-re-builders-alist
        ;; allow input not in order
        '((t   . ivy--regex-ignore-order))
        ivy-count-format "%d/%d "))
#+END_SRC
**** Counsel
Counsel allows us to utilize ivy by replacing many built-in and common functions
with richer versions. 

#+BEGIN_SRC emacs-lisp 
(use-package counsel-projectile :commands counsel-projectile-bookmark)
(use-package counsel
  :commands (council-org-goto jump-in-buffer)
  :config
  (map! (:map counsel-mode-map
         :ni "C-j" #'ivy-next-line
         :ni "C-k" #'ivy-previous-line)))

#+END_SRC
**** Swiper
Swiper is an awesome searching utility with a quick preview. Let's install it and
load it when =swiper= or =swiper-all= is called.

#+BEGIN_SRC emacs-lisp
(use-package swiper
  :commands (swiper swiper-all))
#+END_SRC
**** Historian
Completion [[https://github.com/PythonNut/historian.el][history]]
#+BEGIN_SRC emacs-lisp
(use-package historian
  :defer 5
  :load-path "~/.emacs.d/.local/elisp/historian"
  :config
  (setq historian-save-file (concat cpm-cache-dir ".historian"))
  (historian-mode 1))
#+END_SRC
**** Saveplace
#+BEGIN_SRC emacs-lisp
  (use-package saveplace
    :init
    (save-place-mode 1)
    :config
    (setq save-place-file (concat cpm-cache-dir "saved-places")
    ;; (setq save-place-forget-unreadable-files nil)
  ))
#+END_SRC
**** Ace Window
Ace [[https://github.com/abo-abo/ace-window][window management]]. 
#+BEGIN_SRC emacs-lisp
(use-package ace-window
  :commands (ace-window ace-swap-window aw-flip-window cpm/swap-windows))
#+END_SRC
**** Avy
#+BEGIN_SRC emacs-lisp
(use-package avy
  :commands (avy-goto-char))
#+END_SRC
**** Windows
***** Golden Ratio
Automatic resizing of Emacs windows to the [[https://github.com/roman/golden-ratio.el][golden ratio]]
#+BEGIN_SRC emacs-lisp
  (use-package golden-ratio
    :load-path "~/.emacs.d/.local/elisp/golden-ratio.el/"
    :ensure nil
    :after (:any perspective helm nameframe projectile) 
    :demand t
    :config
    ;; inhibit in helm windows
    (defun pl/helm-alive-p ()
    (if (boundp 'helm-alive-p)
        (symbol-value 'helm-alive-p)))

        (add-to-list 'golden-ratio-inhibit-functions 'pl/helm-alive-p)
    (setq golden-ratio-extra-commands
          (append golden-ratio-extra-commands
                  '(evil-window-left
                    evil-window-right
                    evil-window-up
                    evil-window-down
                    buf-move-left
                    buf-move-right
                    buf-move-up
                    buf-move-down
                    window-number-select
                    select-window
                    select-window-1
                    select-window-2
                    select-window-3
                    select-window-4
                    select-window-5
                    select-window-6
                    select-window-7
                    select-window-8
                    select-window-9
                    previous-multiframe-window
                    magit-status)))
    (golden-ratio-mode 1))
#+END_SRC
***** Window Numbering
Numbered window shortcuts for Emacs
#+BEGIN_SRC emacs-lisp
   (use-package window-numbering
     :defer 1
     :config
     (defun window-numbering-install-mode-line (&optional position)
     "Do nothing, the display is handled by the powerline.")
     (setq window-numbering-auto-assign-0-to-minibuffer nil)
     
     (window-numbering-mode 1)

  ;; make sure neotree is always 0
   (defun spacemacs//window-numbering-assign ()
     "Custom number assignment for neotree."
     (when (and (boundp 'neo-buffer-name)
                (string= (buffer-name) neo-buffer-name)
                ;; in case there are two neotree windows. Example: when
                ;; invoking a transient state from neotree window, the new
                ;; window will show neotree briefly before displaying the TS,
                ;; causing an error message. the error is eliminated by
                ;; assigning 0 only to the top-left window
                (eq (selected-window) (window-at 0 0)))
       0))

   ;; using lambda to work-around a bug in window-numbering, see
   ;; https://github.com/nschum/window-numbering.el/issues/10
   (setq window-numbering-assign-func
         (lambda () (spacemacs//window-numbering-assign))))
#+END_SRC
***** Unset window keys
A nice tip from [[http://pragmaticemacs.com/emacs/use-your-digits-and-a-personal-key-map-for-super-shortcuts/][Pragmatic emacs]]
#+BEGIN_SRC emacs-lisp
;; unset C- and M- digit keys
(dotimes (n 10)
  (global-unset-key (kbd (format "C-%d" n)))
  (global-unset-key (kbd (format "M-%d" n)))
  )
#+END_SRC
***** Windmove
#+BEGIN_SRC emacs-lisp
(use-package windmove
  :commands (windmove-up windmove-down windmove-left windmove-right)
  :config
  (defun cpm/split-window-right-and-focus ()
  "Split the window horizontally and focus the new window."
  (interactive)
  (split-window-right)
  (windmove-right))
  (defun cpm/split-window-below-and-focus ()
  "Split the window vertically and focus the new window."
  (interactive)
  (split-window-below)
  (windmove-down))
  ;; add edit mode keybindings
  (global-set-key (kbd "<H-up>")     'windmove-up)
  (global-set-key (kbd "<H-down>")   'windmove-down)
  (global-set-key (kbd "<H-left>")   'windmove-left)
  (global-set-key (kbd "<H-right>")  'windmove-right)
  )
#+END_SRC
***** Winner
Winner mode is a [[https://www.emacswiki.org/emacs/WinnerMode][built-in package]] for restoring window configurations
#+BEGIN_SRC emacs-lisp
(use-package winner
 :ensure nil
 :defer 5
 :commands (winner-undo winner-redo winner-mode)
 :config
 (winner-mode 1))
#+END_SRC
**** Ranger & Deer
Better dired navigation using ranger-like settings
#+BEGIN_SRC emacs-lisp
  (use-package ranger
    :commands (ranger deer deer-jump-other-window cpm/deer-split-window)
    :init
    (setq ranger-override-dired t
          ranger-cleanup-eagerly t)
    ;; set up image-dired to allow picture resize
    (setq image-dired-dir (concat cpm-cache-dir "image-dir"))
    (unless (file-directory-p image-dired-dir)
      (make-directory image-dired-dir t))
    :config
    (setq  ranger-dont-show-binary t
           ranger-excluded-extensions '("mkv" "iso" "mp4" "png")
           ranger-max-preview-size 10
           ranger-preview-file t
           ranger-show-dotfiles t
           ranger-width-parents 0.25
           ranger-width-preview 0.55 
           ))

  (defun cpm/deer-split-window ()
   "Launch deer in vertical split"
   (interactive)
   (if (= (length (window-list)) 1)
     (progn
     (cpm/split-window-right-and-focus)
     (deer))
    (deer-jump-other-window)))

  ;; (defun deer-jump-other-window (&optional path)
  ;;   "Launch dired in a minimal ranger window in other window."
  ;;   (interactive)
  ;;   (switch-to-buffer-other-window (current-buffer))
  ;;   (deer path))

#+END_SRC
**** Recent files
#+BEGIN_SRC emacs-lisp
  (use-package recentf
    :commands (helm-recentf)
    :config 
    (setq recentf-save-file (concat cpm-etc-dir "recentf"))
    ;; remove agenda files from list.
    (setq recentf-exclude '("projects.org"
                            "inbox.org"
                            "someday.org"
                            "bookmark")
          recentf-max-saved-items 300
          recentf-max-menu-items 10))
#+END_SRC

 

*** Other UI
**** Diminish Modes
 Tidy Up modeline modes.
 #+BEGIN_SRC emacs-lisp
   (use-package diminish
     :commands (diminish diminish-modes))
 #+END_SRC
***** Diminish minor modes
 #+BEGIN_SRC emacs-lisp
   (eval-after-load "flyspell" '(diminish 'flyspell-mode "Ⓢ")) 
   (eval-after-load "abbrev" '(diminish 'abbrev-mode "Ⓐ"))
   (eval-after-load "lispy" '(diminish 'lispy-mode "")) 
   (eval-after-load "lispyville" '(diminish 'lispyville-mode "Ⓛ")) 
   (eval-after-load "centered-window-mode" '(diminish 'centered-window-mode "⦿"))
   (eval-after-load "org-indent" '(diminish 'org-indent-mode))
   (eval-after-load "simple" '(diminish 'auto-fill-function "Ⓕ")) 
   (eval-after-load "pandoc-mode" '(diminish 'pandoc-mode "Ⓟ"))
   (eval-after-load "git-gutter+" '(diminish 'git-gutter+-mode))
   (eval-after-load "company" '(diminish 'company-mode "Ⓒ"))
   (eval-after-load "cm-mode" '(diminish 'cm-mode "ⓒ"))
   (eval-after-load "reftex" '(diminish 'reftex-mode "ⓡ"))
   (eval-after-load "autorevert" '(diminish 'auto-revert-mode "Ⓡ"))
   (eval-after-load "simple" '(diminish 'auto-revert-mode "Ⓡ"))
   (eval-after-load "aggressive-indent" '(diminish 'aggressive-indent-mode "Ⓘ"))
   (eval-after-load "auto-indent-mode" '(diminish 'auto-indent-mode "ⓘ"))
   (eval-after-load "smartparens" '(diminish 'smartparens-mode "ⓟ"))
   (eval-after-load "org-zotxt" '(diminish 'org-zotxt-mode ""))
   (eval-after-load "back-button" '(diminish 'back-button-mode ""))
   ;; (eval-after-load "undo-tree" '(diminish 'undo-tree-mode "Ⓤ"))
   (eval-after-load "undo-tree" '(diminish 'undo-tree-mode ""))
   (eval-after-load "projectile" '(diminish 'projectile-mode ""))
   (eval-after-load "helm" '(diminish 'helm-mode ""))
   #+END_SRC

**** Centered Cursor Mode
 Keep the cursor centered in the screen
 #+BEGIN_SRC emacs-lisp
     (use-package centered-cursor-mode
       :diminish centered-cursor-mode
       :hook 
       ((markdown-mode) . centered-cursor-mode)
       :commands (centered-cursor-mode
                  global-centered-cursor-mode)
       :config
       (progn
         (setq ccm-recenter-at-end-of-file t
               ccm-ignored-commands '(mouse-drag-region
                                      mouse-set-point
                                      widget-button-click
                                      scroll-bar-toolkit-scroll
                                      evil-mouse-drag-region))))
 #+END_SRC
 
**** Namespaced Keybindings
I use a lot of keybindings, with <SPC> as my "leader" key.
***** Application Keybindings
#+BEGIN_SRC emacs-lisp
(general-define-key
  :states '(normal motion visual insert emacs)
  :keymaps 'override
  :prefix "SPC"
  :non-normal-prefix "C-SPC"
 
  "a"  '(:ignore t :which-key "Applications") 
  "ac" '(:ignore t :which-key "Cmus")
  "ad" 'deer
  "ae" 'eshell
  "am" 'multi-term
  "ar" 'ranger
  "as" 'sane-term
  "aw" 'wttrin
  )
#+END_SRC
***** Buffer Keybindings
#+BEGIN_SRC emacs-lisp
(general-define-key
  :states '(normal motion visual insert emacs)
  :keymaps 'override
  :prefix "SPC"
  :non-normal-prefix "C-SPC"

  "b"  '(:ignore t :which-key "Buffers")
  "bb" 'helm-mini
  "bc" 'cpm/copy-whole-buffer-to-clipboard
  "bD" 'kill-buffer-and-window
  "bd" 'kill-this-buffer
  "be" 'erase-buffer
  "bf" 'cpm/browse-file-directory
  "bj" 'cpm/jump-in-buffer 
  "bk" 'evil-delete-buffer
  "bK" 'crux-kill-other-buffers
  "bn" 'evil-buffer-new
  "br" 'revert-buffer
  "bR" 'crux-rename-buffer-and-file
  "bt" 'open-dir-in-iterm
  )
#+END_SRC
***** Comment Keybindings
#+BEGIN_SRC emacs-lisp
(general-define-key
  :states '(normal motion visual insert emacs)
  :keymaps 'override
  :prefix "SPC"
  :non-normal-prefix "C-SPC"

  "c"  '(:ignore t :which-key "Commenting")
  "cb" 'org-block-wrap
  "cc" 'evil-commentary
  "cl" 'evil-commentary-line
  "cy" 'evil-commentary-yank-line
 )
#+END_SRC
***** Config Keybindings
#+BEGIN_SRC emacs-lisp
(general-define-key
  :states '(normal motion visual insert emacs)
  :keymaps 'override
  :prefix "SPC"
  :non-normal-prefix "C-SPC"

  "C"  '(:ignore t :which-key "Config")
  "Cc" 'goto-config.org
  "Cd" 'goto-dotfiles.org
  "CD" 'goto-emacs-dir
  "Ck" 'cpm/compile-dotemacs
  "CK" 'cpm/delete-byte-compiled-files
  "Cl" 'load-config
  "Ci" 'goto-init.el
  "Co" 'goto-org-files
  "Cs" 'goto-custom.el
  )

#+END_SRC
***** File Keybindings
#+BEGIN_SRC emacs-lisp
(general-define-key
  :states '(normal motion visual insert emacs)
  :keymaps 'override
  :prefix "SPC"
  :non-normal-prefix "C-SPC"

    "f"  '(:ignore t :which-key "Files")
    "fd" 'fzf-directory
    "ff" 'helm-find-files
    "fl" 'helm-locate
    "fo" 'crux-open-with
    "fs" 'save-buffer
    "fr" 'helm-recentf
    "fy" 'spacemacs/show-and-copy-buffer-filename
    "fz" 'fzf
    )
#+END_SRC
***** General Keybindings
#+BEGIN_SRC emacs-lisp
  (general-define-key
   :states '(normal motion visual insert emacs)
   :keymaps 'override
   :prefix "SPC"
   :non-normal-prefix "C-SPC"

     "A" 'helm-apropos
     "B" #'cpm/dashboard
     "?" 'helm-descbinds
     "<SPC>" 'helm-M-x
     "d" #'deer
     ;; "D" #'dired-jump-other-window
     "D" #'cpm/deer-split-window
     "E" 'cpm/call-emacs
     "e" 'server-edit
     "G" 'general-describe-keybindings
     "h" 'helm-resume
     "j" 'avy-goto-char
     "k" 'helm-show-kill-ring
     "l" 'repeat
     "N" 'research-notes
     "n" 'big-notes
     ;; "W" 'woman
     "`" 'beacon-blink
     "'" 'shell-pop
     "." 'quick-commit
     ";" 'evil-commentary-line
     "[" 'cpm/previous-user-buffer
     "]" 'cpm/next-user-buffer
     "TAB" 'switch-to-previous-buffer
     )
#+END_SRC
***** Make/Compile Keybindings
#+BEGIN_SRC emacs-lisp
(general-define-key
  :states '(normal motion visual insert emacs)
  :keymaps 'override
  :prefix "SPC"
  :non-normal-prefix "C-SPC"

  "M"   '(:ignore t :which-key "Make/Compile")
  "Mm"  'compile
  "Me"  'compile-goto-error
  "Mk"  'kill-compilation
  "Mr"  'recompile
  "Mv"  'cpm/make-move
)
#+END_SRC
***** Markdown Keybindings
#+BEGIN_SRC emacs-lisp
  (general-define-key
    :states '(normal motion)
    :keymaps 'markdown-mode-map
    :prefix "SPC m" 
    :non-normal-prefix "C-SPC m"

    ""    '(nil :which-key "Local Leader")
    "c"  '(:ignore t :which-key "command")
    "h"  '(:ignore t :which-key "insert")
    "i"  '(:ignore t :which-key "lists")
    "x"  '(:ignore t :which-key "text")

    ;; Movement
    "{"   'markdown-backward-paragraph
    "}"   'markdown-forward-paragraph

    ;; Completion, and Cycling
    "]"   'markdown-complete

    ;; Indentation
    ">"   'markdown-indent-region
    "<"   'markdown-exdent-region

    ;; Buffer-wide commands
    "c]"  'markdown-complete-buffer
    "cc"  'markdown-check-refs
    "ce"  'markdown-export
    "cm"  'markdown-other-window
    "cn"  'markdown-cleanup-list-numbers
    "co"  'markdown-open
    "cp"  'markdown-preview
    "cv"  'markdown-export-and-preview
    "cw"  'markdown-kill-ring-save

    ;; headings
    "hi"  'markdown-insert-header-dwim
    "hI"  'markdown-insert-header-setext-dwim
    "h1"  'markdown-insert-header-atx-1
    "h2"  'markdown-insert-header-atx-2
    "h3"  'markdown-insert-header-atx-3
    "h4"  'markdown-insert-header-atx-4
    "h5"  'markdown-insert-header-atx-5
    "h6"  'markdown-insert-header-atx-6
    "h!"  'markdown-insert-header-setext-1
    "h@"  'markdown-insert-header-setext-2

    ;; Insertion of common elements
    "-"   'markdown-insert-hr
    "if"  'markdown-insert-footnote
    "ii"  'markdown-insert-image
    "ik"  'spacemacs/insert-keybinding-markdown
    "iI"  'markdown-insert-reference-image
    "il"  'markdown-insert-link
    "iL"  'markdown-insert-reference-link-dwim
    "iw"  'markdown-insert-wiki-link
    "iu"  'markdown-insert-uri

    ;; Element removal
    "k"   'markdown-kill-thing-at-point

    ;; Numbering
    "n"   #'markdown-cleanup-list-numbers
    ;; List editing
    "li"  'markdown-insert-list-item

    ;; region manipulation
    "xb"  'markdown-insert-bold
    "xi"  'markdown-insert-italic
    "xc"  'markdown-insert-code
    "xC"  'markdown-insert-gfm-code-block
    "xq"  'markdown-insert-blockquote
    "xQ"  'markdown-blockquote-region
    "xp"  'markdown-insert-pre
    "xP"  'markdown-pre-region

    ;; Following and Jumping
    "N"   'markdown-next-link
    "f"   'markdown-follow-thing-at-point
    "P"   'markdown-previous-link
    "<RET>" 'markdown-do

    "gj"    #'markdown-next-visible-heading
    "gk"    #'markdown-previous-visible-heading
    ;; Assumes you have a markdown renderer plugin in chrome
    "M-r"   #'browse-url-of-file
    "h]"    #'markdown-next-visible-heading
    "h["    #'markdown-previous-visible-heading
    "p["    #'markdown-promote
    "p]"    #'markdown-demote
    "l["    #'markdown-next-link
    "l]"    #'markdown-previous-link
   ) 

  (general-define-key
    :states '(normal motion insert)
    :keymaps 'markdown-mode-map

    "s-*"      #'markdown-insert-list-item
    "s-b"      #'markdown-insert-bold
    "s-i"      #'markdown-insert-italic

    "M--"      #'markdown-insert-hr
    "TAB"      #'markdown-cycle
    "M-h"      #'markdown-promote
    "M-j"      #'markdown-move-down
    "M-k"      #'markdown-move-up
    "M-l"      #'markdown-demote

    "M-<up>"   #'markdown-move-list-item-up
    "M-<down>" #'markdown-move-list-item-down

    )

#+END_SRC
***** Miscellaneous Keybindings
#+BEGIN_SRC emacs-lisp
;; Show which-key top-level bindings
(global-set-key (kbd "H-k") 'which-key-show-top-level)
;; override evil insert for kill line
(general-define-key :states '(insert) "C-k" 'kill-line)
#+END_SRC
***** Package  Keybindings
Keybindings for managing packages
#+BEGIN_SRC emacs-lisp
(general-define-key
  :states '(normal motion visual insert emacs)
  :keymaps 'override
  :prefix "SPC"
  :non-normal-prefix "C-SPC"

    "P" '(:ignore t :which-key "Packages")
    "Pl" 'paradox-list-packages
    "Pu" 'paradox-upgrade-packages
    "Pc" 'finder-commentary
    )
#+END_SRC
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-h C-c") 'finder-commentary)
#+END_SRC
***** Project Keybindings
#+BEGIN_SRC emacs-lisp
  (general-define-key
    :states '(normal visual emacs)
    :keymaps 'override
    :prefix "SPC"
    :non-normal-prefix "C-SPC"

      "p" '(:ignore t :which-key "Projects")
      "p!"  'projectile-run-shell-command-in-root
      "p&"  'projectile-run-async-shell-command-in-root
      "pa"  'projectile-toggle-between-implementation-and-test
      "pb"  'helm-projectile-switch-to-buffer
      "pc"  'projectile-compile-project
      "pC"  'desktop+-create
      "pd"  'helm-projectile-find-dir
      "pD"  'cpm/hydra-desktop
      ;; "pD"  'projectile-dired
      "pf"  'helm-projectile-find-file
      "pF"  #'cpm/helm-projectile-find-file-other-window
      "pg"  'cpm/goto-projects
      "ph"  'helm-projectile
      "pJ"  'bmkp-desktop-jump
      "pG"  'projectile-regenerate-tags
      "pI"  'projectile-invalidate-cache
      "pk"  'projectile-kill-buffers
      ;; "pl"  'desktop+-load
      "po"  'projectile-multi-occur
      "pp"  'helm-projectile-switch-project
      "pP"  'projectile-persp-switch-project
      ;; "pp"  'helm-persp-projectile-switch-project
      "pr"  'helm-projectile-recentf
      "pR"  'projectile-replace
      "pS"  'persp-switch
      "ps"  '(:ignore t :which-key "Frames")
      "pss"  'nameframe-switch-frame
      "ps1" #'cpm/load-phil101
      "ps2" #'cpm/load-phil232
      "ps5" #'cpm/load-phil105
      "ps8" #'cpm/load-phil871
      "psa" #'cpm/load-kant-apperception-substance
      "psb" #'cpm/load-kant-agency-book
      "psc" #'cpm/load-emacs-config
      "psf" #'cpm/load-kant-free-thought
      "pso" #'cpm/load-org-agenda-todo
      "psr" #'cpm/load-kant-reflection
      "pT"  'projectile-find-test-file
      "pv"  'hydra-persp/body
      "pV"  'projectile-vc
      "py"  'projectile-find-tag
    )
#+END_SRC
***** Quit Keybindings
#+BEGIN_SRC emacs-lisp
 (general-define-key
  :states '(normal motion visual insert emacs)
  :keymaps 'override
  :prefix "SPC"
  :non-normal-prefix "C-SPC"
 
    "q"  '(:ignore t :which-key "Quit")
    "qq" 'cpm/save-desktop-save-buffers-kill-emacs
    "qQ" 'evil-quit-all
    "qr" 'restart-emacs
    )
#+END_SRC
***** Search Keybindings
#+BEGIN_SRC emacs-lisp
 (general-define-key
  :states '(normal motion visual insert emacs)
  :keymaps 'override
  :prefix "SPC"
  :non-normal-prefix "C-SPC"
 
    "s" '(:ignore t :which-key "Search")
    "sa" 'helm-org-rifle-agenda-files
    "sd" 'cpm/helm-files-search-current-directory ; search current buffer's directory
    "sD" 'cpm/helm-files-do-ag ; search with directory input
    "sb" 'helm-ag-buffers
    "sf" 'helm-do-ag-this-file
    "sj" 'cpm/forward-or-backward-sexp
    "sk" 'helm-show-kill-ring
    "sl" 'last-search-buffer
    "so" 'helm-occur
    "sp" 'helm-ag-project-root
    "sr" 'helm-org-rifle
    "ss" 'helm-swoop-without-pre-input ;; search with swoop in file
    "sS" #'cpm/flyspell-ispell-goto-next-error ;; search for next spelling error
    "st" #'cpm/search-file-todo-markers ;; search for TODOs in file w/helm-ag
    "sT" #'cpm/search-todo-markers ;; search todo markers in directory w/helm-ag
    "/"  'cpm/helm-files-search-current-directory   ;; search in directory with word prompt
     )
#+END_SRC


***** Toggle Keybindings
#+BEGIN_SRC emacs-lisp
  (general-define-key
    :states '(normal motion visual insert emacs)
    :keymaps 'override
    :prefix "SPC"
    :non-normal-prefix "C-SPC"

      "t"  '(:ignore t :which-key "Toggles")
      "ta" 'company-mode
      "tb" 'buffer-line-mode
      "tB" 'beacon-mode
      "tc" 'centered-cursor-mode
      "tC" 'centered-window-mode
      "td" 'cpm/osx-toggle-menubar-theme
      "tf" 'toggle-serif
      "tF" 'toggle-frame-maximized
      "tg" 'git-gutter-mode
      "tG" 'golden-ratio-mode 
      "th" 'hl-line-mode
      "te" 'toggle-indicate-empty-lines
      "tE" 'eldoc-mode
      "tm" 'hidden-mode-line-mode
      "tM" 'spaceline-toggle-minor-modes
      ;; "tn" 'nlinum-mode
      "tn" 'display-line-numbers-mode
      "tN" 'org-numbers-overlay-mode
      "to" 'org-toggle-link-display
      "tO" 'outline-toc-mode
      "tp" 'smartparens-mode
      "tP" 'show-paren-mode 
      "tr" 'rainbow-identifiers-mode
      "ts" 'ispell-buffer
      "tS" 'flyspell-mode
      "tt" 'toggle-dark-light-theme
      "tT" 'helm-themes
      "tw" 'writeroom-mode
      "tz" 'zone
      ;; "tt" 'counsel-load-theme
    )
#+END_SRC
***** User Keybindings
#+BEGIN_SRC emacs-lisp
  (general-define-key
    :states '(normal motion visual insert emacs)
    :keymaps 'override
    :prefix "SPC"
    :non-normal-prefix "C-SPC"

      "u"  '(:ignore t :which-key "User")
      "uA" '(:ignore r which-key "Agenda Files")
      "uAa" #'cpm/goto-articles.org
      "uAc" #'cpm/goto-classes.org
      "uAf" #'cpm/goto-org-files
      "uAi" #'cpm/goto-inbox.org
      "uAn" #'cpm/goto-notes.org
      "uAp" #'cpm/goto-projects.org
      "uAs" #'cpm/goto-someday.org
      "uAt" #'cpm/org-goto-todo
      "ua" 'cpm/jump-to-org-agenda
      "um" 'cpm/org-to-markdown
      "uc" 'cpm/pandoc-convert-to-pdf
      "uC" 'cpm/pandoc-command-line-convert-to-pdf
      "ug" 'org-mac-grab-link
      "ui" 'cpm/org-goto-inbox
      "uk" 'kill-compilation
      "ul" 'desktop-read
      "uo" 'cpm/markdown-to-org
      "up" 'run-pandoc
      "uP" 'cpm/pandoc-pdf-open
      "ur" 'remember-notes
      "us" 'sb-expand-current-file
      "uS" 'just-one-space
      ;; "ut" 'cpm/org-goto-todo
      "ut" 'cpm/jump-to-org-agenda-all-todos
      "ud" 'distraction-free
      "uD" 'my-desktop
      "uj" 'cpm/goto-journal
      ;; "op" 'pandoc-convert-to-pdf
      "uw" 'count-words
      "uW" 'osx-dictionary-search-input
      "ux" 'helm-bibtex
      )
#+END_SRC
***** Version Control Keybindings
#+BEGIN_SRC emacs-lisp
(general-define-key
  :states '(normal motion visual insert emacs)
  :keymaps 'override
  :prefix "SPC"
  :non-normal-prefix "C-SPC"

  "g"  '(:ignore t :which-key "Git")
  "gb" 'magit-blame
  "gc" 'magit-commit
  "gd" 'magit-diff
  "gl" 'magit-log
  "gn" 'git-gutter:next-hunk
  "gp" 'git-gutter:previous-hunk
  "gr" 'magit-reflog
  "gs" 'magit-status
  )
#+END_SRC
***** Window Keybindings
#+BEGIN_SRC emacs-lisp
(general-define-key
  :states '(normal motion visual insert emacs)
  :keymaps 'override
  :prefix "SPC"
  :non-normal-prefix "C-SPC"

  "0" 'select-window-0
  "1" 'select-window-1
  "2" 'select-window-2
  "3" 'select-window-3
  "4" 'select-window-4
  "5" 'select-window-5

  "w"  '(:ignore t :which-key "Windows")
  "wa" 'ace-window
  "wf" 'cpm/toggle-window-split
  "wc" 'delete-window
  "wd" 'delete-window
  "wm" 'delete-other-windows
  "wr" 'cpm/rotate-windows
  "wR" 'cpm/rotate-windows-backward
  "wu" 'winner-undo
  "wU" 'winner-redo
  "wv" 'cpm/split-window-right-and-focus
  "wV" 'evil-window-vsplit
  "wx" 'cpm/window-exchange
  "w-" 'evil-window-split
  "w_" 'cpm/split-window-below-and-focus
  )
#+END_SRC
***** Wiki Keybindings
#+BEGIN_SRC emacs-lisp
(general-define-key
  :states '(normal motion visual insert emacs)
  :keymaps 'override
  :prefix "SPC"
  :non-normal-prefix "C-SPC"

    "W" '(:ignore t :which-key "Wiki")
    "Wc" 'org-wiki-close
    "Wd" 'org-wiki-dired-all
    "Wk" 'org-wiki-close
    "Wh" 'org-wiki-helm
    "WH" 'org-wiki-help
    "WI" 'org-wiki-index
    "Wi" 'org-wiki-insert
    "Wl" 'org-wiki-link
    "Wm" 'org-wiki-make-page
    "Wv" 'org-wiki-server-toggle
    "We" 'org-wiki-export-html
    "Wp" 'org-wiki-panel
    "Ws" 'org-wiki-search
    "Wt" 'org-wiki-header
  )
#+END_SRC
***** Zotero Keybindings 
#+BEGIN_SRC emacs-lisp
(general-define-key
  :states '(normal motion visual insert emacs)
  :keymaps 'override
  :prefix "SPC"
  :non-normal-prefix "C-SPC"

  "z" '(:ignore t :which-key "Zotero")
  "za" 'org-zotxt-open-attachment
  "zi" 'org-zotxt-insert-reference-link
  "zu" 'org-zotxt-update-reference-link-at-point
)
#+END_SRC

**** Smooth Scrolling
 #+BEGIN_SRC emacs-lisp
  ;; Keyboard smooth scrolling: Prevent the awkward "snap to re-center" when
   ;; the text cursor moves off-screen. Instead, only scroll the minimum amount
   ;; necessary to show the new line. (A number of 101+ disables re-centering.)
   (setq scroll-conservatively 101)

   ;; Optimize mouse wheel scrolling for smooth-scrolling trackpad use.
   ;; Trackpads send a lot more scroll events than regular mouse wheels,
   ;; so the scroll amount and acceleration must be tuned to smooth it out.
   (setq
    ;; If the frame contains multiple windows, scroll the one under the cursor
    ;; instead of the one that currently has keyboard focus.
    mouse-wheel-follow-mouse 't
    ;; Completely disable mouse wheel acceleration to avoid speeding away.
    mouse-wheel-progressive-speed nil
    ;; The most important setting of all! Make each scroll-event move 2 lines at
    ;; a time (instead of 5 at default). Simply hold down shift to move twice as
    ;; fast, or hold down control to move 3x as fast. Perfect for trackpads.
    mouse-wheel-scroll-amount '(2 ((shift) . 4) ((control) . 6)))
 #+END_SRC
**** Which-key
 #+BEGIN_SRC emacs-lisp
 (use-package which-key
   :demand t
   :diminish ""
   :config
   (setq which-key-special-keys nil)
   ;; Set the time delay (in seconds) for the which-key popup to appear.
   (setq which-key-idle-delay .3)
   (which-key-mode))
 #+END_SRC
**** Doom-Quit
 Quit prompt with messages from Doom exit messages

 #+BEGIN_SRC emacs-lisp
 (defun doom-quit-p (&optional prompt)
   "Return t if this session should be killed. Prompts the user for
 confirmation."
 (or (yes-or-no-p (format "››› %s" (or prompt "Quit Emacs?")))
     (ignore (message "Aborted"))))
 (setq confirm-kill-emacs nil)
 (add-hook 'kill-emacs-query-functions #'doom-quit-p)
 #+END_SRC


 #+BEGIN_SRC emacs-lisp
 (defvar +doom-quit-messages
   '(;; from Doom 1
     "Let's beat it -- This is turning into a bloodbath!"
     "I wouldn't leave if I were you. DOS is much worse."
     "Ya know, next time you come in here I'm gonna toast ya."
     "Go ahead and leave. See if I care."
     "Are you sure you want to quit this great editor?"
     ;; Custom
     "Emacs! Emacs!! Emacs!!!"
     "The King is dead, long live the King!"
     "Like you have somewhere better to be..."
     "Don't worry, I won't tell everyone you're a failure"
     "Aus so krummem Holze, als woraus der Mensch gemacht ist, kann nichts ganz Gerades gezimmert werden"
     "(setq nothing t everything 'permitted)"
     "Emacs will remember that."
     "Emacs, Emacs never changes."
     "Hey! Hey, M-x listen!"
     "Okay, look. We've both said a lot of things you're going to regret..."
     "You are *not* prepared!")
   "A list of quit messages, picked randomly by `+doom-quit'. Taken from
 http://doom.wikia.com/wiki/Quit_messages and elsewhere.")

 (defun +doom|quit (&rest _)
   (doom-quit-p
    (format "%s  Quit?"
            (nth (random (length +doom-quit-messages))
                 +doom-quit-messages))))

 (remove-hook 'kill-emacs-query-functions #'doom-quit-p)
 (add-hook 'kill-emacs-query-functions #'+doom|quit)
 #+END_SRC
**** Popup Windows
[[https://github.com/wasamasa/shackle][A package]] that puts an end to popped-up windows not behaving they way you'd like them to.

#+BEGIN_SRC emacs-lisp
  (use-package shackle
    :after helm
    :demand t
    :config
    ;; make helm pop-ups behave
    (setq helm-display-function #'pop-to-buffer)
    (setq shackle-rules '(("\\`\\*helm.*?\\*\\'" :regexp t :align t :ratio 0.46)))
    (shackle-mode 1))
#+END_SRC



**** Helpful (Documentation)
[[http://www.wilfred.me.uk/blog/2017/08/30/helpful-adding-contextual-help-to-emacs/][Contextual help]] for emacs
#+BEGIN_SRC emacs-lisp
(use-package helpful
  :config (evil-set-initial-state 'helpful-mode 'motion)
  :general
  ("C-h f" #'helpful-callable)
  ("C-h k" #'helpful-key)
  ("C-h v" #'helpful-variable)
  ("C-c C-." #'helpful-at-point)
  ("C-h C-l" #'find-library)
  :commands (helpful-function helpful-callable helpful-key helpful-variable helpful-at-point))
#+END_SRC


** Org Mode
The incomparable [[https://orgmode.org][org mode]]
#+BEGIN_SRC emacs-lisp
;; install org for bootstrapping config
(use-package org
  :commands (org-capture)
  :ensure org-plus-contrib)
#+END_SRC

*** Settings
**** New Org
Ensure ELPA org is prioritized above built-in org.
#+BEGIN_SRC emacs-lisp 
(setq load-path (remove-if (lambda (x) (string-match-p "org$" x)) load-path))
#+END_SRC
**** Org Directories 
     #+BEGIN_SRC emacs-lisp
     (setq org-directory "~/Dropbox/org-files")
     (setq org-default-notes-file (concat org-directory "/org-notes.org"))
     #+END_SRC
**** State Settings
     #+BEGIN_SRC emacs-lisp
     (setq org-todo-keywords
      '((sequence "TODO" "NEXT" "|" "DONE")
        (sequence "INPROGRESS" "WAITING(w@/!)" "|" "CANCELED" "INACTIVE")))
     #+END_SRC
**** Org Logging
     #+BEGIN_SRC emacs-lisp
    ; log timestamp when task is marked "DONE" or other finished keyword
    (setq org-log-done 'time)
     #+END_SRC
**** Org Babel Languages
#+BEGIN_SRC emacs-lisp
(with-eval-after-load 'org
(org-babel-do-load-languages
 'org-babel-load-languages
 '((python . t)
   (C . t)
   (calc . t)
   (latex . t)
   (java . t)
   (ruby . t)
   (lisp . t)
   (scheme . t)
   (shell . t)
   (sqlite . t)
   (js . t)))

(defun my-org-confirm-babel-evaluate (lang body)
  "Do not confirm evaluation for these languages."
  (not (or (string= lang "C")
           (string= lang "java")
           (string= lang "python")
           (string= lang "emacs-lisp")
           (string= lang "sqlite"))))
(setq org-confirm-babel-evaluate 'my-org-confirm-babel-evaluate))
#+END_SRC
**** Org Babel Source Blocks
#+BEGIN_SRC emacs-lisp
  (setq org-src-fontify-natively t
        org-src-window-setup 'other-window
        org-src-tab-acts-natively nil
        org-src-strip-leading-and-trailing-blank-lines t)
#+END_SRC

**** Org Config Settings
#+BEGIN_SRC emacs-lisp
  (setq-default 
        org-footnote-section nil ;; place footnotes locally rather than in own section
        org-return-follows-link t ;; make RET follow links
        org-list-allow-alphabetical t ;; allow alphabetical list
        org-hide-emphasis-markers t  ;; hide markers
        org-pretty-entities t ;; make latex look good
        org-pretty-entities-include-sub-superscripts t
        org-hide-leading-stars t
        org-refile-use-cache t  ;; use cache for org refile
        org-startup-folded t
        org-yank-adjusted-subtrees t  ;; adjust subtrees to depth when yanked
        org-yank-folded-subtrees t  ;; fold subtrees on yank
        org-M-RET-may-split-line '((default . nil))  ;; don't split line when creating a new headline, list item, or table field
        org-fontify-quote-and-verse-blocks t ;; make quotes stand out
        org-table-export-default-format "orgtbl-to-csv" ;; export for org-tables to csv
        ;; org-ellipsis "↷" ;; nicer elipses "↴" "▼"
        org-startup-indented t ;; start in indent mode
        org-imenu-depth 8
        imenu-auto-rescan t)
#+END_SRC
**** Org Modules
A list of org modules to load on startup
#+BEGIN_SRC emacs-lisp 
(setq org-modules (quote (org-bbdb org-docview org-bibtex org-gnus org-info org-irc org-mhe org-protocol org-rmail org-w3m org-git-link org-mac-iCal org-mac-link)))
#+END_SRC
**** Org ID
#+BEGIN_SRC emacs-lisp
(setq org-id-locations-file (concat cpm-cache-dir ".org-id-locations"))
#+END_SRC
**** Org Regex (Emphasis)
Per this [[https://emacs.stackexchange.com/questions/13820/inline-verbatim-and-code-with-quotes-in-org-mode][stack exchange]] discussion.
#+BEGIN_SRC emacs-lisp

(with-eval-after-load 'org
; chars for prematch
(setcar org-emphasis-regexp-components            "     ('\"{“”\[\\") 
; chars for postmatch
(setcar (nthcdr 1 org-emphasis-regexp-components) "\] -   .,!?;:''“”\")}/\\“”") 
; forbidden chars
(setcar (nthcdr 2 org-emphasis-regexp-components) "    \t\r\n,\"")
; body
(setcar (nthcdr 3 org-emphasis-regexp-components) ".")
; max newlines 
(setcar (nthcdr 4 org-emphasis-regexp-components) 1)
(org-set-emph-re 'org-emphasis-regexp-components org-emphasis-regexp-components))

#+END_SRC
**** Org Tags
Set tags
#+BEGIN_SRC emacs-lisp
(setq org-tag-persistent-alist 
        '(("@phone" . ?p) 
          ("@computer" . ?c) 
          ("@web" . ?w)
          ("@errands" . ?e)
          ("@house" . ?h)
          ("UNL" . ?u)
          ("CONTACTS" . ?C)
          ("INBOX" . ?i)
          ))
#+END_SRC
*** Org Archive
Tell org where to archive completed tasks
#+BEGIN_SRC emacs-lisp
(setq org-archive-location (concat org-directory "/org-archive/archived.org::datetree/"))
#+END_SRC

Also tell org how to archive all the done tasks (DONE or CANCELED) in a file.
From [[https://changelog.complete.org/archives/9877-emacs-3-more-on-org-mode][here]] based on a stack overflow [[https://stackoverflow.com/a/27043756][answer]]
#+BEGIN_SRC emacs-lisp
(defun cpm/org-archive-done-tasks ()
  (interactive)
  (org-map-entries
   (lambda ()
     (org-archive-subtree)
     (setq org-map-continue-from (outline-previous-heading)))
   "/DONE" 'file)
  (org-map-entries
   (lambda ()
     (org-archive-subtree)
     (setq org-map-continue-from (outline-previous-heading)))
   "/CANCELED" 'file)
)

#+END_SRC
*** Org Refile
Set refile settings.  I got a lot of help on this from [[https://blog.aaronbieber.com/2017/03/19/organizing-notes-with-refile.html][Aaron Bieber's discussion]].

With this set, you can trigger Refile with C-c C-w in any Org file and
get a completing read of all headings up to three levels deep in all
files in =org-agenda-files=. You can also refile to the top header in a
document and create new parents.
#+BEGIN_SRC emacs-lisp
  (setq org-refile-targets '((org-agenda-files :maxlevel . 3)
                             ("/Users/roambot/.emacs.d/config.org" :maxlevel . 8)))
  (setq org-refile-use-outline-path 'file)
  (setq org-outline-path-complete-in-steps nil)
  (setq org-refile-allow-creating-parent-nodes 'confirm)
#+END_SRC
*** Open Docx Files In Default Application (Ie Msword)
Open exported docx files in Word/Open Office rather than emacs
#+BEGIN_SRC emacs-lisp
  (setq org-file-apps
        '(("\\.docx\\'" . default)
          ("\\.mm\\'" . default)
          ("\\.x?html?\\'" . default)
          ("\\.pdf\\'" . default)
          (auto-mode . emacs)))
#+END_SRC
*** Org-Agenda
Settings for the [[http://orgmode.org/manual/Agenda-Views.html][agenda]]. 
#+BEGIN_SRC emacs-lisp
  (setq org-agenda-files '("~/Dropbox/org-files/"))
  (general-define-key "C-c a" #'org-agenda)
  ; https://orgmode.org/manual/Storing-searches.html#Storing-searches
  (setq org-agenda-custom-commands
        '(("x" agenda)
          ("y" agenda*) ; or agenda entries planned this week/day with an hour specification like [h]h:mm
          ("z" todo "TODO")
          ("n" todo "NEXT")
          ("r" todo "REVISE")
          ("w" todo "WAITING")))

  ;; Display properties
  (setq org-cycle-separator-lines 0
        org-tags-column 80
        org-agenda-tags-column org-tags-column
        org-agenda-window-setup 'only-window
        org-agenda-restore-windows-after-quit t
        org-agenda-todo-ignore-scheduled 'all
        org-agenda-todo-ignore-deadlines 'all 
        ;; org-agenda-sticky t
        org-agenda-span 'day)

  (with-eval-after-load 'org-agenda
    (general-define-key :keymaps 'org-agenda-mode-map 
                        "j" 'org-agenda-next-item
                        "k" 'org-agenda-previous-item))

  ;; automatically refresh the agenda after adding a task
  (defun cpm/org-agenda-refresh ()
  (interactive)
  (when (get-buffer "*Org Agenda*")
      (with-current-buffer "*Org Agenda*"
          (org-agenda-redo t)
          (message "[org agenda] refreshed!"))))
  (add-hook 'org-capture-after-finalize-hook 'cpm/org-agenda-refresh)

  ;; show all todos
  (defun cpm/jump-to-org-agenda-all-todos ()
    "open agenda with all unscheduled/non-deadline todos"
    (interactive)
    (org-agenda nil "z"))
#+END_SRC

*** Org-Super-Agenda
[[https://github.com/alphapapa/org-super-agenda][Supercharge]] org-agenda. Settings courtesy of [[https://github.com/fuxialexander/doom-emacs-private-xfu][fuxialexander]]
#+BEGIN_SRC emacs-lisp
    (use-package org-super-agenda
      :commands (org-super-agenda-mode)
      :config
      (setq org-super-agenda-groups
            '((:name "Log\n"
                     :log t)  ; Automatically named "Log"
              (:name "Schedule\n"
                     :time-grid t)
              (:name "Today\n"
                     :scheduled today)
              ;; (:name "Habits\n"
              ;;        :habit t)
              (:name "Due today\n"
                     :deadline today)
              (:name "Overdue\n"
                     :deadline past)
              (:name "Due soon\n"
                     :deadline future)
              (:name "Waiting\n"
                     :todo "WAITING"
                     :order 98)
              (:name "Scheduled earlier\n"
                     :scheduled past))))

  ;; Hydra for org agenda (graciously taken from Spacemacs)
  (after! org-agenda
  (org-super-agenda-mode)
  (general-define-key :states '(normal emacs) :keymaps 'org-agenda-keymap
    "."  'cpm/hydra-org-agenda/body)
  (defhydra cpm/hydra-org-agenda (:color pink :hint none)
    "
  Org agenda (_q_uit)

  ^Clock^      ^Visit entry^              ^Date^             ^Other^
  ^-----^----  ^-----------^------------  ^----^-----------  ^-----^---------
  _ci_ in      _SPC_ in other window      _ds_ schedule      _gr_ reload
  _co_ out     _TAB_ & go to location     _dd_ set deadline  _._  go to today
  _cq_ cancel  _RET_ & del other windows  _dt_ timestamp     _gd_ go to date
  _cj_ jump    _o_   link                 _+_  do later      ^^
  ^^           ^^                         _-_  do earlier    ^^
  ^^           ^^                         ^^                 ^^
  ^View^          ^Filter^                 ^Headline^         ^Toggle mode^
  ^----^--------  ^------^---------------  ^--------^-------  ^-----------^----
  _vd_ day        _ft_ by tag              _ht_ set status    _tf_ follow
  _vw_ week       _fr_ refine by tag       _hk_ kill          _tl_ log
  _vt_ fortnight  _fc_ by category         _hr_ refile        _ta_ archive trees
  _vm_ month      _fh_ by top headline     _hA_ archive       _tA_ archive files
  _vy_ year       _fx_ by regexp           _h:_ set tags      _tr_ clock report
  _vn_ next span  _fd_ delete all filters  _hp_ set priority  _td_ diaries
  _vp_ prev span  ^^                       ^^                 ^^
  _vr_ reset      ^^                       ^^                 ^^
  ^^              ^^                       ^^                 ^^
  "
    ;; Entry
    ("hA" org-agenda-archive-default)
    ("hk" org-agenda-kill)
    ("hp" org-agenda-priority)
    ("hr" org-agenda-refile)
    ("h:" org-agenda-set-tags)
    ("ht" org-agenda-todo)
    ;; Visit entry
    ("o"   link-hint-open-link :exit t)
    ("<tab>" org-agenda-goto :exit t)
    ("TAB" org-agenda-goto :exit t)
    ("SPC" org-agenda-show-and-scroll-up)
    ("RET" org-agenda-switch-to :exit t)
    ;; Date
    ("dt" org-agenda-date-prompt)
    ("dd" org-agenda-deadline)
    ("+" org-agenda-do-date-later)
    ("-" org-agenda-do-date-earlier)
    ("ds" org-agenda-schedule)
    ;; View
    ("vd" org-agenda-day-view)
    ("vw" org-agenda-week-view)
    ("vt" org-agenda-fortnight-view)
    ("vm" org-agenda-month-view)
    ("vy" org-agenda-year-view)
    ("vn" org-agenda-later)
    ("vp" org-agenda-earlier)
    ("vr" org-agenda-reset-view)
    ;; Toggle mode
    ("ta" org-agenda-archives-mode)
    ("tA" (org-agenda-archives-mode 'files))
    ("tr" org-agenda-clockreport-mode)
    ("tf" org-agenda-follow-mode)
    ("tl" org-agenda-log-mode)
    ("td" org-agenda-toggle-diary)
    ;; Filter
    ("fc" org-agenda-filter-by-category)
    ("fx" org-agenda-filter-by-regexp)
    ("ft" org-agenda-filter-by-tag)
    ("fr" org-agenda-filter-by-tag-refine)
    ("fh" org-agenda-filter-by-top-headline)
    ("fd" org-agenda-filter-remove-all)
    ;; Clock
    ("cq" org-agenda-clock-cancel)
    ("cj" org-agenda-clock-goto :exit t)
    ("ci" org-agenda-clock-in :exit t)
    ("co" org-agenda-clock-out)
    ;; Other
    ("q" nil :exit t)
    ("gd" org-agenda-goto-date)
    ("." org-agenda-goto-today)
    ("gr" org-agenda-redo)))

    (defun cpm/jump-to-org-agenda ()
    (interactive)
    (org-agenda nil "a"))
#+END_SRC

*** Org Capture
**** Capture Settings
#+BEGIN_SRC emacs-lisp
  (general-define-key "C-c c" 'org-capture)
  (add-hook 'org-capture-mode-hook 'evil-insert-state)
  (setq org-capture-templates
        '(("p" "Projects" entry (file+headline "~/Dropbox/org-files/todo.org" "Projects")
           "** STARTED %? \n  %i")
          ("c" "Capture" entry (file+headline "~/Dropbox/org-files/todo.org" "Inbox")
           "* TODO %?\n %i")
          ("j" "Journal" entry (file+olp+datetree "~/Dropbox/org-files/journal.org")
           "**** %<%H:%M>\n%?")
          ("l" "A link, for reading later." entry (file+headline "~/Dropbox/org-files/org-notes.org" "Reading List")
            "* %:description\n%u\n\n%c\n\n%i"
            :empty-lines 1)
          ("m" "Mail-Task" entry (file+headline "~/Dropbox/org-files/todo.org" "Inbox")
           "** TODO %:description                         :email: \n[[message://%l][Email link]] \n%? ")
          ("n" "Notes" entry (file "~/Dropbox/org-files/org-notes.org")
          "* %?")
          ("w" "Review: Weekly Review" entry (file+datetree "~/Dropbox/org-files/reviews.org")
            (file "~/Dropbox/org-files/templates/weekly_review_template.org"))))

    ;; Add date to captured items
    (defun add-property-with-date-captured ()
      "Add DATE_CAPTURED property to the current item."
      (interactive)
      (org-set-property "DATE_CAPTURED" (format-time-string "%c")))

    (add-hook 'org-capture-before-finalize-hook 'add-property-with-date-captured)

#+END_SRC
**** Org Journal Capture
Tell emacs what you're doing a few times a day. Depends on a [[/Users/roambot/bin/scripts/emacs_journal.sh][shell script]] run
in the background. I got the idea from [[http://www.diegoberrocal.com/blog/2015/08/19/org-protocol/][Diego Berrocal]]. Hat tip to [[http://stackoverflow.com/questions/23517372/hook-or-advice-when-aborting-org-capture-before-template-selection][stack
overflow]] for help on hooks for the created frame.

#+BEGIN_SRC emacs-lisp
(defun cpm/org-journal ()
  (interactive) (org-capture nil "j"))

(defun cpm/what-are-you-doing-capture ()
  (interactive)
  (make-frame '((name . "What are you doing?") (left . (+ 550)) (top . (+ 400)) (width . 100) (height . 12)))
  (select-frame-by-name "What are you doing?")
  (cpm/org-journal)
  )

#+END_SRC
**** TESTING Email Capture Workflow
#+BEGIN_SRC emacs-lisp
  (defun cpm/org-mailmate ()
    (interactive) (org-capture nil "m"))


  (defun cpm/email-mailmate-capture ()
    (interactive)
    (make-frame '((name . "Email Capture") (left . 300) (top . 400) (width . 90) (height . 15)))
    (select-frame-by-name "Email Capture")
    (cpm/org-mailmate)
    )

#+END_SRC
**** Alfred capture workflow
Help alfred and org-capture play nice. Courtesy of [[http://orgmode.org/worg/org-contrib/alfred-org-capture.html][worg]] with some slight modifications.
#+BEGIN_SRC emacs-lisp
(defun cpm/org-capture-frame ()
  (interactive)
  (org-capture nil "c"))
  
(defun cpm/make-orgcapture-frame ()
  "Create a new frame and run org-capture."
  (interactive)
  (make-frame '((name . "alfred-capture") (width . 90) (height . 20)
                (top . 400) (left . 300)
                ))
  (select-frame-by-name "alfred-capture")
  (cpm/org-capture-frame))

#+END_SRC
**** Capture advice
Make capture the only window and close after refiling.
 #+BEGIN_SRC emacs-lisp
   (defadvice org-capture
     (after make-full-window-frame activate)
     "Advise capture to be the only window when used as a popup"
     (cond ((equal "What are you doing?" (frame-parameter nil 'name)) (delete-other-windows))
           ((equal "alfred-capture" (frame-parameter nil 'name)) (delete-other-windows))
           ((equal "Email Capture" (frame-parameter nil 'name)) (delete-other-windows))

           ))

    (defadvice org-capture-finalize
      (after delete-capture-frame activate)
       "Advise capture-finalize to close the frame"
       (cond ((equal "What are you doing?" (frame-parameter nil 'name)) (delete-frame))
             ((equal "alfred-capture" (frame-parameter nil 'name)) (delete-frame))
             ((equal "Email Capture" (frame-parameter nil 'name)) (delete-frame))
             ))
#+END_SRC

*** Org Keybindings
**** Evil Org 
#+BEGIN_SRC emacs-lisp
(use-package evil-org
  :init
  (add-hook 'org-mode-hook 'evil-org-mode)  
  :config
  (add-hook 'evil-org-mode-hook  (lambda () (evil-org-set-key-theme '(textobjects insert navigation additional shift)))))
#+END_SRC
**** Org Local Leader Keybindings

#+BEGIN_SRC emacs-lisp
  (general-define-key
  :states '(normal visual)
  :keymaps 'org-mode-map
  :prefix "SPC m" 
  :non-normal-prefix "C-SPC m"

   ""    '(nil :which-key "Local Leader")
   "RET" #'cpm/org-archive-done-tasks
   "SPC" #'org-toggle-checkbox
   "."   #'org-cycle-agenda-files
   "/"   #'org-sparse-tree
   "="   #'org-align-all-tags
   "?"   #'org-tags-view
   ":"   #'org-set-tags
   "a"   #'super-jump-to-org-agenda
   "A"   #'org-archive-subtree
   "b"   #'org-tree-to-indirect-buffer
   "B"   #'org-babel-tangle
   "c"   #'org-capture
   "d"   #'org-time-stamp
   "D"   #'org-deadline
   "e"   #'org-edit-special
   "n"   #'cpm/narrow-or-widen-dwim
   "r"   #'org-refile
   "s"   #'org-schedule
   "t"   #'counsel-org-tag
   "T"   #'org-todo
   "v"   #'variable-pitch-mode
   "l"   #'org-insert-link
   "L"   #'org-store-link
   "+"   #'org-timestamp-up-day
   "-"   #'org-timestamp-down-day
   "<"   #'org-metaleft
   ">"   #'org-metaright

   "i"  '(:ignore t :which-key "Insert...")
         "il" #'org-insert-link
         "if" #'org-footnote-new

   "R"  '(:ignore t :which-key "RevealJS..." )
         "Rr" #'org-reveal-export-to-html-and-browse
         "Rs" #'cpm/narrowed-subtree-to-html
         "RS" #'org-reveal-export-current-subtree
         "Rp" #'cpm/reveal-to-pdf)

  (general-define-key
    :states '(normal motion emacs)
    :keymaps 'org-agenda-mode-map
    :prefix "SPC"
    :non-normal-prefix "C-SPC"
      "<escape>" #'org-agenda-Quit
      "m"   #'org-agenda-month-view
      "C-j" #'org-agenda-next-item
      "C-k" #'org-agenda-previous-item
      "C-n" #'org-agenda-next-item
      "C-p" #'org-agenda-previous-item)
#+END_SRC
**** Alternate Bindings
#+BEGIN_SRC emacs-lisp
  (general-define-key :states '(normal) :keymaps 'org-mode-map
        "RET" 'org-open-at-point     ;; Open with return in evil
        "p"   'org-yank ;; better pasting behavior
        "s-J" 'crux-top-join-line
        )
  ;;      "L" 'org-shiftright
  ;;      "H" 'org-shiftleft
  ;;      "$" 'org-end-of-line
  ;;      "^" 'org-beginning-of-line
  ;;      "<" 'org-metaleft
  ;;      ">" 'org-metaright
  ;;      "-" 'org-cycle-list-bullet)
  
  ;;   ;; normal & insert state shortcuts.
    (general-define-key :states '(normal insert) :keymaps 'org-mode-map
       ;; easily emphasize text
       ;; see https://emacs.stackexchange.com/questions/27645/unable-to-bind-emphasize-key-in-org-mode
       "s-b" (lambda () (interactive) (org-emphasize ?\*))
       "s-i" (lambda () (interactive) (org-emphasize ?\/))
       "s-=" (lambda () (interactive) (org-emphasize ?\=))
        ;; better pasting behavior in org-mode
       "s-v" 'org-yank)
  ;;      "TAB" 'org-cycle
  ;;      "s-l" 'org-metaright
  ;;      "s-h" 'org-metaleft
  ;;      "s-k" 'org-metaup
  ;;      "s-j" 'org-metadown
  ;;      "s-L" 'org-shiftmetaright
  ;;      "s-H" 'org-shiftmetaleft
  ;;      "s-K" 'org-shiftmetaup
  ;;      "s-J" 'org-shiftmetadown
  ;;      "s-o" '(lambda () (interactive)
  ;;               (evil-org-eol-call
  ;;                '(lambda()
  ;;                   (org-insert-heading)
  ;;                   (org-metaright))))
  ;;      "s-t" '(lambda () (interactive)
  ;;               (evil-org-eol-call
  ;;                '(lambda()
  ;;                   (org-insert-todo-heading nil)
  ;;                   (org-metaright)))))
  ;;   ;; Use tab in insert mode
  ;;   (general-define-key :states '(insert) :keymaps 'org-mode-map "\t" nil
  ;;      "RET" #'org-return-indent
  ;;      "C-j" nil
  ;;      "C-k" nil
  ;;      "H-j"   #'org-next-visible-heading
  ;;      "H-k"   #'org-previous-visible-heading
  ;;      "H-S-j"     #'org-forward-heading-same-level
  ;;      "H-S-k"     #'org-backward-heading-same-level
  ;;      )
#+END_SRC

*** Org Template Expansions

#+BEGIN_SRC emacs-lisp
  (with-eval-after-load 'org
  (add-to-list 'org-structure-template-alist
    '("E" "#+BEGIN_SRC emacs-lisp\n?\n#+END_SRC"))
  (add-to-list 'org-structure-template-alist
    '("n" "#+BEGIN_NOTES\n?\n#+END_NOTES"))
  (add-to-list 'org-structure-template-alist
    '("t" "#+BEGIN_COMMENT TODO: ?  #+END_COMMENT"))
  (add-to-list 'org-structure-template-alist
    '("b" "#+REVEAL: split?"))
  (add-to-list 'org-structure-template-alist
    '("f" "#+ATTR_REVEAL: :frag (appear)?")))
#+END_SRC
*** Org Bullets
#+BEGIN_SRC emacs-lisp
  (use-package org-bullets
    :after org
    :demand t
    :hook (org-mode . (lambda () (org-bullets-mode 1)))
    :config 
    (setq org-bullets-bullet-list '("◉" "⚫"))) 

    ;; Other bullets
    ;; "●" "◉" "→"
    ;; ("◉" "◎" "⚫" "○" "►" "◇")
    ;;  "∙" "∶" "∵" "∷" "∺" )))
    ;; (setq org-bullets-bullet-list '("❂" "⁑" "⁂" "❖" "✮" "✱" "✵")))

  ;; Asterisks and dashes for bullet lists are fine, but actual circular bullets are better
  ;; via http://www.howardism.org/Technical/Emacs/orgmode-wordprocessor.html
  (font-lock-add-keywords 'org-mode
                        '(("^ +\\([-*]\\) "
                           (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "•"))))))
#+END_SRC
*** Org Prettify Source Blocks
Make source blocks look better. Courtesy of [[https://pank.eu/blog/pretty-babel-src-blocks.html][Rasmus Pank Roulund]].
Last updated: 2018-01-11
#+BEGIN_SRC emacs-lisp 
  (with-eval-after-load 'org
    (defvar-local rasmus/org-at-src-begin -1
      "Variable that holds whether last position was a ")

    (defvar rasmus/ob-header-symbol ?☰
      "Symbol used for babel headers")

    (defun rasmus/org-prettify-src--update ()
      (let ((case-fold-search t)
            (re "^[ \t]*#\\+begin_src[ \t]+[^ \f\t\n\r\v]+[ \t]*")
            found)
        (save-excursion
          (goto-char (point-min))
          (while (re-search-forward re nil t)
            (goto-char (match-end 0))
            (let ((args (org-trim
                         (buffer-substring-no-properties (point)
                                                         (line-end-position)))))
              (when (org-string-nw-p args)
                (let ((new-cell (cons args rasmus/ob-header-symbol)))
                  (cl-pushnew new-cell prettify-symbols-alist :test #'equal)
                  (cl-pushnew new-cell found :test #'equal)))))
          (setq prettify-symbols-alist
                (cl-set-difference prettify-symbols-alist
                                   (cl-set-difference
                                    (cl-remove-if-not
                                     (lambda (elm)
                                       (eq (cdr elm) rasmus/ob-header-symbol))
                                     prettify-symbols-alist)
                                    found :test #'equal)))
          ;; Clean up old font-lock-keywords.
          (font-lock-remove-keywords nil prettify-symbols--keywords)
          (setq prettify-symbols--keywords (prettify-symbols--make-keywords))
          (font-lock-add-keywords nil prettify-symbols--keywords)
          (while (re-search-forward re nil t)
            (font-lock-flush (line-beginning-position) (line-end-position))))))

    (defun rasmus/org-prettify-src ()
      "Hide src options via `prettify-symbols-mode'.

    `prettify-symbols-mode' is used because it has uncollpasing. It's
    may not be efficient."
      (let* ((case-fold-search t)
             (at-src-block (save-excursion
                             (beginning-of-line)
                             (looking-at "^[ \t]*#\\+begin_src[ \t]+[^ \f\t\n\r\v]+[ \t]*"))))
        ;; Test if we moved out of a block.
        (when (or (and rasmus/org-at-src-begin
                       (not at-src-block))
                  ;; File was just opened.
                  (eq rasmus/org-at-src-begin -1))
          (rasmus/org-prettify-src--update))
        ;; Remove composition if at line; doesn't work properly.
        ;; (when at-src-block
        ;;   (with-silent-modifications
        ;;     (remove-text-properties (match-end 0)
        ;;                             (1+ (line-end-position))
        ;;                             '(composition))))
        (setq rasmus/org-at-src-begin at-src-block)))

    (defun rasmus/org-prettify-symbols ()
      (mapc (apply-partially 'add-to-list 'prettify-symbols-alist)
            (cl-reduce 'append
                       (mapcar (lambda (x) (list x (cons (upcase (car x)) (cdr x))))
                               `(("#+begin_src" . ?╦) ;; ➤ 🖝 ➟ ➤ ✎ ✎
                                 ("#+end_src"   . ?╩) ;; □
                                 ("#+header:" . ,rasmus/ob-header-symbol)
                                 ("#+begin_comment" . ?✎)
                                 ("#+end_comment" . ?✎)
                                 ("#+begin_notes" . ?➤)
                                 ("#+end_notes" . ?➤)
                                 ("#+begin_quote" . ?»)
                                 ("#+end_quote" . ?«)))))
      (turn-on-prettify-symbols-mode)
      (add-hook 'post-command-hook 'rasmus/org-prettify-src t t))
    (add-hook 'org-mode-hook #'rasmus/org-prettify-symbols))


#+END_SRC

*** Org-Goto
Make counsel display org headings nicely. 
#+BEGIN_SRC emacs-lisp
(with-eval-after-load 'org
  (setq counsel-org-goto-display-style 'path)
  (setq counsel-org-goto-separator " ➜ ")
  (setq counsel-org-goto-face-style 'org)
  (define-key org-mode-map (kbd "C-c C-j") 'counsel-org-goto)
  (define-key org-mode-map (kbd "C-u C-c C-j") 'counsel-org-goto-all))
#+END_SRC
*** Org-Reveal
#+BEGIN_SRC emacs-lisp
  (use-package ox-reveal
  :commands (org-reveal-export-current-subtree org-reveal-export-to-html-and-browse)
  :config
  (setq org-reveal-root (concat "file://" (getenv "HOME") "/bin/reveal.js")
        org-reveal-theme "moon"
        org-reveal-default-frag-style "roll-in"
        org-reveal-hlevel 2
        ))
       
(defun cpm/narrowed-subtree-to-html ()
  "export narrowed tree to html"
  (interactive)
  (org-reveal-export-current-subtree)
  (org-narrow-to-subtree))
#+END_SRC
*** Org Organization (GTD)
**** GTD Projects
#+begin_src emacs-lisp
(defun cpm/org-goto-todo ()
  (interactive)
  (find-file "~/Dropbox/org-files/todo.org")
  (widen)
  (beginning-of-buffer)
  (re-search-forward "* Inbox")
  (beginning-of-line))

(defun cpm/org-goto-inbox ()
  (interactive)
  (find-file "~/Dropbox/org-files/inbox.org")
  (widen)
  (beginning-of-buffer)
  (beginning-of-line))

(defun cpm/org-goto-projects ()
  (interactive)
  (find-file "~/Dropbox/org-files/todo.org")
  (widen)
  (beginning-of-buffer)
  (re-search-forward "* Projects")
  (beginning-of-line))

(defun cpm/project-overview ()
  (interactive)
  (cpm/org-goto-projects)
  (org-narrow-to-subtree)
  (org-columns))
#+end_src
**** Stuck Projects
#+begin_src emacs-lisp
(defun cpm/my-org-agenda-list-stuck-projects ()
  (interactive)
  (cpm/org-goto-projects)
  (org-agenda nil "#" 'subtree))
#+end_src
**** Areas
#+begin_src emacs-lisp
(defun cpm/go-to-areas ()
    (interactive)
    (find-file "~/Dropbox/org-files/todo.org")
    (widen)
    (beginning-of-buffer)
    (re-search-forward "* Areas")
    (beginning-of-line))

(defun cpm/areas-overview ()
    (interactive)
    (go-to-areas)
    (org-narrow-to-subtree)
    (org-columns))
#+end_src
**** Random Notes
#+begin_src emacs-lisp
(use-package org-randomnote
  :commands (org-randomnote org-randomnote--go-to-random-header org-randomnote--get-random-file org-randomnote--get-random-subtree)
  :init
  (setq org-randomnote-candidates '("~/Dropbox/org-files/todo.org")))
#+end_src

*** Org & Pandoc (Ox-pandoc)

#+BEGIN_SRC emacs-lisp
  (use-package ox-pandoc
    :after ox
    :demand t
    :config
    ;; default options for all output formats
    (setq org-pandoc-command (expand-file-name "/usr/local/bin/pandoc"))
    (setq org-pandoc-options '((standalone . t)))
    ;; cancel above settings only for 'docx' format
    (setq org-pandoc-options-for-docx '((standalone . nil)))
    ;; special settings for beamer-pdf and latex-pdf exporters
    (setq org-pandoc-options-for-beamer-pdf '((pdf-engine . "xelatex")))
    (setq org-pandoc-options-for-latex-pdf '((pdf-engine . "xelatex"))))
#+END_SRC 
*** Org Rifle
Search [[https://github.com/alphapapa/helm-org-rifle][rapidly]] through org files using helm
#+BEGIN_SRC emacs-lisp
  (use-package helm-org-rifle
    :commands (helm-org-rifle helm-org-rifle-agenda-files helm-org-rifle-org-directory))
#+END_SRC
*** Org-Download
Drag and drop images to Emacs org-mode. Courtesy of [[https://github.com/abo-abo/org-download][abo-abo]]. 
#+BEGIN_SRC emacs-lisp
  (use-package org-download
    :commands (org-download-yank org-download-screenshot org-download-image)
    :config
     (setq org-download-method 'directory)
           org-download-image-dir "~/Dropbox/org-files/org-pictures"
           org-download-image-latex-width 500
   )
#+END_SRC
*** Org Pomodoro
Helps with time tracking
#+BEGIN_SRC emacs-lisp
  (use-package org-pomodoro
    :commands org-pomodoro
    :init
    (progn
      (setq org-pomodoro-audio-player "/usr/bin/afplay")))
#+END_SRC emacs-lisp
*** Org Indirect Buffer
Some advice to automatically switch to a new indirect buffer upon creation
#+BEGIN_SRC emacs-lisp
(defadvice org-tree-to-indirect-buffer (after org-tree-to-indirect-buffer-after activate) (other-window 1))
#+END_SRC

*** Org Functions
Some useful org-specific functions
**** Org-Fill Functions
 Functions to calculate apt offsets and call regular org fill stuff. There's a
 useful [[http://stackoverflow.com/questions/14351154/org-mode-outline-level-specific-fill-column-values][stack overflow thread]] on this. 
#+BEGIN_SRC emacs-lisp
(defun calc-offset-on-org-level ()
  "Calculate offset (in chars) on current level in org mode file."
  (* (or (org-current-level) 0) org-indent-indentation-per-level))

(defun my-org-fill-paragraph (&optional JUSTIFY)
  "Calculate apt fill-column value and fill paragraph."
  (let* ((fill-column (- fill-column (calc-offset-on-org-level))))
    (org-fill-paragraph JUSTIFY)))

(defun my-org-auto-fill-function ()
  "Calculate apt fill-column value and do auto-fill"
  (let* ((fill-column (- fill-column (calc-offset-on-org-level))))
    (org-auto-fill-function)))
    
(defun my-org-mode-hook ()
  (setq fill-paragraph-function   'my-org-fill-paragraph
        normal-auto-fill-function 'my-org-auto-fill-function))

(add-hook 'org-load-hook 'my-org-mode-hook)
(add-hook 'org-mode-hook 'my-org-mode-hook)
#+END_SRC
**** Narrow & Advance/Retreat
Functions to advance forwards or backwards through narrowed tree
#+BEGIN_SRC emacs-lisp
(defun cpm/org-advance ()
  (interactive)
  (when (buffer-narrowed-p)
    (beginning-of-buffer)
    (widen)
    (org-forward-heading-same-level 1))
  (org-narrow-to-subtree))

(defun cpm/org-retreat ()
  (interactive)
  (when (buffer-narrowed-p)
    (beginning-of-buffer)
    (widen)
    (org-backward-heading-same-level 1))
  (org-narrow-to-subtree))
#+END_SRC
**** Org files
#+BEGIN_SRC emacs-lisp
(defun cpm/goto-org-files ()
  "goto org-files directory"
  (interactive)
  (require 'ranger)
  (find-file "~/Dropbox/org-files"))
(defun cpm/goto-mail-inbox.org ()
  "goto org-mail-inbox"
  (interactive)
  (find-file "~/Dropbox/org-files/mail.org"))
(defun cpm/goto-todo.org ()
  "goto org-todo"
  (interactive)
  (find-file "~/Dropbox/org-files/todo.org"))
(defun cpm/goto-articles.org ()
  "goto org-articles"
  (interactive)
  (find-file "~/Dropbox/org-files/articles.org"))
(defun cpm/goto-classes.org ()
  "goto org-classes"
  (interactive)
  (find-file "~/Dropbox/org-files/classes.org"))
(defun cpm/goto-notes.org ()
  "goto org-notes"
  (interactive)
  (find-file "~/Dropbox/org-files/org-notes.org"))
(defun cpm/goto-someday.org ()
  "goto org-someday"
  (interactive)
  (find-file "~/Dropbox/org-files/someday.org"))
#+END_SRC
**** Export Headings as Separate PDF Files
Helpful advice from [[http://pragmaticemacs.com/emacs/export-org-mode-headlines-to-separate-files/][pragmatic emacs]]
#+BEGIN_SRC emacs-lisp
;; export headlines to separate files
;; http://emacs.stackexchange.com/questions/2259/how-to-export-top-level-headings-of-org-mode-buffer-to-separate-files
(defun cpm/org-export-headlines-to-pdf ()
  "Export all subtrees that are *not* tagged with :noexport: to
separate files.

Subtrees that do not have the :EXPORT_FILE_NAME: property set
are exported to a filename derived from the headline text."
  (interactive)
  (save-buffer)
  (let ((modifiedp (buffer-modified-p)))
    (save-excursion
      (goto-char (point-min))
      (goto-char (re-search-forward "^*"))
      (set-mark (line-beginning-position))
      (goto-char (point-max))
      (org-map-entries
       (lambda ()
         (let ((export-file (org-entry-get (point) "EXPORT_FILE_NAME")))
           (unless export-file
             (org-set-property
              "EXPORT_FILE_NAME"
              (replace-regexp-in-string " " "_" (nth 4 (org-heading-components)))))
           (deactivate-mark)
           (org-pandoc-export-to-latex-pdf nil t)
           (unless export-file (org-delete-property "EXPORT_FILE_NAME"))
           (set-buffer-modified-p modifiedp)))
       "-noexport" 'region-start-level))))
#+END_SRC
*** Org Numbers Overlay
[[https://github.com/larkery/emacs/blob/master/site-lisp/org-numbers-overlay.el][This]] is a useful minor-mode to number org-mode headings. It came up in
the course of [[https://www.reddit.com/r/emacs/comments/6crtzw/it_is_possible_to_display_numbers_at_the/][this reddit]] discussion. 
#+BEGIN_SRC emacs-lisp
(define-minor-mode org-numbers-overlay-mode
  "Add overlays to org headings which number them"
  nil " *1." nil

  (let ((hooks '(after-save-hook
                 org-insert-heading-hook))
        (funcs '(org-promote
                 org-cycle-level
                 org-promote-subtree
                 org-demote
                 org-demote-subtree
                 org-move-subtree-up
                 org-move-subtree-down
                 org-move-item-down
                 org-move-item-up
                 org-cut-subtree
                 org-insert-todo-heading
                 org-insert-todo-subheading
                 org-meta-return
                 org-set-property
                 org-move)))
    (if org-numbers-overlay-mode
        (progn
          (org-numbers-overlay-update)
          (dolist (fn funcs)
            (advice-add fn :after #'org-numbers-overlay-update))
          (dolist (hook hooks)
            (add-hook hook #'org-numbers-overlay-update)))

      (progn
        (dolist (fn funcs)
          (advice-add fn :after #'org-numbers-overlay-update))
        (dolist (hook hooks)
          (remove-hook hook #'org-numbers-overlay-update))

        (loop for o in (overlays-in (point-min) (point-max))
              if (eq (overlay-get o 'type) 'org-number)
              do (delete-overlay o))))))

(defun org-numbers-overlay-update (&rest args)
  (when org-numbers-overlay-mode
    (let ((levels (make-vector 10 0)))
      (save-excursion
        (widen)
        (goto-char (point-min))
        (while (outline-next-heading)
          (if (assoc "UNNUMBERED" (org-entry-properties))
              ;; if it's unnumbered delete any overlays we have on it
              (loop for o in (overlays-in (point)
                                          (save-excursion (end-of-line) (point)))
                    if (eq (overlay-get o 'type) 'org-number)
                    do (delete-overlay o))
            ;; if it's not unnumbered add a number or update it
            (let* ((detail (org-heading-components))
                   (level (- (car detail) 1))
                   (lcounter (1+ (aref levels level)))
                   (o (or (loop for o in (overlays-in (point)
                                                      (save-excursion (end-of-line) (point)))
                                if (eq (overlay-get o 'type) 'org-number)
                                return o)
                          (make-overlay (point) (+ (point) (car detail))))))
              (aset levels level lcounter)
              (loop for i from (1+ level) to 9
                    do (aset levels i 0))
              (overlay-put o 'type 'org-number)
              (overlay-put o 'evaporate t)
              (overlay-put o 'after-string
                           (let (s)
                             (loop for i across levels
                                   until (zerop i)
                                   do (setf s (if s (format "%s.%d" s i)
                                                (format " %d" i))
                                            ))
                             s)))))))))
(provide 'org-numbers-overlay)
#+END_SRC
*** Toc-org
Let's install and load the =toc-org= package after org mode is loaded. This is the
package that automatically generates an up to date table of contents for us.

#+BEGIN_SRC emacs-lisp
(use-package toc-org
  :after org
  :demand t
  :init (add-hook 'org-mode-hook #'toc-org-enable))
#+END_SRC

*** Org Miscellaneous Packages  
Other useful org packages

#+BEGIN_SRC emacs-lisp
  (use-package htmlize :after org :demand t)
  (use-package org-inlinetask :ensure nil :commands org-inlinetask-insert-task)
  ;; ignore export of headlines marked with :ignore: tag
  (with-eval-after-load 'org
    (require 'ox-extra)
    (ox-extras-activate '(ignore-headlines)))
#+END_SRC 
*** Org Wiki
#+begin_src emacs-lisp
(use-package org-wiki
  :load-path "~/.emacs.d/.local/elisp"
  :commands (org-wiki-export-html-sync org-wiki-open org-wiki-helm org-wiki-dired org-wiki-index)
  :init
  (setq  org-wiki-location "~/Dropbox/org-files/Wiki")
)
#+end_src
*** Org Clock Hydra
A useful [[https://gist.github.com/deerpig/3cebadb236fed15c54b45f73a4321336#file-hydra-org-el][Gist]]. From a useful [[https://www.reddit.com/r/emacs/comments/85z9k4/marcin_borkowskis_orgmode_hydra/][reddit]] discussion.
#+BEGIN_SRC emacs-lisp
;; hydra-org ----------------------------------------------------
;;
;; based on Marcin Borkowski's Org-mode Hydra: 
;; http://mbork.pl/2018-03-18_My_Org-mode_hydra

(defhydra cpm/hydra-org-clock (:color pink :timeout 12 :hint nil)
  "
                                                                      ╭──────────┐
                                                                      │ Org Mode │
 ╭────────────────────────────────────────────────────────────────────┴──────────╯
  Clock In  [_i_]  Cancel a clock [_q_]  Go to a clock [_j_] Clock in last task [_<f10>_]
  Clock Out [_o_]  Create TODO    [_m_]                                  Quit [_<SPC>_] 
"
  ("i" (lambda () (interactive) (org-clock-in '(4))))
  ("o" org-clock-out)
  ("q" org-clock-cancel )
  ("<f10>" org-clock-in-last )
  ("j" (lambda () (interactive) (org-clock-goto '(4))) ) 
  ("m" make-this-message-into-an-org-todo-item )
  ("<SPC>" nil nil))
#+END_SRC
*** Hooks
#+BEGIN_SRC emacs-lisp
  (add-hook 'org-mode-hook
      (lambda () 
        (turn-on-auto-fill)
        (flyspell-mode 1)
        (org-zotxt-mode)
        (global-git-gutter-mode 0)
        ))
#+END_SRC

*** Org Export
Various exporters to use. Right now it is just markdown that I need.
#+BEGIN_SRC emacs-lisp
(eval-after-load "org"
  '(require 'ox-md nil t))
#+END_SRC

*** Ox-Hugo
[[https://github.com/kaushalmodi/ox-hugo][Export]] to Hugo with Org
#+BEGIN_SRC emacs-lisp
(use-package ox-hugo
  :after ox
  :demand ox-hugo)
#+END_SRC

*** Org Export Top-Level Trees
From a useful [[https://emacs.stackexchange.com/questions/27226/how-to-export-top-level-trees-in-an-org-file-to-corresponding-files][stack exchange]] post
#+BEGIN_SRC emacs-lisp
(defun cpm/org-map-entries (org-file in-tags func)
  (let ((tags (if (stringp in-tags)
                   (list in-tags)
                 in-tags)))

    (with-temp-buffer
      (org-mode)
      (insert-file-contents org-file-main)

      ;; Execute func at each heading that matches tags.
      (while (< (point) (point-max))

        ;; If find a heading...
        (and (search-forward-regexp "^\* " nil "end")

             ;; ...that matches the given tags...
             (seq-reduce
              (lambda(a b) (and a b))
              (mapcar
               (lambda (tag)
                 (beginning-of-line)
                 (search-forward-regexp
                  (concat ":" tag ":") (line-end-position) "end"))
               tags)
              t)

             ;; ... then execute given function with cursor at beginning of
             ;; heading.
             (progn
               (beginning-of-line)
               (save-excursion
                 (funcall func))
               (end-of-line)))))))
#+END_SRC

** Search
*** Ag
 #+BEGIN_SRC emacs-lisp
   (use-package ag
   :commands (helm-do-ag cpm/helm-files-do-ag cpm/helm-files-search-current-directory helm-do-ag-this-file helm-ag-buffers)
   :config
   (progn
     (defun ag/jump-to-result-if-only-one-match ()
       "Jump to the first ag result if that ag search came up with just one match."
       (let (only-one-match)
         (when (member "--stats" ag-arguments)
           (save-excursion
             (goto-char (point-min))
             (setq only-one-match (re-search-forward "^1 matches\\s-*$" nil :noerror)))
           (when only-one-match
             (next-error)
             (kill-buffer (current-buffer))
             (message (concat "ag: Jumping to the only found match and "
                              "killing the *ag* buffer."))))))
     (add-hook 'ag-search-finished-hook #'ag/jump-to-result-if-only-one-match)  
    
     ;; Set default ag arguments
     ;; It looks like the ~/.agignore is used when launching ag from emacs too.
     ;; So the ignores from ~/.agignore don't have to be set here again.

     (setq ag-highlight-search t)
     ;; By default, ag.el will open results in a different window in the frame, so
     ;; the results buffer is still visible. You can override this so the results
     ;; buffer is hidden and the selected result is shown in its place:
     (setq ag-reuse-window nil)
     ;; reuse the same *ag* buffer for all your searches
     (setq ag-reuse-buffers t)
     ;; ;; To save buffer automatically when `wgrep-finish-edit'
     ;; (setq wgrep-auto-save-buffer t)

     (with-eval-after-load 'projectile
       ;; Override the default function to use the projectile function instead
       (defun ag/project-root (file-path)
         (let ((proj-name (projectile-project-root)))
           (if proj-name
               proj-name ; return `projectile-project-root' if non-nil
             ;; Else condition is same as the `ag/project-root' definition
             ;; from ag.el
             (if ag-project-root-function
                 (funcall ag-project-root-function file-path)
               (or (ag/longest-string
                    (vc-git-root file-path)
                    (vc-svn-root file-path)
                    (vc-hg-root file-path))
                   file-path))))))))

 #+END_SRC
 
*** Ripgrep (rg)
 #+BEGIN_SRC emacs-lisp 
 (use-package rg 
   :commands rg)
 #+END_SRC
*** Anzu
[[https://github.com/syohex/emacs-anzu][anzu.el]] is an Emacs port of anzu.vim. anzu.el provides a minor mode which displays current match and total matches information in the mode-line in various search modes.
#+BEGIN_SRC emacs-lisp
(use-package anzu
  :commands (isearch-foward isearch-backward)
  :config (global-anzu-mode))
(use-package evil-anzu
  :commands (evil-search-forward evil-search-backward))
#+END_SRC

** Shell
*** Sane term
 Sane settings for ansi-term
 #+BEGIN_SRC emacs-lisp
   (use-package sane-term
     :commands sane-term
     :init
     ;; shell to use for sane-term
     (setq sane-term-shell-command "/usr/local/bin/zsh")
     ;; sane-term will create first term if none exist
     (setq sane-term-initial-create t)
     ;; `C-d' or `exit' will kill the term buffer.
     (setq sane-term-kill-on-exit t)
     ;; After killing a term buffer, not cycle to another.
     (setq sane-term-next-on-kill nil))
 #+END_SRC
*** Shell Pop
 A popup shell
 #+begin_src emacs-lisp 
   (use-package shell-pop
     :commands shell-pop
     :init
     (setq shell-pop-term-shell "/usr/local/bin/zsh")
     (setq shell-pop-shell-type '("eshell" "*eshell*" (lambda nil (eshell))))
     :config
       (defun ansi-term-handle-close ()
        "Close current term buffer when `exit' from term buffer."
        (when (ignore-errors (get-buffer-process (current-buffer)))
          (set-process-sentinel (get-buffer-process (current-buffer))
                                (lambda (proc change)
                                  (when (string-match "\\(finished\\|exited\\)" change)
                                    (kill-buffer (when (buffer-live-p (process-buffer proc)))
                                    (delete-window))))))
      (add-hook 'shell-pop-out-hook 'kill-this-buffer)
      (add-hook 'term-mode-hook (lambda () (linum-mode -1) (ansi-term-handle-close)))))
 #+end_src
*** Shell settings
 Other useful shell settings  
 #+begin_src emacs-lisp
    ;; basic settings
    ;; (evil-set-initial-state 'term-mode 'emacs)
    (setq explicit-shell-file-name "/usr/local/bin/zsh")
    ;; don't add newline in long lines
    (setq-default term-suppress-hard-newline t)
    ;; kill process buffers without query
    (setq kill-buffer-query-functions (delq 'process-kill-buffer-query-function kill-buffer-query-functions))
    ;; (global-set-key (kbd "C-x k") 'kill-this-buffer) 
    ;; kill ansi-buffer on exit
    (defadvice term-sentinel (around my-advice-term-sentinel (proc msg))
      (if (memq (process-status proc) '(signal exit))
          (let ((buffer (process-buffer proc)))
             ad-do-it
             (kill-buffer buffer))
            ad-do-it))
          (ad-activate 'term-sentinel)

   ;; clickable links & no highlight of line
   (defun my-term-hook ()
     (goto-address-mode) (global-hl-line-mode 0))
   (add-hook 'term-mode-hook 'my-term-hook)
    
   ;; paste and navigation
   (defun term-send-tab ()
   "Send tab in term mode."
     (interactive)
     (term-send-raw-string "\t"))

   ;; Emacs doesn’t handle less well, so use cat instead for the shell pager 
   (setenv "PAGER" "cat")

   ;; hack to fix pasting issue, the paste micro-state won't work in term
   (general-define-key :states '(normal) :keymaps 'term-raw-map 
          "p" 'term-paste
          "C-k" 'term-send-up
          "C-j" 'term-send-down)

   (general-define-key :states '(insert) :keymaps 'term-raw-map 
          "C-c C-d" 'term-send-eof
          "C-c C-z" 'term-stop-subjob
          "<tab>"   'term-send-tab
          "s-v"     'term-paste
          "C-k"     'term-send-up
          "C-j"     'term-send-down)
 #+end_src
*** Compilation buffer

 Whenever I run ~compile~, the buffer stays even after a successful compilation. Let's make it close automatically if the compilation is successful.

 #+BEGIN_SRC emacs-lisp
 (setq compilation-finish-functions
       (lambda (buf str)
         (if (null (string-match ".*exited abnormally.*" str))
             ;;no errors, make the compilation window go away in a few seconds
             (progn
               (run-at-time "0.4 sec" nil
                            (lambda ()
                              (select-window (get-buffer-window (get-buffer-create "*compilation*")))
                              (switch-to-buffer nil)
                              (delete-window)))
               (message "No Compilation Errors!")))))
 #+END_SRC
*** Completion buffer
 Kill the completion buffer
 #+BEGIN_SRC emacs-lisp
   ;; Remove completion buffer when done
   (add-hook 'minibuffer-exit-hook 
   '(lambda ()
            (let ((buffer "*Completions*"))
              (and (get-buffer buffer)
               (kill-buffer buffer)))))
 #+END_SRC
*** Virtualenvwrapper
 #+BEGIN_SRC emacs-lisp
   (use-package virtualenvwrapper
    :after (:any eshell sane-term ansi-term)
    :demand t
    :config
    (venv-initialize-interactive-shells) ;; if you want interactive shell support
    (venv-initialize-eshell) ;; if you want eshell support
    (setq venv-location "~/bin/virtualenvs")
    (setq venv-project-home "~/Dropbox/Work/projects/")
    (add-hook 'venv-postactivate-hook (lambda () (workon-venv))))

   (defcustom venv-project-home
     (expand-file-name (or (getenv "PROJECT_HOME") "~/Dropbox/Work/projects/"))
       "The location(s) of your virtualenv projects."
       :group 'virtualenvwrapper)

   (defun workon-venv ()
    "change directory to project in eshell"
     (eshell/cd (concat venv-project-home venv-current-name)))
 #+END_SRC
*** Tramp
An easy way to ssh
#+BEGIN_SRC emacs-lisp
(use-package tramp-term
  :commands tramp-term
)
#+END_SRC
*** Eshell
 Eshell is an [[https://www.masteringemacs.org/article/complete-guide-mastering-eshell][elisp shell]]. It has its own configuration parameters, distinct
 from those of shell or ansi-terminal.
**** Eshell Settings
 Basic settings
 #+BEGIN_SRC emacs-lisp 
   (use-package eshell
     :commands eshell
     :init
     (setq eshell-directory-name (concat cpm-etc-dir "eshell/")
           eshell-history-file-name (concat cpm-etc-dir "eshell/history")
           eshell-aliases-file (concat cpm-etc-dir "eshell/alias")
           eshell-last-dir-ring-file-name (concat cpm-etc-dir "eshell/lastdir")
           eshell-highlight-prompt nil
           eshell-buffer-shorthand t
           eshell-cmpl-ignore-case t
           eshell-cmpl-cycle-completions t
           eshell-destroy-buffer-when-process-dies t
           eshell-history-size 10000
           ;; auto truncate after 20k lines
           eshell-buffer-maximum-lines 20000
           eshell-hist-ignoredups t
           eshell-error-if-no-glob t
           eshell-glob-case-insensitive t
           eshell-scroll-to-bottom-on-input 'all
           eshell-scroll-to-bottom-on-output 'all
           eshell-list-files-after-cd t
           eshell-banner-message ""
           ;; eshell-banner-message (message "Emacs initialized in %.2fs \n\n" (float-time (time-subtract (current-time) my-start-time)))
           ;; eshell-banner-message "What would you like to do?\n\n"
         )
         ;; Visual commands
     (setq eshell-visual-commands '("ranger" "vi" "screen" "top" "less" "more" "lynx"
                                        "ncftp" "pine" "tin" "trn" "elm" "vim"
                                        "nmtui" "alsamixer" "htop" "el" "elinks"
                                        ))
     (setq eshell-visual-subcommands '(("git" "log" "diff" "show"))))



   (defun cpm/setup-eshell ()
    (interactive)
     ;; turn off semantic-mode in eshell buffers
     (semantic-mode -1)
     ;; turn off hl-line-mode
     (hl-line-mode -1))
#+END_SRC

**** Eshell Helm
#+BEGIN_SRC emacs-lisp
     ;; helm support
     (add-hook 'eshell-mode-hook
          (lambda ()
            (eshell-cmpl-initialize)
            (define-key eshell-mode-map [remap eshell-pcomplete] 'helm-esh-pcomplete)
            (define-key eshell-mode-map (kbd "M-l") 'helm-eshell-history)
            (cpm/setup-eshell)))

         (when (not (functionp 'eshell/rgrep))
           (defun eshell/rgrep (&rest args)
             "Use Emacs grep facility instead of calling external grep."
             (eshell-grep "rgrep" args t)))
#+END_SRC

**** Eshell Truncate Buffers
Per this [[https://emacs.stackexchange.com/a/10874/11934][stack exchange discussion]]
#+BEGIN_SRC emacs-lisp
(defun my/truncate-eshell-buffers ()
  "Truncates all eshell buffers"
  (interactive)
  (save-current-buffer
    (dolist (buffer (buffer-list t))
      (set-buffer buffer)
      (when (eq major-mode 'eshell-mode)
        (eshell-truncate-buffer)))))

;; After being idle for 5 seconds, truncate all the eshell-buffers if
;; needed. If this needs to be canceled, you can run `(cancel-timer
;; my/eshell-truncate-timer)'
(setq my/eshell-truncate-timer
      (run-with-idle-timer 5 t #'my/truncate-eshell-buffers))
 #+END_SRC
**** Eshell Evil History Navigation
History browsing. Note keybindings need to be buffer local as per https://github.com/noctuid/general.el/issues/80
#+BEGIN_SRC emacs-lisp
(add-hook 'eshell-mode-hook
(lambda ()
(general-define-key :states  '(normal insert emacs) :keymaps 'eshell-mode-map
    "<down>" 'eshell-next-input
    "<up>"   'eshell-previous-input
    "C-k"    'eshell-next-input
    "C-j"    'eshell-previous-input)
    ))
#+END_SRC
**** Eshell Prompt
A nicer [[https://gist.github.com/ekaschalk/f0ac91c406ad99e53bb97752683811a5][eshell prompt]] with some [[http://www.modernemacs.com/post/custom-eshell/][useful discussion]] of how it was put together.
I've made just a few tiny modifications.

#+BEGIN_SRC emacs-lisp
  (require 'dash)
  (require 's)

  (defmacro with-face (STR &rest PROPS)
    "Return STR propertized with PROPS."
    `(propertize ,STR 'face (list ,@PROPS)))

  (defmacro esh-section (NAME ICON FORM &rest PROPS)
    "Build eshell section NAME with ICON prepended to evaled FORM with PROPS."
    `(setq ,NAME
           (lambda () (when ,FORM
                   (-> ,ICON
                      (concat esh-section-delim ,FORM)
                      (with-face ,@PROPS))))))

  (defun esh-acc (acc x)
    "Accumulator for evaluating and concatenating esh-sections."
    (--if-let (funcall x)
        (if (s-blank? acc)
            it
          (concat acc esh-sep it))
      acc))

  (defun esh-prompt-func ()
    "Build `eshell-prompt-function'"
    (concat esh-header
            (-reduce-from 'esh-acc "" eshell-funcs)
            "\n"
            eshell-prompt-string))

  (esh-section esh-dir
               "\xf07c"  ;  (faicon folder)
               (abbreviate-file-name (eshell/pwd))
               '(:foreground "#268bd2" :underline t))

  (esh-section esh-git
               "\xe907"  ;  (git icon)
               (with-eval-after-load 'magit
               (magit-get-current-branch))
               '(:foreground "#b58900"))

  (esh-section esh-python
               "\xe928"  ;  (python icon)
               (with-eval-after-load "virtualenvwrapper"
               venv-current-name))

  (esh-section esh-clock
               "\xf017"  ;  (clock icon)
               (format-time-string "%H:%M" (current-time))
               '(:foreground "forest green"))

  ;; Below I implement a "prompt number" section
  (setq esh-prompt-num 0)
  (add-hook 'eshell-exit-hook (lambda () (setq esh-prompt-num 0)))
  (advice-add 'eshell-send-input :before
              (lambda (&rest args) (setq esh-prompt-num (incf esh-prompt-num))))

  (esh-section esh-num
               "\xf0c9"  ;  (list icon)
               (number-to-string esh-prompt-num)
               '(:foreground "brown"))

  ;; Separator between esh-sections
  (setq esh-sep " | ")  ; or "  "

  ;; Separator between an esh-section icon and form
  (setq esh-section-delim " ")

  ;; Eshell prompt header
  (setq esh-header "\n┌─")  ; or "\n "

  ;; Eshell prompt regexp and string. Unless you are varying the prompt by eg.
  ;; your login, these can be the same.
  (setq eshell-prompt-regexp "^└─>> ") ;; note the '^' to get regex working right
  (setq eshell-prompt-string "└─>> ") 

  ;; Choose which eshell-funcs to enable
  (setq eshell-funcs (list esh-dir esh-git esh-python esh-clock esh-num))

  ;; Enable the new eshell prompt
  (setq eshell-prompt-function 'esh-prompt-func)
#+END_SRC
**** Shell Switcher
 Useful for switching between [[https://github.com/DamienCassou/shell-switcher][multiple instances]] of eshell. But you can
 configure for any shell that you use.
 #+BEGIN_SRC emacs-lisp
   (use-package shell-switcher
     :general
     ("C-'"  'shell-switcher-switch-buffer-other-window)
     :config
     (add-hook 'eshell-mode-hook 'shell-switcher-manually-register-shell)
     (setq shell-switcher-mode t))
 #+END_SRC
**** Clear Eshell 
 Make eshell act like a standard unix terminal.
 #+BEGIN_SRC emacs-lisp
   (defun eshell-clear-buffer ()
   "Clear terminal"
   (interactive)
   (let ((inhibit-read-only t))
     (erase-buffer)
     (eshell-send-input)))
 (add-hook 'eshell-mode-hook
       '(lambda()
           (local-set-key (kbd "C-l") 'eshell-clear-buffer)))
 #+END_SRC
**** Eshell Magit
 #+BEGIN_SRC emacs-lisp
 (defun eshell/magit ()
 "Function to open magit-status for the current directory"
   (interactive)
   (magit-status default-directory)
   nil)
 #+END_SRC
**** Eshell Fringe Status
Show [[https://github.com/ryuslash/eshell-fringe-status][last status in fringe]]
#+BEGIN_SRC emacs-lisp
(use-package eshell-fringe-status
  :defer t
  :config
  (add-hook 'eshell-mode-hook 'eshell-fringe-status-mode))
#+END_SRC
**** Eshell Autosuggest
Fish-like [[https://github.com/dieggsy/esh-autosuggest/][history autosuggestions]] in eshell
#+BEGIN_SRC emacs-lisp
(use-package esh-autosuggest
  :hook (eshell-mode . esh-autosuggest-mode))
#+END_SRC
** Completion
*** Company
#+BEGIN_SRC emacs-lisp
(use-package company
  :ensure t
  :hook ((prog-mode org-mode markdown-mode) . company-mode)
  :init
  (setq company-idle-delay 0.45
        company-minimum-prefix-length 3
        company-require-match nil
        company-dabbrev-ignore-case nil
        company-dabbrev-downcase nil)
  :config
  ;; Default backends
  (add-to-list 'company-backends 'company-files)
  ;; key bindings
  (let ((map company-active-map))
   (define-key map (kbd "C-/") 'company-search-candidates)
   (define-key map (kbd "C-M-/") 'company-filter-candidates)
   (define-key map (kbd "C-d") 'company-show-doc-buffer)
   (define-key map (kbd "C-j") 'company-select-next)
   (define-key map (kbd "C-k") 'company-select-previous)
   (define-key map (kbd "C-l") 'company-complete-selection))
 ;; Nicer looking faces
 (custom-set-faces
  '(company-tooltip-common
    ((t (:inherit company-tooltip :weight bold :underline nil))))
  '(company-tooltip-common-selection
    ((t (:inherit company-tooltip-selection :weight bold :underline nil)))))
)
#+END_SRC

*** Company-Bibtex
#+BEGIN_SRC emacs-lisp
(use-package company-bibtex
  :ensure t
  :after company
  :demand t
  :config
  (setq company-bibtex-bibliography "~/Dropbox/Work/master.bib")
  (setq company-bibtex-org-citation-regex "-?@")
  (add-to-list 'company-backends 'company-bibtex))
#+END_SRC
*** Yasnippet
A template system for Emacs http://joaotavora.github.com/yasnippet/
#+BEGIN_SRC emacs-lisp
    (use-package yasnippet
      :hook ((prog-mode org-mode markdown-mode text-mode) . yas-minor-mode)
      :commands (yas-expand yas-minor-mode)
      :diminish (yas-minor-mode . " Ⓨ")
      :config
      ;; see https://emacs.stackexchange.com/a/30150/11934
      (defun cpm/yas-org-mode-hook ()
        (setq-local yas-buffer-local-condition
                '(not (org-in-src-block-p t))))
      (add-hook 'org-mode-hook #'cpm/yas-org-mode-hook)

      ;; snippet directory
      (setq yas-snippet-dirs '("~/.emacs.d/.local/snippets/cpm-snippets"
                               yasnippet-snippets-dir))
      ;; the official snippet collection https://github.com/AndreaCrotti/yasnippet-snippets
      (use-package yasnippet-snippets :ensure t :after yasnippet :demand t)

      ;; Adding yasnippet support to company
      (with-eval-after-load 'company-mode
      (add-to-list 'company-backends '(company-yasnippet)))
      (yas-reload-all))


#+END_SRC
** Programming
*** Alignment
[[https://github.com/edkolev/evil-lion][This package]] provides gl and gL align operators: gl MOTION CHAR and right-align gL MOTION CHAR
#+BEGIN_SRC emacs-lisp
(use-package evil-lion
  :defer t
  :config
  (general-define-key :states '(normal) :keymaps 'prog-mode-map
  "g l" 'evil-lion-left
  "g L" 'evil-lion-right)

  (general-define-key :states '(visual) :keymaps 'prog-mode-map
  "g l" 'evil-lion-left
  "g L" 'evil-lion-right)
  )
#+END_SRC
*** Rainbow delimiters
[[https://github.com/Fanael/rainbow-delimiters][Useful package]] that will highlight delimiters such as parentheses, brackets or braces according to their depth. Each successive level is highlighted in a different color. This makes it easy to spot matching delimiters, orient yourself in the code, and tell which statements are at a given depth.
   #+BEGIN_SRC emacs-lisp
   (use-package rainbow-delimiters 
     :commands rainbow-delimiters-mode
     :init
     (add-hook 'prog-mode-hook 'rainbow-delimiters-mode))
   #+END_SRC
*** Rainbow identifiers
[[https://github.com/Fanael/rainbow-identifiers][Rainbow identifiers mode]] is an Emacs minor mode providing highlighting of identifiers based on their names. Each identifier gets a color based on a hash of its name.
#+BEGIN_SRC emacs-lisp
(use-package rainbow-identifiers
  :commands rainbow-identifiers-mode
  :init
  (add-hook 'prog-mode-hook 'rainbow-identifiers-mode))
#+END_SRC
*** Rainbow mode
[[https://github.com/emacsmirror/rainbow-mode][Colorize color names]] in buffers 
#+BEGIN_SRC emacs-lisp
(use-package rainbow-mode
  :commands rainbow-mode)
#+END_SRC 
*** Electric Pair (Autopair)
#+BEGIN_SRC emacs-lisp
(use-package electric-pair
  :ensure nil
  :commands electric-pair-mode
  :init
  (add-hook 'prog-mode-hook 'electric-pair-mode)
  (add-hook 'org-mode-hook 'electric-pair-mode)
  (add-hook 'markdown-mode-hook 'electric-pair-mode)
  :config 
  ;; via https://www.topbug.net/blog/2016/09/29/emacs-disable-certain-pairs-for-electric-pair-mode/
  (setq electric-pair-inhibit-predicate
      (lambda (c)
        (if (char-equal c ?\") t (electric-pair-default-inhibit c)))))
#+END_SRC
*** Languages
**** Applescript
#+BEGIN_SRC emacs-lisp
  (use-package applescript-mode
    :ensure t
    :commands (applescript-mode))
#+END_SRC
**** Elisp
#+BEGIN_SRC emacs-lisp 
  (use-package elisp-slime-nav
    :commands elisp-slime-nav-mode
    :config
    (add-hook! (emacs-lisp-mode ielm-mode) '(elisp-slime-nav-mode)))

  (use-package eldoc
    :commands eldoc-mode
    :diminish eldoc-mode
    :config 
    ;; Show ElDoc messages in the echo area immediately, instead of after
    ;; 1/2 a second.
    (setq eldoc-idle-delay 0))

    ;; Elisp hook
    (add-hook 'emacs-lisp-mode-hook (lambda ()
                (setq show-trailing-whitespace t)
                (prettify-symbols-mode)
                (eldoc-mode)
                (yas-minor-mode)
                (company-mode)
                (rainbow-delimiters-mode)))

#+END_SRC
**** Haskell
#+BEGIN_SRC emacs-lisp
  (use-package haskell-mode
    :commands haskell-mode)
#+END_SRC
**** Html
#+BEGIN_SRC emacs-lisp
(use-package web-mode
  :commands (web-mode)
  :mode ("\\.html$" . web-mode)
  :config
  (setq web-mode-enable-auto-pairing t
        web-mode-enable-auto-expanding t
        web-mode-enable-css-colorization t
        web-mode-enable-auto-closing t
        web-mode-enable-auto-quoting t)) 
#+END_SRC
**** Lua
#+BEGIN_SRC emacs-lisp
(use-package lua-mode
  :commands lua-mode
  :init
  (dolist (pattern '("\\.lua\\'"))
  (add-to-list 'auto-mode-alist (cons pattern 'lua-mode))))
#+END_SRC
**** PHP
#+BEGIN_SRC emacs-lisp
(use-package php-mode
  :commands php-mode
  :init
  (dolist (pattern '("\\.php\\'"))
  (add-to-list 'auto-mode-alist (cons pattern 'php-mode))))
#+END_SRC
**** Shell script mode
#+BEGIN_SRC emacs-lisp
  (use-package sh-script
    :commands sh-script-mode
    :init
    (progn
      ;; Use sh-mode when opening `.zsh' files, and when opening Prezto runcoms.
      (dolist (pattern '("\\.zsh\\'"
                         "zlogin\\'"
                         "zlogout\\'"
                         "zpreztorc\\'"
                         "zprofile\\'"
                         "zshenv\\'"
                         "zshrc\\'"))
        (add-to-list 'auto-mode-alist (cons pattern 'sh-mode)))))

    (defun spacemacs//setup-shell ()
        (when (and buffer-file-name
                   (string-match-p "\\.zsh\\'" buffer-file-name))
          (sh-set-shell "zsh")))
      (add-hook 'sh-mode-hook 'spacemacs//setup-shell)
#+END_SRC
**** Yaml
#+BEGIN_SRC emacs-lisp
  (use-package yaml-mode
    :commands yaml-mode
    :config
    (add-to-list 'auto-mode-alist '("\\.yml$" . yaml-mode))
    (add-to-list 'auto-mode-alist '("\\.yaml$" . yaml-mode))
    (add-hook 'yaml-mode-hook (lambda () (run-hooks 'prog-mode-hook)))
  )
#+END_SRC
**** Vim
#+BEGIN_SRC emacs-lisp
(use-package vimrc-mode
  :commands vimrc-mode)
#+END_SRC
*** Macrostep
Interactive [[https://github.com/joddie/macrostep][macro expander]] for emacs
#+BEGIN_SRC emacs-lisp
(use-package macrostep
  :commands macrostep-expand
) 
#+END_SRC
*** Documentation
#+BEGIN_SRC emacs-lisp
(use-package tldr 
  :commands (tldr tldr-update-docs)
  :init 
  (evil-set-initial-state 'tldr-mode 'emacs)
  :config
  (setq tldr-directory-path (expand-file-name "tldr/" cpm-etc-dir)))
#+END_SRC
** Version Control
 Magit is a great interface for git projects. It's much more pleasant to use than
 the standard git interface on the command line. I've set up some easy
 keybindings to access magit and related packages.

*** Magit
 #+BEGIN_SRC emacs-lisp
   (use-package magit
     :commands 
     (magit-blame-mode
      magit-commit
      magit-diff
      magit-log
      magit-status)
     :init
     (add-hook 'git-commit-mode-hook 'turn-on-flyspell)
     (add-hook 'magit-mode-hook 'evil-magit-init)
     (setq vc-follow-symlinks t)
     ;; Suppress the message we get about "Turning on
     ;; magit-auto-revert-mode" when loading Magit.
     (setq magit-no-message '("Turning on magit-auto-revert-mode..."))
     :config
     ;; make magit go fullscreen
     ;; (setq magit-display-buffer-function #'magit-display-buffer-fullframe-status-v1)
     (setq magit-diff-refine-hunk 'all)
     (global-git-commit-mode t) ; use emacs as editor for git commits
     (setq magit-push-always-verify nil)
     )
 #+END_SRC

*** Evil Magit
 Evil bindings for magit
 #+BEGIN_SRC emacs-lisp
 (use-package evil-magit
   :after magit
   :demand t
   :config
   (setq evil-magit-use-y-for-yank t))
 #+END_SRC

*** Git timemachine
 #+BEGIN_SRC emacs-lisp
 (use-package git-timemachine            ; Go back in Git time
   :commands git-timemachine
 )
 #+END_SRC
 
*** Gited
Give git projects branches the dired treatment
#+BEGIN_SRC emacs-lisp
(use-package gited
  :commands (gited-list gited-list-branches))
#+END_SRC
 
*** Git gutter
Git gutter is great for giving visual feedback on changes, but it doesn't play
well with org-mode using org-indent. So I don't use it globally. 
 #+BEGIN_SRC emacs-lisp
   (use-package git-gutter
     :defer t
     :init
     (add-hook! (markdown-mode prog-mode conf-mode) 'git-gutter-mode)
     (setq git-gutter:disabled-modes '(org-mode asm-mode image-mode)
           git-gutter:update-interval 2
           git-gutter:window-width 2))

   (use-package git-gutter-fringe
     :diminish git-gutter-mode
     :demand fringe-helper
     :after git-gutter
     :config
     ;; subtle diff indicators in the fringe
     ;; places the git gutter outside the margins.
     (setq-default fringes-outside-margins t)
     ;; thin fringe bitmaps
     (define-fringe-bitmap 'git-gutter-fr:added
     [224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224]
     nil nil 'center)
     (define-fringe-bitmap 'git-gutter-fr:modified
     [224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224]
     nil nil 'center)
     (define-fringe-bitmap 'git-gutter-fr:deleted
     [0 0 0 0 0 0 0 0 0 0 0 0 0 128 192 224 240 248]
     nil nil 'center))
       
 #+END_SRC

*** Quick commits
Make a quick commit without opening magit. This is a version of a
workflow I used to use in Sublime Text. Perfect for short commit messages.
 #+BEGIN_SRC emacs-lisp
   (defun quick-commit ()
   "make a quick commit from the mini-buffer"
   (interactive)
   (evil-ex '"!Git add % && Git commit -m '" ))
 #+END_SRC
 

 
 
 
 
* Research & Writing
** Spelling
Use flyspell and aspell
#+BEGIN_SRC emacs-lisp
  (use-package ispell
    :commands (ispell-word ispell-region ispell-buffer)
    :config
    ;; Save a new word to personal dictionary without asking
    (setq ispell-silently-savep nil)
    (setq-default ispell-program-name "aspell")
    (setq-default ispell-list-command "list")
    (setq ispell-extra-args
        (list "--sug-mode=fast" ;; ultra|fast|normal|bad-spellers
              "--lang=en_US"
              "--ignore=3")))

  (use-package flyspell
    :commands flyspell-auto-correct-word
    :hook ((org-mode markdown-mode latex-mode) . turn-on-flyspell)
    :general
    ("C-;" 'flyspell-auto-correct-word)
    :init
    ;; Below variables need to be set before `flyspell' is loaded.
    (setq flyspell-use-meta-tab nil)
    :config
    ;; Use mouse
    (define-key flyspell-mouse-map [down-mouse-3] #'flyspell-correct-word)
    (define-key flyspell-mouse-map [mouse-3] #'undefined)
    ;; reduce messages & slowdown
    (setq flyspell-issue-message-flag nil)
    (setq flyspell-issue-welcome-flag nil))
#+END_SRC 

** Spelling Autocorrect
Use abbrev-mode as my autocorrect. Via [[http://endlessparentheses.com/ispell-and-abbrev-the-perfect-auto-correct.html][Endless Parentheses]]. 
#+BEGIN_SRC emacs-lisp
(define-key ctl-x-map "\C-i"
  #'endless/ispell-word-then-abbrev)

(defun endless/simple-get-word ()
  (car-safe (save-excursion (ispell-get-word nil))))

(defun endless/ispell-word-then-abbrev (p)
  "Call `ispell-word', then create an abbrev for it.
With prefix P, create local abbrev. Otherwise it will
be global.
If there's nothing wrong with the word at point, keep
looking for a typo until the beginning of buffer. You can
skip typos you don't want to fix with `SPC', and you can
abort completely with `C-g'."
  (interactive "P")
  (let (bef aft)
    (save-excursion
      (while (if (setq bef (endless/simple-get-word))
                 ;; Word was corrected or used quit.
                 (if (ispell-word nil 'quiet)
                     nil ; End the loop.
                   ;; Also end if we reach `bob'.
                   (not (bobp)))
               ;; If there's no word at point, keep looking
               ;; until `bob'.
               (not (bobp)))
        (backward-word)
        (backward-char))
      (setq aft (endless/simple-get-word)))
    (if (and aft bef (not (equal aft bef)))
        (let ((aft (downcase aft))
              (bef (downcase bef)))
          (define-abbrev
            (if p local-abbrev-table global-abbrev-table)
            bef aft)
          (message "\"%s\" now expands to \"%s\" %sally"
                   bef aft (if p "loc" "glob")))
      (user-error "No typo at or before point"))))

(setq save-abbrevs 'silently)

(use-package abbrev
  :ensure nil
  :commands (abbrev-mode))

#+END_SRC

** Helm-Bibtex
Great for managing citations and notes
#+begin_src emacs-lisp
  (use-package helm-bibtex
    :commands helm-bibtex
    :config
    ;; Set insert citekey with markdown citekeys for org-mode
    (setq bibtex-completion-format-citation-functions
          '((org-mode    . bibtex-completion-format-citation-pandoc-citeproc)
          (latex-mode    . bibtex-completion-format-citation-cite)
          (markdown-mode . bibtex-completion-format-citation-pandoc-citeproc)
          (default       . bibtex-completion-format-citation-default)))
    (setq bibtex-completion-display-formats
          '((t . "${author:36} ${title:*} ${year:4} ${=has-pdf=:1}${=has-note=:1} ${=type=:7}")))
    ;; Set default action for helm-bibtex as inserting citation
    (helm-delete-action-from-source "Insert citation" helm-source-bibtex)
    (helm-add-action-to-source "Insert citation" 'helm-bibtex-insert-citation helm-source-bibtex 0)
    (setq bibtex-completion-pdf-symbol "⌘")
    (setq bibtex-completion-notes-symbol "✎")
    (setq bibtex-completion-notes-template-one-file
   "* ${author} (${date}): ${title} 
  :PROPERTIES:
  :INTERLEAVE_PDF: ${file}
  :Custom_ID: ${=key=}
  :END: 
  [[pdfview:${file}][file link]]
       ")
    (setq bibtex-completion-bibliography "~/Dropbox/Work/Master.bib" 
          bibtex-completion-library-path "~/Dropbox/Work/MasterLib/"
          bibtex-completion-pdf-field nil
          bibtex-completion-notes-path "~/Dropbox/org-files/articles.org"
          ;; bibtex-completion-additional-search-fields '(keywords)
          bibtex-completion-notes-extension ".org"
          helm-bibtex-full-frame nil) 

  ;; Set global shortcut for calling helm-bibtex
  )
#+end_src
** Markdown mode
*** Markdown settings
#+begin_src emacs-lisp
  (use-package markdown-mode
    :mode (("\\.markdown\\'" . markdown-mode)
           ("\\.md\\'"       . markdown-mode))
    :init
    ;; markdown hooks
    (add-hook 'markdown-mode-hook
          '(lambda ()
             (turn-on-auto-fill) (centered-cursor-mode) (git-gutter-mode 1) (set-fill-column 78) (hl-todo-mode)))
    (setq markdown-command "pandoc -s -N --smart --bibliography=~/Dropbox/Work/Master.bib"
            markdown-enable-math t
            markdown-nested-imenu-heading-index t
            markdown-open-command "~/bin/scripts/mark.sh"
            markdown-footnote-location 'immediately
            )
       ;; add keybindings to hook
     :config
     ;; remove strikout comment face
     (set-face-attribute 'markdown-comment-face nil 
     :weight 'bold :strike-through nil)

     )


#+end_src
*** Pandoc
Pandoc mode for markdown conversion
#+BEGIN_SRC emacs-lisp
  (use-package pandoc-mode
    :commands (cpm/pandoc-convert-to-pdf run-pandoc pandoc-convert-to-pdf)
    :config
    (progn
      (defun run-pandoc ()
        "Start pandoc for the buffer and open the menu"
        (interactive)
        (pandoc-mode)
        (pandoc-main-hydra/body))
      (add-hook 'pandoc-mode-hook 'pandoc-load-default-settings)

    (defun cpm/pandoc-convert-to-pdf ()
     (interactive)
     (cond
     ((eq major-mode 'org-mode)
      (call-interactively 'org-pandoc-export-to-latex-pdf-and-open))
     (t
      (call-interactively 'pandoc-convert-to-pdf) (cpm/pandoc-pdf-open) (evil-window-prev 1))))

    (defun cpm/pandoc-command-line-convert-to-pdf ()
     "convert to pdf"
     (interactive)
     (evil-ex "!pandoc -s -N -V mainfont=Optima --pdf-engine=xelatex --bibliography=~/Dropbox/Work/Master.bib --template=~/.pandoc/pandoc-templates/default.latex -o '%.pdf' '%'"))

    (defun cpm/pandoc-pdf-open ()
     "Open created PDF file"  
     (interactive)
     (find-file-other-window (concat (file-name-sans-extension buffer-file-name) ".pdf"))))
    :init
    (progn
      (setq pandoc-data-dir (concat cpm-etc-dir "pandoc-mode/"))
      ;; help pandoc find xelatex
      (setenv "PATH" (concat (getenv "PATH") ":/Library/TeX/texbin"))))
#+END_SRC
** Writeroom (Distraction free mode)
This simulates programs like writeroom that provide a distraction-free
mode of writing. 
#+BEGIN_SRC emacs-lisp
(use-package writeroom-mode
  :commands (writeroom-mode)
  :config
  (setq writeroom-fullscreen-effect 'maximized)
  (setq writeroom-width 85))
    (defun distraction-free ()
    "distraction free writing"
      (interactive)
      (git-gutter-mode 0) 
      (linum-mode 0) 
      (centered-cursor-mode)
      (writeroom-mode)
      )

#+END_SRC
** Deft Notes
#+BEGIN_SRC emacs-lisp
  (use-package deft
    :commands (deft deft-find-file cpm/deft)
    :init
    (progn
      ;; start in insert mode
      (add-to-list 'evil-insert-state-modes 'deft-mode)
      (setq deft-extensions '("org" "md" "txt")
            deft-directory "~/Dropbox/org-files"
            deft-text-mode 'org-mode
            deft-use-filter-string-for-filename t ;; use filter string as filename
            deft-org-mode-title-prefix t ;; add #+TITLE prefix
            deft-recursive t  ;; search recursively in folders
            deft-use-filename-as-title t)
    :config
    ;; Make sure titles have no spaces: from [[http://pragmaticemacs.com/category/deft/][pragmaticemacs]]
    ;;advise deft-new-file-named to replace spaces in file names with -
    (defun bjm-deft-strip-spaces (args)
    "Replace spaces with - in the string contained in the first element of the list args. Used to advise deft's file naming function."
    (list (replace-regexp-in-string " " "-" (car args)))
    )
    (advice-add 'deft-new-file-named :filter-args #'bjm-deft-strip-spaces)

  ;;function to run deft in specified directory
  (defun any-deft (dir)
    "Run deft in directory DIR"
    (setq deft-directory dir)
    (switch-to-buffer "*Deft*")
    (kill-this-buffer)
    (require 'org)
    (deft)
    )
  (defun big-notes ()
    "Goto main notes with deft"
    (interactive)
    (any-deft "~/Dropbox/Notes")
    (kill-this-buffer)
    (any-deft "~/Dropbox/Notes")
  )
  (defun research-notes ()
    "Goto research notes"
    (interactive)
    (any-deft "~/Dropbox/org-files/Wiki"))))
#+END_SRC
** Interleave
[[https://github.com/rudolfochrist/interleave][Interleave]] your reading notes with the PDF.
#+BEGIN_SRC emacs-lisp
(use-package interleave
  :commands interleave)
#+END_SRC
** Lorem ipsum
Make arbitrary blocks or sentences of text.
#+BEGIN_SRC emacs-lisp
  (use-package lorem-ipsum
    :commands (Lorem-ipsum-insert-sentences Lorem-ipsum-insert-list Lorem-ipsum-insert-paragraphs)
    :config 
    (lorem-ipsum-use-default-bindings)
    )

#+END_SRC
** Palimpsest mode
#+BEGIN_SRC emacs-lisp
  (use-package palimpsest
    :defer t
    :diminish palimpsest-mode
    :init 
    (add-hook 'markdown-mode-hook 'palimpsest-mode)
    (add-hook 'org-mode-hook 'palimpsest-mode)
    :config
    (setq palimpsest-trash-file-suffix ".archive"))
#+END_SRC
** LaTeX

#+BEGIN_SRC emacs-lisp
;; Basic settings
(use-package auctex
  :mode ("\\.tex\\'" . latex-mode)
  :commands (latex-mode LaTeX-mode plain-tex-mode)
  :init
  (progn
    (add-hook 'LaTeX-mode-hook #'LaTeX-preview-setup)
    (add-hook 'LaTeX-mode-hook #'flyspell-mode)
    (add-hook 'LaTeX-mode-hook #'turn-on-reftex)
    (setq-default TeX-engine 'xetex)
    (setq TeX-auto-save t
          TeX-parse-self t
          TeX-save-query nil
          TeX-PDF-mode t)
    (setq-default TeX-master nil)))

(use-package preview
  :ensure nil
  :after auctex
  :commands LaTeX-preview-setup
  :init
  (progn
    (setq-default preview-scale 1.4
      preview-scale-function '(lambda () (* (/ 10.0 (preview-document-pt)) preview-scale)))))

(use-package reftex
  :commands turn-on-reftex
  :init
  (progn
    (setq reftex-plug-into-AUCTeX t)))

(use-package bibtex
  :defer t
  :mode ("\\.bib" . bibtex-mode)
  :init
  (progn
    (setq bibtex-align-at-equal-sign t)
    (add-hook 'bibtex-mode-hook (lambda () (set-fill-column 120)))))


;; Auto-fill for LaTeX
(defun schnouki/latex-auto-fill ()
  "Turn on auto-fill for LaTeX mode."
  (turn-on-auto-fill)
  (set-fill-column 80)
  (setq default-justification 'left))
(add-hook 'LaTeX-mode-hook #'schnouki/latex-auto-fill)

;; Compilation command
(add-hook 'LaTeX-mode-hook (lambda () (setq compile-command "latexmk -pdflatex=xelatex -f -pdf %f")))

;; Prevent ispell from verifying some LaTeX commands
;; http://stat.genopole.cnrs.fr/dw/~jchiquet/fr/latex/emacslatex
(defvar schnouki/ispell-tex-skip-alists
      '("cite" "nocite"
  "includegraphics"
  "author" "affil"
  "ref" "eqref" "pageref"
  "label"))
(setq ispell-tex-skip-alists
      (list
       (append (car ispell-tex-skip-alists)
         (mapcar #'(lambda (cmd) (list (concat "\\\\" cmd) 'ispell-tex-arg-end)) schnouki/ispell-tex-skip-alists))
       (cadr ispell-tex-skip-alists)))

;; Indentation with align-current in LaTeX environments
(defvar schnouki/LaTeX-align-environments '("tabular" "tabular*"))
(add-hook 'LaTeX-mode-hook
    (lambda ()
      (require 'align)
      (setq LaTeX-indent-environment-list
      ;; For each item in the list...
      (mapcar (lambda (item)
          ;; The car is an environment
          (let ((env (car item)))
            ;; If this environment is in our list...
            (if (member env schnouki/LaTeX-align-environments)
          ;; ...then replace this item with a correct one
          (list env 'align-current)
        ;; else leave it alone
        item)))
        LaTeX-indent-environment-list))))

;; Use dvipdfmx to convert DVI files to PDF in AUCTeX
(eval-after-load 'tex
  '(add-to-list 'TeX-command-list
                '("DVI to PDF" "dvipdfmx %d" TeX-run-command t t) t))

;; SyncTeX (http://www.emacswiki.org/emacs/AUCTeX#toc19)
(defun synctex/un-urlify (fname-or-url)
  "A trivial function that replaces a prefix of file:/// with just /."
  (if (string= (substring fname-or-url 0 8) "file:///")
      (substring fname-or-url 7)
    fname-or-url))

#+END_SRC


** PDF-Tools
Better than doc-view, but doesn't render well on retina screens :(
#+BEGIN_SRC emacs-lisp 
      (use-package pdf-tools
        :mode (("\\.pdf$" . pdf-view-mode))
        :config
        (progn
          (pdf-tools-install)
          (evil-set-initial-state 'pdf-view-mode 'normal)
          (evil-set-initial-state 'pdf-outline-buffer-mode 'normal)
          (general-define-key :states '(normal) :keymaps 'pdf-view-mode-map
              ;; Navigation
              "j"  'pdf-view-next-line-or-next-page
              "k"  'pdf-view-previous-line-or-previous-page
              "l"  'pdf-view-next-page 
              "h"  'pdf-view-previous-page
              "J"  'image-forward-hscroll
              "K"  'image-backward-hscroll
              "gg"  'pdf-view-first-page
              "G"  'pdf-view-last-page
              "gt"  'pdf-view-goto-page
              "gl"  'pdf-view-goto-label
              "u" 'pdf-view-scroll-down-or-previous-page
              "d" 'pdf-view-scroll-up-or-next-page
              "-"  'pdf-view-shrink
              "+"  'pdf-view-enlarge
              "="  'pdf-view-fit-page-to-window
              (kbd "C-u") 'pdf-view-scroll-down-or-previous-page
              (kbd "C-d") 'pdf-view-scroll-up-or-next-page
              (kbd "``")  'pdf-history-backward
              ;; Search
              "/" 'isearch-forward
              "?" 'isearch-backward
              ;; Actions
              "r"   'pdf-view-revert-buffer
              "o"   'pdf-links-action-perform
              "O"   'pdf-outline
              )
          (general-define-key :states '(insert) :keymaps 'pdf-view-mode-map
              "y" 'pdf-view-kill-ring-save )

         ;; midnite mode
         (setq pdf-view-midnight-colors '("#839496" . "#002b36" )) ; original values

         (defun bms/pdf-no-filter ()
         "View pdf without colour filter."
         (interactive)
         (pdf-view-midnight-minor-mode -1)
         )

        ;; change midnite mode colours functions
        (defun bms/pdf-midnite-original ()
          "Set pdf-view-midnight-colors to original colours."
          (interactive)
          (setq pdf-view-midnight-colors '("#839496" . "#002b36" )) ; original values
          (pdf-view-midnight-minor-mode)
          )

        (defun bms/pdf-midnite-amber ()
          "Set pdf-view-midnight-colors to amber on dark slate blue."
          (interactive)
          (setq pdf-view-midnight-colors '("#ff9900" . "#0a0a12" )) ; amber
          (pdf-view-midnight-minor-mode)
          )

        (defun bms/pdf-midnite-green ()
          "Set pdf-view-midnight-colors to green on black."
          (interactive)
          (setq pdf-view-midnight-colors '("#00B800" . "#000000" )) ; green
          (pdf-view-midnight-minor-mode)
          )

        (defun bms/pdf-midnite-colour-schemes ()
          "Midnight mode colour schemes bound to keys"
                (local-set-key (kbd "!") (quote bms/pdf-no-filter))
                (local-set-key (kbd "@") (quote bms/pdf-midnite-amber))
                (local-set-key (kbd "#") (quote bms/pdf-midnite-green))
                    (local-set-key (kbd "$") (quote bms/pdf-midnite-original))
         )
          ;; midnite mode hook
          (add-hook 'pdf-view-mode-hook (lambda ()
                                          (bms/pdf-midnite-colour-schemes)
                                          ; automatically turns on midnight-mode for pdfs
                                          (pdf-view-midnight-minor-mode)
                                          ; fixes blinking pdf in evil
                                          (blink-cursor-mode -1)
                                          (beacon-mode -1)))

    ))      

#+END_SRC
*** Org PDF View
 For annotation and jumping to file
#+BEGIN_SRC emacs-lisp
  (use-package org-pdfview
    :commands (org-pdfview-open)
    :init
    (add-to-list 'org-file-apps 
               '("\\.pdf\\'" . (lambda (file link)
                                  (org-pdfview-open link))))
   )
#+END_SRC
*** Extract annotations
#+BEGIN_SRC emacs-lisp
  (use-package pdf-tools-org 
    :ensure nil
    :commands (pdf-tools-org-export-to-org pdf-tools-org-import-from-org))

      ;; Extracting annotations using pdf-tools
      ;; modified from https://github.com/politza/pdf-tools/pull/133 
      ;; taken from http://matt.hackinghistory.ca/2015/11/11/note-taking-with-pdf-tools/

      (defun mwp/pdf-multi-extract (sources)
      "Helper function to print highlighted text from a list of pdf's, with one org header per pdf, 
      and links back to page of highlight."
      (let (
            (output ""))
        (dolist (thispdf sources)
          (setq output (concat output (pdf-annot-markups-as-org-text thispdf nil level ))))
        (princ output))
      )

      (defun cpm/pdf-summary-extract (sources)
      "Helper function to print underlined text from a list of pdf's, with one org header per pdf, 
      and links back to page of highlight."
      (let (
            (output ""))
        (dolist (thispdf sources)
          (setq output (concat output (pdf-annot-summary-as-org-text thispdf nil level ))))
        (princ output))
      )

      ;; this is stolen from https://github.com/pinguim06/pdf-tools/commit/22629c746878f4e554d4e530306f3433d594a654
      (defun pdf-annot-edges-to-region (edges)
      "Attempt to get 4-entry region \(LEFT TOP RIGHT BOTTOM\) from several edges.
      We need this to import annotations and to get marked-up text, because annotations
      are referenced by its edges, but functions for these tasks need region."

      (let ((left0 (nth 0 (car edges)))
            (top0 (nth 1 (car edges)))
            (bottom0 (nth 3 (car edges)))
            (top1 (nth 1 (car (last edges))))
            (right1 (nth 2 (car (last edges))))
            (bottom1 (nth 3 (car (last edges))))
            (n (safe-length edges)))
        ;; we try to guess the line height to move
        ;; the region away from the boundary and
        ;; avoid double lines
        (list left0
              (+ top0 (/ (- bottom0 top0) 2))
              right1
              (- bottom1 (/ (- bottom1 top1) 2 )))))

      (defun pdf-annot-markups-as-org-text (pdfpath &optional title level)
      "Acquire highligh annotations as text, and return as org-heading"

      (interactive "fPath to PDF: ")  
      (let* ((outputstring "") ;; the text to be returned
              (title (or title (replace-regexp-in-string "-" " " (file-name-base pdfpath ))))
              (level (or level (1+ (org-current-level)))) ;; I guess if we're not in an org-buffer this will fail
              (levelstring (make-string level ?*)) ;; set headline to proper level
              (annots (sort (pdf-info-getannots nil pdfpath)  ;; get and sort all annots
                            'pdf-annot-compare-annotations)))
        ;; create the header
        (setq outputstring (concat levelstring " Quotes From " title "\n\n")) ;; create heading

        ;; extract text
        (mapc
          (lambda (annot) ;; traverse all annotations
            (if (eq 'highlight (assoc-default 'type annot))
                (let* ((page (assoc-default 'page annot))
                      ;; use pdf-annot-edges-to-region to get correct boundaries of annotation
                      (real-edges (pdf-annot-edges-to-region
                                    (pdf-annot-get annot 'markup-edges)))
                      (text (or (assoc-default 'subject annot) (assoc-default 'content annot)
                                (replace-regexp-in-string "\n" " " (pdf-info-gettext page real-edges nil pdfpath))))

                      (height (nth 1 real-edges)) ;; distance down the page
                      ;; use pdfview link directly to page number
                      (linktext (concat "[[pdfview:" pdfpath "::" (number-to-string page) 
                                        "++" (number-to-string height) "][" title  "]]" )))
                  (setq outputstring (concat outputstring text " ("
                                            linktext ", " (number-to-string page) ")\n\n"))
                  ))

            (if (eq 'text (assoc-default 'type annot))
                (let* ((page (assoc-default 'page annot))
                      ;; use pdf-annot-edges-to-region to get correct boundaries of annotation
                      (real-edges (pdf-annot-edges-to-region
                                    (pdf-annot-get annot 'markup-edges)))
                      (text (or (assoc-default 'subject annot) (assoc-default 'content annot)
                                (replace-regexp-in-string "\n" " " (pdf-info-gettext page real-edges nil pdfpath))))

                      (height (nth 1 real-edges)) ;; distance down the page
                      ;; use pdfview link directly to page number
                      (linktext (concat "[[pdfview:" pdfpath "::" (number-to-string page) 
                                        "++" (number-to-string height) "][" title  "]]" )))
                  (setq outputstring (concat outputstring text " ("
                                            linktext ", " (number-to-string page) ")\n\n"))
                  ))

              (if (eq 'underline (assoc-default 'type annot))
                  (let* ((page (assoc-default 'page annot))
                        ;; use pdf-annot-edges-to-region to get correct boundaries of highlight
                        (real-edges (pdf-annot-edges-to-region
                                      (pdf-annot-get annot 'markup-edges)))
                        (text (or (assoc-default 'subject annot) (assoc-default 'content annot)
                                  (replace-regexp-in-string "\n" " " (pdf-info-gettext page real-edges nil pdfpath))))

                        (height (nth 1 real-edges)) ;; distance down the page
                        ;; use pdfview link directly to page number
                        (linktext (concat "[[pdfview:" pdfpath "::" (number-to-string page) 
                                          "++" (number-to-string height) "][" title  "]]" )))
                    (setq outputstring (concat outputstring text " ("
                                              linktext ", " (number-to-string page) ")\n\n"))
                    ))
                  )
          annots)
        outputstring ;; return the header
        )
      )

      (defun pdf-annot-summary-as-org-text (pdfpath &optional title level)
      "Acquire underlined annotations as text, and return as org-heading"

      (interactive "fPath to PDF: ")  
      (let* ((outputstring "") ;; the text to be returned
              (title (or title (replace-regexp-in-string "-" " " (file-name-base pdfpath ))))
              (level (or level (1+ (org-current-level)))) ;; I guess if we're not in an org-buffer this will fail
              (levelstring (make-string level ?*)) ;; set headline to proper level
              (annots (sort (pdf-info-getannots nil pdfpath)  ;; get and sort all annots
                            'pdf-annot-compare-annotations)))
        ;; create the header
        (setq outputstring (concat levelstring " Summary from " title "\n\n")) ;; create heading

        ;; extract text
        (mapc
          (lambda (annot) ;; traverse all annotations
              (if (eq 'underline (assoc-default 'type annot))
                  (let* ((page (assoc-default 'page annot))
                        ;; use pdf-annot-edges-to-region to get correct boundaries of annotation
                        (real-edges (pdf-annot-edges-to-region
                                      (pdf-annot-get annot 'markup-edges)))
                        (text (or (assoc-default 'subject annot) (assoc-default 'content annot)
                                  (replace-regexp-in-string "\n" " " (pdf-info-gettext page real-edges nil pdfpath))))

                        (height (nth 1 real-edges)) ;; distance down the page
                        ;; use pdfview link directly to page number
                        (linktext (concat "[[pdfview:" pdfpath "::" (number-to-string page) 
                                          "++" (number-to-string height) "][" title  "]]" )))
                    (setq outputstring (concat outputstring text " ("
                                              linktext ", " (number-to-string page) ")\n\n"))
                    ))
                  )
          annots)
        outputstring ;; return the header
        )
      )

#+END_SRC
** Zotero
Interface with Zotero.
#+BEGIN_SRC emacs-lisp
  (use-package zotxt
    :after (any: org markdown-mode)
    :demand t
    :commands (org-zotxt-mode zotxt-easykey-mode org-zotxt-insert-reference-link-to-item org-zotxt-open-attachment org-zotxt-update-reference-link-at-point)
    :diminish (org-zoxt zotxt org-zotxt-mode)
    :config
    (setq org-zotxt-default-search-method :title-creator-year)
    )

#+END_SRC


* Private
#+BEGIN_SRC emacs-lisp
(let ((private (expand-file-name "private.el" cpm-cache-dir))) 
  (if (file-exists-p private)
	  (load-file private)))
#+END_SRC

* Miscellaneous Packages
** Restart emacs
#+BEGIN_SRC emacs-lisp
(use-package restart-emacs
  :commands restart-emacs)
#+END_SRC
** Autorevert
Auto-revert buffers of changed files
#+BEGIN_SRC emacs-lisp
  (use-package autorevert                 
    :ensure nil
    :defer 8
    :init
    (setq auto-revert-interval 1)
    (global-auto-revert-mode 1)
    :config
    (progn 
      (setq auto-revert-verbose nil ; Shut up, please!
            revert-without-query '(".*") ;; disable revert query
            ;; Revert Dired buffers, too
            global-auto-revert-non-file-buffers t)))
#+END_SRC
** URL & Request
#+BEGIN_SRC emacs-lisp
(use-package request
  :defer 10
  :ensure nil
  :config
  (setq request-storage-directory (concat cpm-cache-dir "request"))
)
#+END_SRC
* Post-Initialization
** Remember
A built-in [[info:remember][remember]] buffer
#+BEGIN_SRC emacs-lisp
(use-package remember
 :ensure nil
 :commands (remember remember-notes)
 :config
 (setq remember-data-dir (concat cpm-cache-dir "remember")
       remember-data-file (concat cpm-cache-dir "remember/notes"))
 (unless (file-directory-p remember-data-dir)
         (make-directory remember-data-dir t)))
 
#+END_SRC
** Server
Start server
#+BEGIN_SRC emacs-lisp
  (use-package server
   :defer 10
   :config
    (if (display-graphic-p)
        (unless (or (daemonp) (server-running-p))
           (message "Starting server..")
           (server-start)))
    )
#+END_SRC
** Page Breaks
Dashboard depends on this. 
#+BEGIN_SRC emacs-lisp
(use-package page-break-lines
  :defer t
  :diminish "")
#+END_SRC
** Dashboard
Startup with a [[https://github.com/rakanalh/emacs-dashboard][dashboard]] listing recent files, bookmarks, and projects.
#+BEGIN_SRC emacs-lisp
    (use-package dashboard
      :commands (dashboard-insert-startupify-lists cpm/dashboard)
      :config
      (setq dashboard-items '((agenda . 5)
                              (recents  . 5)
                              (bookmarks . 5)
                              (projects . 5)
                              (totd . 1)))

        ;; tip of the day
        (defun totd()
        (let* ((commands (loop for s being the symbols
        when (commandp s) collect s))
        (command (nth (random (length commands)) commands)))
        (insert
        (format "** Tip of the day: ** \nCommand: %s\n\n%s\n\nInvoke with:\n\n"
        (symbol-value 'command)
        (documentation command)))
        (where-is command t)))
        (defun dashboard-insert-totd (list-size) (totd)) (add-to-list 'dashboard-item-generators '(totd . dashboard-insert-totd))

        (setq dashboard-startup-banner 2)
        ;; (dashboard-setup-startup-hook)
        (map! (:map dashboard-mode-map
          :ni     "TAB" 'widget-forward
          :ni     "C-i" 'widget-forward
          :ni     "backtab" 'widget-backward
          :ni     "RET" 'widget-button-press
          :ni     "down-mouse-1" 'widget-button-click
          :ni     "g" #'dashboard-insert-startupify-lists
          :ni     "a" (dashboard-insert-shortcut "a" "Agenda for today:")
          :ni     "r" (dashboard-insert-shortcut "r" "Recent Files:")
          :ni     "m" (dashboard-insert-shortcut "m" "Bookmarks:")
          :ni     "p" (dashboard-insert-shortcut "p" "Projects:"))))

  ;; from https://www.reddit.com/r/emacs/comments/8jaflq/tip_how_to_use_your_dashboard_properly/
  (defun cpm/dashboard-banner ()
    "Set a dashboard banner including information on package initialization
     time and garbage collections."
    (setq dashboard-banner-logo-title
          (format "Emacs ready in %.2f seconds with %d garbage collections."
                  (float-time (time-subtract after-init-time before-init-time)) gcs-done)))


  (defun cpm/dashboard ()
   "load dashboard and swith to buffer"
  (interactive)
  (let ((buffer "*dashboard*"))
    (when (not (get-buffer buffer))
      (dashboard-insert-startupify-lists))
    (switch-to-buffer buffer)))

  (defun goto-dashboard ()
    "goto the dashboard"
    (interactive)
    (switch-to-buffer "*dashboard*"))
#+END_SRC
** Startup time
Display Startup time
#+BEGIN_SRC emacs-lisp

(message "Start up time %.2fs" (float-time (time-subtract (current-time) my-start-time)))

#+END_SRC

* Test
** FIXME Tabs
Buffer tabs in modeline or Echo are. [[https://github.com/linktohack/buffer-line][Pictures]] help. Works well, especially
with a toggle but I need to figure out evil bindings to make it easy to
key a buffer up quickly. 
#+BEGIN_SRC emacs-lisp
(use-package buffer-line
  :load-path "~/.emacs.d/.local/elisp/buffer-line/"
  :commands buffer-line-mode
  :init
  (setq buffer-line-place 'echo-area)    ; Acceptable value: `nil' or `echo-area', `mode-line'
  (setq buffer-line-mode-line-limit 60)  ; In case of `mode-line'.
  )
#+END_SRC
** TESTING Academic Phrases
Use common [[https://github.com/nashamri/academic-phrases][academic phrases]] in papers
#+BEGIN_SRC emacs-lisp
(use-package academic-phrases
 :commands (academic-phrases academic-phrases-by-section))
#+END_SRC
** TESTING Org Projectile
:PROPERTIES:
:DATE_ADDED: March 3, 2018
:END:

[[https://github.com/IvanMalison/org-projectile][Manage]] project TODOs with org mode and projectile. Seems like it will be
useful but we'll see.  

#+BEGIN_SRC emacs-lisp
(use-package org-projectile
  :general 
  (:states '(normal visual emacs)
  :keymaps 'override
  :prefix "SPC"
  :non-normal-prefix "C-SPC"
  "p" '(:ignore t :which-key "Projects")
  "pt" 'org-projectile-project-todo-completing-read)
  :config
  (progn
    (setq org-projectile-projects-file
          "~/Dropbox/org-files/projects.org")
    (setq org-agenda-files (append org-agenda-files (org-projectile-todo-files)))
    (push (org-projectile-project-todo-entry) org-capture-templates))
  :ensure t)
#+END_SRC
** TESTING Eterm-256 Color
Add [[https://github.com/dieggsy/eterm-256color][customizable 256 color support]] to =term= and =ansiterm=
#+BEGIN_SRC emacs-lisp
  (use-package eterm-256color
    :ensure t
    :config
    (add-hook 'term-mode-hook #'eterm-256color-mode))
#+END_SRC
# "
** TESTING Quelpa
Get emacs packages from [[https://github.com/quelpa/quelpa#installation][anywhere]] and use with [[https://github.com/quelpa/quelpa-use-package][use-package]]
#+BEGIN_SRC emacs-lisp
  (use-package quelpa
    :ensure t
    :demand t
    :init
    ;; disable checking Melpa
    (setq quelpa-update-melpa-p nil)
    ;; don't use Melpa at all
    (setq quelpa-checkout-melpa-p nil)
    ;; quelpa dir settings
    (setq quelpa-dir (concat cpm-local-dir "quelpa")))

  (use-package quelpa-use-package
    :ensure t
    :demand t
    :config
    ;; advince for maybe installing with quelpa
    (quelpa-use-package-activate-advice))


#+END_SRC
** TESTING Github Stars
Browse your [[https://github.com/xuchunyang/github-stars.el/tree/894a2c3fd72ae233f7cce63f3af45afc32f18be3][Github stars]]
#+BEGIN_SRC emacs-lisp
  (use-package github-stars
    :ensure t
    :quelpa (github-stars :fetcher github :repo "xuchunyang/github-stars.el"))
#+END_SRC
** TESTING Mixed-Pitch
Mix fixed-pitch and variable-pitch fonts [[https://github.com/jabranham/mixed-pitch/tree/b6b1601c7a3eb9ab23e33192bc479bccc4dd5e7b][in Emacs]]
#+BEGIN_SRC emacs-lisp
(use-package mixed-pitch)
#+END_SRC
** TESTING Shell Path
#+BEGIN_SRC emacs-lisp
(use-package exec-path-from-shell
  :if (eq system-type 'darwin)
  :custom
  (exec-path-from-shell-check-startup-files nil)
  :config
  (exec-path-from-shell-initialize))
#+END_SRC
** TESTING Ligatures
Per the [[https://github.com/i-tu/Hasklig/issues/84][discussion here]]. 
#+BEGIN_SRC emacs-lisp 
 (defun my-correct-symbol-bounds (pretty-alist)
    "Prepend a TAB character to each symbol in this alist,
this way compose-region called by prettify-symbols-mode
will use the correct width of the symbols
instead of the width measured by char-width."
    (mapcar (lambda (el)
              (setcdr el (string ?\t (cdr el)))
              el)
            pretty-alist))

  (defun my-ligature-list (ligatures codepoint-start)
    "Create an alist of strings to replace with
codepoints starting from codepoint-start."
    (let ((codepoints (-iterate '1+ codepoint-start (length ligatures))))
      (-zip-pair ligatures codepoints)))

  ; list can be found at https://github.com/i-tu/Hasklig/blob/master/GlyphOrderAndAliasDB#L1588
  (setq my-hasklig-ligatures
    (let* ((ligs '("&&" "***" "*>" "\\\\" "||" "|>" "::"
                   "==" "===" "==>" "=>" "=<<" "!!" ">>"
                   ">>=" ">>>" ">>-" ">-" "->" "-<" "-<<"
                   "<*" "<*>" "<|" "<|>" "<$>" "<>" "<-"
                   "<<" "<<<" "<+>" ".." "..." "++" "+++"
                   "/=" ":::" ">=>" "->>" "<=>" "<=<" "<->")))
      (my-correct-symbol-bounds (my-ligature-list ligs #Xe100))))

  ;; nice glyphs for haskell with hasklig
  (defun my-set-hasklig-ligatures ()
    "Add hasklig ligatures for use with prettify-symbols-mode."
    (setq prettify-symbols-alist
          (append my-hasklig-ligatures prettify-symbols-alist))
    (prettify-symbols-mode))

  (add-hook 'text-mode-hook 'my-set-hasklig-ligatures)
#+END_SRC
** TESTING Emacs Anywhere
https://github.com/zachcurry/emacs-anywhere
#+BEGIN_SRC emacs-lisp
  (defun popup-handler (app-name window-title x y w h)
    (cond (t (markdown-mode))) ; default major mode)
    (setq ea-x 300
          ea-y 400
          ea-width 90
          ea-height 15
          ea-paste t)

    ;; Hook your function
    (add-hook 'ea-popup-hook 'popup-handler)
    )
#+END_SRC
** TESTING Neotree
A [[https://github.com/jaypei/emacs-neotree][emacs tree plugin]] like NerdTree for Vim
#+BEGIN_SRC emacs-lisp
(use-package neotree
  :bind ("s-t" . neotree)
  :config
  (setq neo-dont-be-alone t
        neo-theme 'icons
        neo-smart-open t
        projectile-switch-project-action 'neotree-projectile-action)
  (evil-define-key 'normal neotree-mode-map (kbd "TAB") 'neotree-enter)
  (evil-define-key 'normal neotree-mode-map (kbd "SPC") 'neotree-quick-look)
  (evil-define-key 'normal neotree-mode-map (kbd "q") 'neotree-hide)
  (evil-define-key 'normal neotree-mode-map (kbd "RET") 'neotree-enter)
  (evil-define-key 'normal neotree-mode-map (kbd "u") 'neotree-select-up-node)
  (evil-define-key 'normal neotree-mode-map (kbd "i") 'neotree-enter)
  (evil-define-key 'normal neotree-mode-map (kbd "K") 'neotree-delete-node))
#+END_SRC
[[https://github.com/Alexander-Miller/treemacs][Treemacs]] is a file and project explorer 
#+BEGIN_SRC emacs-lisp
  (use-package treemacs
    :ensure t
    :defer t
    :init
    (with-eval-after-load 'winum
      (define-key winum-keymap (kbd "M-0") #'treemacs-select-window))
    :config
    (progn
      (setq treemacs-collapse-dirs              (if (executable-find "python") 3 0)
            treemacs-file-event-delay           5000
            treemacs-follow-after-init          t
            treemacs-follow-recenter-distance   0.1
            treemacs-goto-tag-strategy          'refetch-index
            treemacs-indentation                2
            treemacs-indentation-string         " "
            treemacs-is-never-other-window      nil
            treemacs-no-png-images              nil
            treemacs-project-follow-cleanup     nil
            treemacs-persist-file               (expand-file-name ".cache/treemacs-persist" user-emacs-directory)
            treemacs-recenter-after-file-follow nil
            treemacs-recenter-after-tag-follow  nil
            treemacs-show-hidden-files          t
            treemacs-silent-filewatch           nil
            treemacs-silent-refresh             nil
            treemacs-sorting                    'alphabetic-desc
            treemacs-space-between-root-nodes   t
            treemacs-tag-follow-cleanup         t
            treemacs-tag-follow-delay           1.5
            treemacs-width                      35)

      (treemacs-follow-mode t)
      (treemacs-filewatch-mode t)
      (pcase (cons (not (null (executable-find "git")))
                   (not (null (executable-find "python3"))))
        (`(t . t)
         (treemacs-git-mode 'extended))
        (`(t . _)
         (treemacs-git-mode 'simple)))))
    ;; :bind
    ;; (:map global-map
    ;;       ("M-0"       . treemacs-select-window)
    ;;       ("C-x t 1"   . treemacs-delete-other-windows)
    ;;       ("C-x t t"   . treemacs)
    ;;       ("C-x t B"   . treemacs-bookmark)
    ;;       ("C-x t C-t" . treemacs-find-file)
    ;;       ("C-x t M-t" . treemacs-find-tag)))

  (use-package treemacs-evil
    :after treemacs evil
    :ensure t)

  (use-package treemacs-projectile
    :after treemacs projectile
    :ensure t)
#+END_SRC
