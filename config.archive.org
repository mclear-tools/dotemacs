** Zetteldeft
#+BEGIN_SRC emacs-lisp
  (use-package zetteldeft
    :ensure nil
    :load-path "~/.emacs.d/.local/elisp/zetteldeft"
    :commands (zd-new-file zd-find-file zd-deft-new-search)
    :after deft
    :demand t) 
#+END_SRC


** Zetteldeft
A useful set of functions for managing a Zettelkasten. From [[https://github.com/EFLS/zetteldeft][EFLS]]. 
*** Package preparation

The required preamble and some other initial settings.
To know how this package works, please skip right past this to the next section.

**** Preamble

Some declaration.

#+BEGIN_SRC emacs-lisp
;;; zetteldeft.el --- a simple package                     -*- lexical-binding: t; -*-

;; Copyright (C) 2018  EFLS

;; Author: EFLS <email>
;; Keywords: deft zettelkasten zetteldeft
;; Version: 0.0.1

;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.

;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see <http://www.gnu.org/licenses/>.

;;; Commentary:

;; Zetteldeft: turn deft into a zettelkasten writing system to create linked notes.

;;; Code:
#+END_SRC

**** Requirements

=deft= is required, obviously, and =avy= is needed for some utility functions.

#+BEGIN_SRC emacs-lisp
(require 'deft)

(unless (package-installed-p 'avy)
  (user-error 'zetteldeft "Avy not installed, required for zd-avy-* functions."))
(require 'avy)
#+END_SRC

**** Customization

For easy but minor customization options.

#+BEGIN_SRC emacs-lisp
(defgroup zetteldeft nil
  "A zettelkasten on top of deft.")
#+END_SRC

*** Basic =zetteldeft= functions

In this section:
#+TOC: headlines 2 local

**** Search functions
***** =zd-get-thing-at-point= returns string

Returns the thing at point as string.

Tries to get, in the following order:
 - links between =[[=
 - hashtags: =§=, =#= or =@=
 - words

Based on snippet suggested by =saf-dmitry= on deft's [[https://github.com/jrblevin/deft/issues/52#issuecomment-401766828][Github]].

#+BEGIN_SRC emacs-lisp
(defun zd-get-thing-at-point ()
  "Return the thing at point, which can be a link, tag or word."
  (require 'thingatpt)
  (let* ((link-re "\\[\\[\\([^]]+\\)\\]\\]")
         (htag-re "\\([§#@][[:alnum:]_-]+\\)"))
   (cond
    ((thing-at-point-looking-at link-re)
      (match-string-no-properties 1))
     ((thing-at-point-looking-at htag-re)
      (match-string-no-properties 1))
     (t (thing-at-point 'word t)))))
#+END_SRC

***** =zd-search-at-point= thing at point

Search the thing at point.
Note that calling =zd-search-at-point= on a =§= link includes =§= in the filter string.

Based on snippet suggested by =saf-dmitry= on deft's [[https://github.com/jrblevin/deft/issues/52#issuecomment-401766828][Github]].

#+BEGIN_SRC emacs-lisp
(defun zd-search-at-point ()
  "Search deft with thing-at-point as filter.
Thing can be a double-bracketed link, a hashtag, or a word."
  (interactive)
  (let ((string (zd-get-thing-at-point)))
   (if string
       (zd-search-global string t)
     (user-error "No search term at point"))))
#+END_SRC

***** =zd-search-global= for string

Search with deft for given string.
If there is only one result, that file is opened, unless additional argument is true.

Based on snippet suggested by =saf-dmitry= on deft's [[https://github.com/jrblevin/deft/issues/52#issuecomment-401766828][Github]].

#+BEGIN_SRC emacs-lisp
(defun zd-search-global (str &optional dntOpn)
  "Search deft with STR as filter.
If there is only one result, open that file (unless DNTOPN is true)."
  ;; Sanitize the filter string
  (setq str (replace-regexp-in-string "[[:space:]\n]+" " " str))
  ;; Call deft search on the filter string
  (let ((deft-incremental-search t))
   (deft)
   (deft-filter str t))
  ;; If there is a single match, open the file
  (unless dntOpn
   (when (eq (length deft-current-files) 1)
     (deft-open-file (car deft-current-files)))))
#+END_SRC

***** =zd-search-filename= for string

Deft search on filename.
If there is only one result, open that file.

Incremental search is turned off, and the filter is set to filenames only.

#+BEGIN_SRC emacs-lisp
(defun zd-search-filename (thisStr &optional otherWindow)
  "Search for deft files with string THISSTR in filename.
Open if there is only one result (in another window if otherWindow is non-nill)."
  ;; Sanitize the filter string
  (setq thisStr (replace-regexp-in-string "[[:space:]\n]+" " " thisStr))
  ;; Call deft search on the filter string
  (let ((deft-filter-only-filenames t))
   (deft-filter thisStr t))
  ;; If there is a single match, open the file
  (when (eq (length deft-current-files) 1)
    (deft-open-file (car deft-current-files) otherWindow)))
#+END_SRC

***** =zd-search-current-id= searches current id

Deft search on the id of the current file.

This function is useful to easily see which notes link to the current file.

Result is not opened automaticaly.

Steps:
 1. Get the filename from the current buffer.
 2. Lift the ID from it.
 3. Search with resulting string.

#+BEGIN_SRC emacs-lisp
(defun zd-search-current-id ()
  "Search deft with the id of the current file as filter.
Open if there is only one result."
  (interactive)
  (zd--check)
  (zd-search-global (zd-lift-id (file-name-base (buffer-file-name))) t))
#+END_SRC

***** =zd-get-file-list= returns file list with search term

Get a list of the files with given search string.

To *fix*: sorting of results.

The code searches for the given string and returns =deft-current-files=.

#+BEGIN_SRC emacs-lisp
(defun zd-get-file-list (srch)
  "Returns a list of files with the search item SRCH."
  (let ((deft-current-sort-method 'title))
    (deft-filter srch t)
    deft-current-files))
#+END_SRC

**** IDs
***** =zd-id-format= for generating ID strings

String format when generating ids.

#+BEGIN_SRC emacs-lisp
(defcustom zd-id-format "%Y-%m-%d-%H%M"
  "Format used when generating zetteldeft IDs.
Be warned: the regexp to find these IDs is set separately."
  :type 'string
  :group 'zetteldeft)
#+END_SRC

While we're at it, lets tell deft to create new files with this new format.
For good measure: I advise creating new notes in the =zetteldeft= system with =zd-new-file= or =zd-new-file-and-link= as defined below.

#+BEGIN_SRC emacs-lisp
(setq deft-new-file-format zd-id-format)
#+END_SRC

Here is the function to generate an ID string in said format.

#+BEGIN_SRC emacs-lisp
(defun zd-generate-id ()
  "Generates an id in `zd-id-format'."
  (format-time-string zd-id-format))
#+END_SRC

***** =zd-id-regex= for finding IDs

The regular expression used to search for zetteldeft IDs.

This dictates that a zetteldeft ID should consist of:
 1. a series of exactly 4 numbers
 2. followed by exactly 3 sets of a dash and two or more numbers

#+BEGIN_SRC emacs-lisp
(defcustom zd-id-regex "[0-9]\\{4\\}\\(-[0-9]\\{2,\\}\\)\\{3\\}"
  "The regex used to search for zetteldeft IDs."
  :type 'string
  :group 'zetteldeft)
#+END_SRC

***** =zd-lift-id= filters the ID from a string

Return the zetteldeft ID from any string.

Searches with a temporary buffer, from the end of the string backwards (hence the =-1= argument), which implies that the last zetteldeft string is returned.

#+BEGIN_SRC emacs-lisp
(defun zd-lift-id (str)
  "Extract the zetteldeft ID from STR with the regular expression stored in `zd-id-regex'."
  (with-temp-buffer
    (insert str)
    (when (re-search-forward zd-id-regex nil t -1)
      (match-string 0))))
#+END_SRC

Or are there better ways than working =with-temp-buffer=?

Here is a little test.

#+BEGIN_SRC emacs-lisp :exports both :tangle no :results replace value
(zd-lift-id "2018-11-09-1934-12 Some text (1989) - testing (2000 p. 12-25)")
#+END_SRC

#+RESULTS:
: 2018-11-09-1934

**** Finding & linking files from minibuffer
***** =zd-find-file= opens file from minibuffer

Select file from the deft folder from the minibuffer.

Based on =deft-find-file=.

#+BEGIN_SRC emacs-lisp
(defun zd-find-file (file)
  "Open deft file FILE."
  (interactive
    (list (completing-read "Deft find file: "
           (deft-find-all-files-no-prefix))))
  (deft-find-file file))
#+END_SRC

***** =zd-find-file-id-insert= inserts file id

Select file from minibuffer and insert its link, prepended by =§=.

Based on =deft-find-file=.

#+BEGIN_SRC emacs-lisp
(defun zd-find-file-id-insert (file)
  "Find deft file FILE and insert its link id, prepended by §."
  (interactive (list
    (completing-read "File to insert id from: "
      (deft-find-all-files-no-prefix))))
  (insert (concat "§" (zd-lift-id file))))
#+END_SRC

***** =zd-find-file-full-title-insert= inserts id and title

Select file from minibuffer and insert its link, prepended by =§=.

Based on =deft-find-file=.

#+BEGIN_SRC emacs-lisp
(defun zd-find-file-full-title-insert (file)
  "Find deft file FILE and insert its link id with title, prepended by §."
  (interactive (list
    (completing-read "File to insert full title from: "
      (deft-find-all-files-no-prefix))))
  (insert (concat "§" (file-name-base file))))
#+END_SRC

**** New file creation
***** =zd-new-file= creates new file

Create new file with filename as =zd-id-format= and a string.

Either provide a name as argument, or enter one in the mini-buffer.
A title is automatically added to the file, unless an additioanl parameter is given.
When =evil= is used, enter the insert state as well.
The full name is added to the kill ring.
Note that the file is only actually created upon save.

#+BEGIN_SRC emacs-lisp
(defun zd-new-file (str &optional empty)
  "Create a new deft file. Filename is `zd-id-format' appended by STR. No extension needed.

After creating, the title is inserted in org-mode format (unless EMPTY is true) and the full file name is added to the kill ring."
  (interactive (list (read-string "name: ")))
  (let* ((zdId (zd-generate-id))
         (zdName (concat zdId " " str)))
  (deft-new-file-named zdName)
  (kill-new zdName)
  (unless empty (zd-insert-org-title))
  (when (featurep 'evil) (evil-insert-state))))
#+END_SRC

***** =zd-new-file-and-link= inserts generated id

Generate an id, append a name, and generate a new file based on id and link.

Either provide a name as argument, or enter one in the mini-buffer.

#+BEGIN_SRC emacs-lisp
(defun zd-new-file-and-link (str)
  "Inserts generated id with `zd-id-format' appended with STR.
Creates new deft file with id and STR as name."
  (interactive (list (read-string "name: ")))
  (insert "§" (zd-generate-id) " " str)
  (zd-new-file str))
#+END_SRC

**** Moving around with =avy=
***** =zd-avy-tag-search=

Use avy to jump to a tag and search for it.

The search term should include the =#= as tag identifier, so it's as easy as jumping to the =#= and running =zd-search-at-point=.

#+BEGIN_SRC emacs-lisp
(defun zd-avy-tag-search ()
  "Call on avy to jump and search tags indicated with #."
  (interactive)
  (save-excursion
   (avy-goto-char ?#)
   (zd-search-at-point)))
#+END_SRC

***** =zd-avy-link-search=

Use avy to jump to an id and search for it.

Jumps to the =§= identifier and searches for the thing at point -- excluding the =§= character.

#+BEGIN_SRC emacs-lisp
(defun zd-avy-link-search ()
  "Call on avy to jump and search link ids indicated with §.
Opens immediately if there is only one result."
  (interactive)
  (save-excursion
    (avy-goto-char ?§)
    (zd-search-global (zd-lift-id (zd-get-thing-at-point)))))
#+END_SRC

***** =zd-avy-file-search=

Select and follow an ID link to a file.

Use avy to jump to an id and find the corresponding file.
There should be only one result, as the id should be unique.
That file is then opend (in another window if requested).

Jump to a =§= with =avy=, get the thing at point.
If it is non-nil, search it after sanitizing.

#+BEGIN_SRC emacs-lisp
(defun zd-avy-file-search (&optional otherWindow)
 "Call on avy to jump to link ids indicated with § and use it to search for filenames.
Open that file (when it is the only search result, and in another window if OTHERWINDOW)."
  (interactive)
  (save-excursion
    (avy-goto-char ?§)
    (zd-search-filename (zd-lift-id (zd-get-thing-at-point)) otherWindow)))
#+END_SRC

Let's also define a function to open a file in another window.
Selection of the window occurs via =ace-window=.

#+BEGIN_SRC emacs-lisp
(defun zd-avy-file-search-ace-window ()
  "Call on avy to jump to link ids indicated with § and use it to search for filenames.
When there is only one search result, as there should be, open that file in a window selected through `ace-window'."
  (interactive)
  (require 'ace-window)
  (save-excursion
    (avy-goto-char ?§)
    (let ((ID (zd-lift-id (zd-get-thing-at-point))))
      (select-window (aw-select "Select window..."))
      (zd-search-filename ID))))
#+END_SRC

**** Utility functions
***** Deft new search

The following function launches deft, clears the filter and enters =evil-insert-state= (when evil is used).

#+BEGIN_SRC emacs-lisp
(defun zd-deft-new-search ()
  "Launch deft, clear filter and enter insert state."
  (interactive)
  (deft)
  (deft-filter-clear)
  (when (featurep 'evil) (evil-insert-state)))
#+END_SRC

***** =zd--check= checks if file is part of zetteldeft

A quick but necessary check to see whether the provided file is part of the deft directory.

To achieve this, take the directory of the current buffer file name and expand it to its absolute path.
Then check whether the =deft-directory= is part of that absolute path.
Signal a user error if it is not.

#+BEGIN_SRC emacs-lisp
(defun zd--check ()
  "Checks if the currently visited file is in `zetteldeft' territory: whether it has `deft-directory' somewhere in its path."
  (unless (string-match-p
            (regexp-quote deft-directory)
            (file-name-directory (buffer-file-name)))
    (user-error "Not in zetteldeft territory.")))
#+END_SRC

***** =zd-file-rename= renames visited file

Rename the current file.
Based on the function =deft-rename-file= with only minor changes in the way =old-filename= is set: from current buffer rather than from =deft= search buffer.

Probably requires some more testing.
Anyway, best to use this only when visiting a file in the deft directory.

The function also updates the =#+title:= at the top of the buffer, if any is present.

#+BEGIN_SRC emacs-lisp
(defun zd-file-rename ()
  "Rename the current file via the deft function. Use this on files in the deft-directory."
  (interactive)
  (zd--check)
    (let ((old-filename (buffer-file-name))
          (deft-dir (file-name-as-directory deft-directory))
          new-filename old-name new-name)
      (when old-filename
        (setq old-name (deft-base-filename old-filename))
        (setq new-name (read-string
                        (concat "Rename " old-name " to (without extension): ")
                        old-name))
        (setq new-filename
              (concat deft-dir new-name "." deft-default-extension))
        (rename-file old-filename new-filename)
        (deft-update-visiting-buffers old-filename new-filename)
        (zd-update-title-in-file)
        (deft-refresh))))
#+END_SRC

To update the title of the currently visited file, the following function is used.

#+BEGIN_SRC emacs-lisp
(defun zd-update-title-in-file ()
  "Update the #+TITLE in the current file, if present."
  (save-excursion
    (let ((zd-string-after-title ""))
      (goto-char (point-min))
      (when (search-forward "#+title:" nil t)
        (delete-region (line-beginning-position) (line-end-position))
        (zd-insert-org-title)))))
#+END_SRC

***** =zd-lift-file-title= returns file title from path

Returns only the file title from a file, removing path, extension, and link ID.

#+BEGIN_SRC emacs-lisp
(defun zd-lift-file-title (zdFile)
  "Returns the title of a zetteldeft note.
ZDFILE should be a full path to a note."
  (let ((baseName (file-name-base zdFile)))
    (replace-regexp-in-string
     "[0-9]\\{2,\\}-[0-9-]+[[:space:]]"
     "" baseName)))
#+END_SRC

***** =zd-insert-org-title= inserts file title in org-mode

Easily insert the title of the current file in =org-mode= syntax, i.e. as a =#+title:= line.

The code gets the base of the buffer file name, takes from it the file title (i.e. strips the link id at the beginning), and inserts the remaining string.

Below the title, an additional template string is inserted automatically.
This string, variable =zd-string-after-title=, can be customized and is empty by default.

#+BEGIN_SRC emacs-lisp
(defun zd-insert-org-title ()
  "Insert filename of current file as org syntax."
  (interactive)
  (zd--check)
  (insert
    "#+title: "
    (zd-lift-file-title (file-name-base (buffer-file-name)))
    zd-string-after-title))
#+END_SRC

Customize the string to be inserted below the title.
Used when generating a new file.

#+BEGIN_SRC emacs-lisp
(defcustom zd-string-after-title ""
  "String inserted below title when `zd-insert-org-title' is called.
Empty by default.
Don't forget to add `\\n' at the beginning to start a new line."
  :type 'string
  :group 'zetteldeft)
#+END_SRC

***** =zd-count-words= counts total number of words

To count the total number of words, lets loop over all the files and count words in each.
The total is printed in the minibuffer.

#+BEGIN_SRC emacs-lisp
(defun zd-count-words ()
  "Prints total number of words and notes in the minibuffer."
  (interactive)
  (let ((numWords 0))
    (dolist (deftFile deft-all-files)
      (with-temp-buffer
        (insert-file-contents deftFile)
        (setq numWords (+ numWords (count-words (point-min) (point-max))))))
    (message "Your zettelkasten contains %s notes with %s words in total." (length deft-all-files) numWords)))
#+END_SRC

***** =zd-copy-id-current-file= copies id in filename

Add the ID from the current file to the kill ring.

Steps:
 1. Get the filename from the buffer
 2. Strip the ID from it.
 3. Result can be empty string when no id is detected in the filename.

#+BEGIN_SRC emacs-lisp
(defun zd-copy-id-current-file ()
  "Add the id from the filename the buffer is currently visiting to the kill ring."
  (interactive)
  (zd--check)
  (let ((ID (concat "§" (zd-lift-id (file-name-base (buffer-file-name))))))
    (kill-new ID)
    (message "%s" ID)))
#+END_SRC

***** =zd-id-to-full-title= returns title from ID

Convert a zetteldeft ID into its full title.

The ID should lead to only one title, obviously, so an error is thrown when this is not the case.

#+BEGIN_SRC emacs-lisp
(defun zd-id-to-full-title (zdID)
  "Return full title from given zetteldeft ID.
Throws an error when either none or multiple files with said ID are found."
  (let ((deft-filter-only-filenames t))
    (deft-filter zdID t))
  (unless (eq (length deft-current-files) 1)
    (user-error "ID Error. Either no or multiple zetteldeft files found with ID %s." zdID))
  (file-name-base (car deft-current-files)))
#+END_SRC

*** Listing all tags

=zd-all-tags= puts all tags in =zd-tag-list= and returns them.

Use =zd-tag-buffer= to create a buffer with all tags.

**** =zd-all-tags= returns them all

Extracting tags with =zd-extract-tags=.

#+BEGIN_SRC emacs-lisp
(defun zd-all-tags ()
  "Return a list of all the tags found in zetteldeft files."
  (setq zd-tag-list (list))
  (dolist (deftFile deft-all-files)
    (zd-extract-tags deftFile))
  zd-tag-list)
#+END_SRC

**** =zd-tag-buffer= puts all tags in a buffer

The name of the buffer we'll be using:

#+BEGIN_SRC emacs-lisp
(setq zd-tag-buffer-name "*zd-tag-buffer*")
#+END_SRC

And some code to create that buffer.

Move to the =zd-tag-buffer-name=

#+BEGIN_SRC emacs-lisp
(defun zd-tag-buffer ()
  "Switch to the *zd-tag-buffer* and list tags."
  (interactive)
  (switch-to-buffer zd-tag-buffer-name)
  (erase-buffer)
  (dolist (zdTag (zd-all-tags))
    (insert (format "%s \n" zdTag)))
  (unless (eq major-mode 'org-mode) (org-mode))
  (sort-lines nil (point-min) (point-max)))
#+END_SRC

**** Tag extracting functions

Some utility functions to achieve all of this.

***** =zd-tag-format= provides the tag-finding regex

The regular expression used to filter out tags.
Tags start with a =#= or =@= and contain least one or more letters.
Dashes are allowed.

Tags should be positioned either be at the beginning of a new line, or preceded by a space.
This should help filter out hashtags used in URLs.

#+BEGIN_SRC emacs-lisp
(defcustom zd-tag-format "\\(^\\|\s\\)[#@][a-z-]+"
  "Regular expression used to filter out tags."
  :type 'string
  :group 'zetteldeft)
#+END_SRC

***** =zd-extract-tags= from a file

Open a given file in a temporary buffer.
Loop a search for the tag regexp.
When a tag is found, remove any whitespace from it and add it to the =zd-tag-list= if it isn't there already.
Delete the found tag and search again.

#+BEGIN_SRC emacs-lisp
(defun zd-extract-tags (deftFile)
  "Find all tags in DEFTFILE and add them to zd-tag-list"
  (with-temp-buffer
    (insert-file-contents deftFile)
    (while (re-search-forward zd-tag-format nil t)
      (let ((foundTag (replace-regexp-in-string " " "" (match-string 0))))
        ;; Add found tag to zd-tag-list if it isn't there already
        (unless (member foundTag zd-tag-list)
          (push foundTag zd-tag-list)))
      ;; Remove found tag from buffer
      (delete-region (point) (re-search-backward zd-tag-format)))))
#+END_SRC

*** Gathering notes

In this section:
#+TOC: headlines 2 local

**** On "gathering notes"

Sometimes you want to easily gather all notes with a certain tag or search term.
Say you want to quickly generate a list of links to all files including the tag =#zetteldeft=.

The following functions do that for you.
There are three of them, each either taking a search term as argument or prompting for one:
 1. =zd-insert-list-links= inserts a simple list of notes which contain the search term, spelling out the full filename for each note (including ID).
 2. =zd-org-search-include= generates =org-mode= syntax to =#+INCLUDE= the files below a header with their title.
 3. =zd-org-search-insert= inserts the contents of all of these notes below their respective titles.

More documentation can be found below.
    
**** List of links
***** FIX =zd-insert-list-links= generates list with tagged files

Creates and inserts a list with links to all files with selected search term.

The code gets a list of files that contain the search string, runs through said list and inserts a link for each entry.

To *fix*: when called from within a zetteldeft note, exclude the note itself from the generated list.

#+BEGIN_SRC emacs-lisp
(defun zd-insert-list-links (zdSrch)
  "Inserts at point a list of links to all deft files with a search string ZDSRCH.
When searching for a tag, include # manually in the search."
  (interactive (list (read-string "search string: ")))
  (dolist (zdFile (zd-get-file-list zdSrch))
    (zd-list-entry-file-link zdFile)))
#+END_SRC

***** =zd-insert-list-links-new= generates list with new links

Does the same as the above function, but only inserts IDs that aren't already present in the current file.

This is especially handy when you hope to check wheter all notes with a certain tag are linked to, or simply to list unlinked notes.

One potential *issue*, to be fixed in the future: the file from where the function is called, will also be in said list...

#+BEGIN_SRC emacs-lisp
(defun zd-insert-list-links-new (zdSrch)
  "Inserst a list of links to all deft files with a search string ZDSRCH, yet in contrast to `zd-insert-list-links' only includes links that are not yet present in the current file.
Can only be called from a file in the zetteldeft directory."
  (interactive (list (read-string "search string: ")))
  (zd--check)
  (let (zdCurrentIDs zdFoundIDs zdFinalIDs)
    (setq zdCurrentIDs (zd-extract-links (buffer-file-name)))
    ; filter IDs from search results
    (dolist (zdFile (zd-get-file-list zdSrch))
      (push (zd-lift-id zdFile) zdFoundIDs))
    ; create new list with unique ids
    (dolist (zdID zdFoundIDs)
      (unless (member zdID zdCurrentIDs)
        (push zdID zdFinalIDs)))
    ; finally find full title for each ID and insert it
    (dolist (zdID zdFinalIDs)
      (setq zdID (zd-id-to-full-title zdID))
      (insert " - " (concat "§" zdID "\n")))))
#+END_SRC

***** =zd-list-entry-file-link= includes a file link as list entry

Inserts for given file a link id and title as a list entry.

#+BEGIN_SRC emacs-lisp
(defun zd-list-entry-file-link (zdFile)
  "Insert ZDFILE as list entry."
  (insert " - " (concat "§" (file-name-base zdFile)) "\n"))
#+END_SRC

**** Compiling a single =org=
***** Idea and example
****** Including notes with given search term

The following explains what =zd-org-search-include= does, but the concept is more or less the same for =zd-org-search-insert=.

For each of the notes with the provided search term, it inserts a heading, a line with =#+INCLUDE= and the full path to the relevant notes.
This results in a single file that can be easily exported.

The only function meant for use on the users end, is =zd-org-search-include=.

For example,

#+BEGIN_SRC emacs-lisp :tangle no
(zd-org-search-include "#export")
#+END_SRC

inserts necessary code to include all files containing the tag =#export=.
The results would look like the following:

#+BEGIN_SRC org
\* First file title
#+INCLUDE: "/path/to/2018-07-13-2210 First file title.org"

\* File two
#+INCLUDE: "/path/to/2018-07-13-2223 File two.org"
#+END_SRC

All functions are documented below.

****** Semi-automated example

You could, for example, add the following code to a document and execute (or evaluate) it from within =org-mode=.
Add it under a "comment" type heading to prevent it from being exported itself, like so: =* COMMENT Code=.

#+BEGIN_SRC emacs-lisp :tangle no
(let (frst)
  (save-excursion
    ;; Move to next heading
    (outline-next-heading)
    (setq frst (point))
    ;; Delete everything after
    (delete-region frst (point-max))
    ;; Include the files
    (zd-org-search-include "#tag")
    ; Sort these entries alphabetically (set mark to use a region)
;   (goto-char frst) (set-mark (point-max))
;   (org-sort-entries nil ?a)
  ))
#+END_SRC

The code deletes everything after the current header and inserts all notes with =#tag= in them.

In order to also sort the entries alphabetically, uncomment the last two lines.

A final caveat: don't put the file with the above code in you =deft= folder, or it will attempt to include itself (since it has =#tag= in it).

****** Issues & things to note

Before we look at the functions, a note on limitations of the current implementation.

1. *Over-enthusiastic inclusion*
   Sometimes, a tag appears in a file without the need for it to be included.
   For example, a file with a list of all tags will also include the tag one wants.
   In the future, this might be resolved by filtering, for example with http://ergoemacs.org/emacs/elisp_filter_list.html.

2. *Inclusion from second line onwards*
   Currently, the =#+INCLUDE= lines only include from the second line onwards.
   This is a work-around to prevent =#+TITLE= lines from being included (and messing up the title on =org-export=.
   To change this, edit the inserted strings in the =zd-org-include-file= function.

3. *Sorting*
   The files included are unsorted, or rather: sorted as =deft= provides the results.
   Attempts at sorting by title are included in =zd-get-file-list=, but not working properly.
   As a solution, use =org-sort= manually after running =zd-org-search-include=.

***** =zd-org-search-include= generates =#+INCLUDE= syntax

Asks user for a search string and inserts headers and =#+INCLUDE= code for all files with said tag.
When used on =#tag=, make sure to include the =#= manually.

#+BEGIN_SRC emacs-lisp
(defun zd-org-search-include (zdSrch)
  "Inserts at point org-mode code to include all files with the selected tag. Include the # manually in the prompt."
  (interactive (list (read-string "tag (include the #): ")))
  (dolist (zdFile (zd-get-file-list zdSrch))
    (zd-org-include-file zdFile)))
#+END_SRC

***** =zd-org-search-insert= generates titles & file content

Very similar to the previous function, but rather than writing syntax to include files, insert their contents directly.

#+BEGIN_SRC emacs-lisp
(defun zd-org-search-insert (zdSrch)
  "Inserts at point all the content of the files with ZDSRCH. When looking for zetteldeft tags, include the # manually in the search."
  (interactive (list (read-string "Search term: ")))
  (dolist (zdFile (zd-get-file-list zdSrch))
    (zd-org-insert-file zdFile)))
#+END_SRC

**** Helper functions
***** =zd-insert-file-contents= returns the contents of a file

Returns the contents of a file.

#+BEGIN_SRC emacs-lisp
(defun zd-file-contents (zdFile &optional removeLines)
  "Inserts file contents of a zetteldeft note.
ZDFILE should be a full path to a note.

Optional: leave out first REMOVELINES lines."
  (with-temp-buffer
    (insert-file-contents zdFile)
    (when removeLines
      (kill-whole-line removeLines))
    (buffer-string)))
#+END_SRC

***** =zd-org-include-file= includes a file in =org= format

Inserts the title as a new header, with the =#+INCLUDE= line below.
Includes only from the second line onward, so that any =#+TITLE= lines are omitted.

#+BEGIN_SRC emacs-lisp
(defun zd-org-include-file (zdFile)
  "Insert code to include org-file zdFile."
  (insert
    ;; Insert org-mode title
    "* " (zd-lift-file-title zdFile) "\n"
    ;; Insert #+INCLUDE: "file.org" :lines 2-
    "#+INCLUDE: \"" zdFile "\" :lines \"2-\"\n\n"))
#+END_SRC

***** =zd-org-insert-file= inserts a files content

For a file, insert its title and contents (without first 3 lines).

Even better would be: without any of the lines starting with =#= at the beginning of the file.

#+BEGIN_SRC emacs-lisp
(defun zd-org-insert-file (zdFile)
  "Insert title and contents of ZDFILE."
  (insert
    ;; Insert org-mode title
    "\n* " (zd-lift-file-title zdFile) "\n\n"
    ;; Insert file contents (without the first 3 lines)
    (zd-file-contents zdFile 3)))
#+END_SRC

*** Creating visuals

In this section:
#+TOC: headlines 2 local

**** Introducing graphs

Linking notes together in plain text is fun, but sometimes you want to visualize which notes are connected.

The following functions attempt to provide said functionallity, but are in a very early stage of development.
They generate an org source block for =graphviz=, which can then be executed to generate a pdf.

A brief introduction:
 - =zd-org-graph-search= creates a graph with all the notes containing a provided string.
 - =zd-org-graph-note= creates a graph that starts at a note, connects all notes linked to it, and all notes linked to those. In other words, it looks two levels deep.


The resulting graph looks something like this:

[[./img/zd-graph.jpg]]

It's worth noting, again, that this is very provisional.
 
**** Graph functions
***** =zd-org-graph-search= creates graph from search string

An org code block with =graphviz= code for a =graph.pdf=.

Find all notes with the provided search term.
Loop over this list, and insert title and links for each one.

#+BEGIN_SRC emacs-lisp :results silent
(defun zd-org-graph-search (str)
  "Insert org source block for graph with zd search results. STR should be the search the resulting notes of which should be included in the graph."
  (interactive (list (read-string "search string: ")))
  (setq zd-graph--links (list))
  (let ((zdList (zd-get-file-list str)))
    (insert zd-graph-syntax-begin)
    (insert "\n  // links\n")
    (dolist (oneFile zdList)
      (insert "\n")
      (zd-graph-insert-links oneFile))
    (zd-graph-insert-all-titles))
  (insert zd-graph-syntax-end))
#+END_SRC

***** =zd-org-graph-note= creates graph from note

Insert an org source code block for a graphviz presentation of a note and its connections.

When links are added, they are also stored in =zd-graph--links= which is later used to insert titles.

#+BEGIN_SRC emacs-lisp
(defun zd-org-graph-note (deftFile)
  "Create a graph starting from note DEFTFILE."
  (interactive)
  (setq zd-graph--links (list))
  (insert zd-graph-syntax-begin)
  (insert "\n  // base note and links \n")
  (zd-graph-insert-links deftFile)
  (zd-graph-insert-additional-links)
  (zd-graph-insert-all-titles)
  (insert zd-graph-syntax-end))
#+END_SRC

**** Building blocks
***** =zd-graph-syntax-begin= provides opening syntax

Within graphviz, I advise to use =fdp=, =twopi= (which overlaps more) or =circo= as layouts.

#+BEGIN_SRC emacs-lisp
(defcustom zd-graph-syntax-begin
  "#+BEGIN_SRC dot :file ./graph.pdf :cmdline -Kfdp -Tpdf
  \n graph {\n"
  "Syntax to be included at the start of the zetteldeft graph.")
#+END_SRC
          
***** =zd-graph-syntax-end= provides closing syntax

#+BEGIN_SRC emacs-lisp
(defcustom zd-graph-syntax-end
  "} \n#+END_SRC\n"
  "Syntax to be included at the end of the zetteldeft graph.")
#+END_SRC

***** =zd-extract-links= pulls links from a file

Very similar to the =zd-extract-tags= function, but returns links instead of storing them.

#+BEGIN_SRC emacs-lisp
(defun zd-extract-links (deftFile)
  "Find all links in DEFTFILE and return a list."
  (let ((zdLinks (list)))
    (with-temp-buffer
      (insert-file-contents deftFile)
      (while (re-search-forward zd-id-regex nil t)
        (let ((foundTag (replace-regexp-in-string " " "" (match-string 0))))
          ;; Add found tag to zdLinks if it isn't there already
          (unless (member foundTag zdLinks)
            (push foundTag zdLinks)))
        ;; Remove found tag from buffer
        (delete-region (point) (re-search-backward zd-id-regex))))
   zdLinks))
#+END_SRC

***** =zd-graph-insert-links= inserts graphviz links

Insert the sanitized ID from the file, followed by an arrow and all of the links.

Store both the deft file provided and any found files in =zd-graph--links=.

#+BEGIN_SRC emacs-lisp
(defun zd-graph-insert-links (deftFile)
  "Inserts a file's links in a one line dot graph format.
Any inserted ID is also stored in `zd-graph--links'."
  (insert "  \""
          (zd-lift-id deftFile)
          "\" -- {")
  (dolist (oneLink (zd-extract-links deftFile))
    (zd-graph-store-link oneLink t)
    (insert "\"" oneLink "\" "))
  (insert "}\n")
  (zd-graph-store-link deftFile))
#+END_SRC

***** =zd-graph-insert-title= inserts graphviz title line

Titles have to be inserted in the correct =graphviz= format, like so:

#+BEGIN_SRC dot :tangle no :exports code
 B [label = "Node B"]
#+END_SRC

The following function should achieve that.

#+BEGIN_SRC emacs-lisp
(defun zd-graph-insert-title (deftFile)
  "Inserts the DEFTFILE title definition in a one line dot graph format."
  (let ((zdTitle (replace-regexp-in-string "\"" "" (zd-lift-file-title deftFile)))
        (zdId    (zd-lift-id deftFile)))
    (insert "  \"" zdId "\""
            " [label = \"" zdTitle " (§" zdId ")\"")
    (insert "]" "\n"))
  (zd-graph-store-link deftFile))
#+END_SRC

The title is taken from the file string and any additional quotes removed.

***** =zd-graph-store-link= stores provided notes

For future reference, linked files are stored in =zd-graph--links=.
This function facilitates that process.

Provide a link to a file to store it.
Simply providing an ID works too, if you provide the second argument as true.

#+BEGIN_SRC emacs-lisp
(defun zd-graph-store-link (deftFile &optional idToFile)
  "Push DEFTFILE to zd-graph--links unless it's already there.
When IDTOFILE is non-nil, DEFTFILE is considered an id and the the function first looks for the corresponding file."
  (when idToFile
    (let ((deft-filter-only-filenames t))
      (progn
        (deft-filter deftFile t)
        (setq deftFile (car deft-current-files)))))
  (unless (member deftFile zd-graph--links)
    (push deftFile zd-graph--links)))
#+END_SRC

***** =zd-graph-insert-additional-links= inserts stored links

Insert links stored in the =zd-graph--links= list.
Except the first list item, as this is considered the base file already included.

#+BEGIN_SRC emacs-lisp
(defun zd-graph-insert-additional-links ()
  "Insert rest of `zd-graph--links'."
  (setq zd-graph--links (cdr zd-graph--links))
  (dolist (oneFile zd-graph--links)
    (zd-graph-insert-links oneFile)))
#+END_SRC

***** =zd-graph-insert-all-titles= inserts all stored titles

Insert all titles stored in =zd-graph--links=.

#+BEGIN_SRC emacs-lisp
(defun zd-graph-insert-all-titles ()
  "Insert all graphviz title lines for all links stored in `zd-graph--links'."
  (insert "\n  // titles \n")
  (dolist (oneLink zd-graph--links)
    ;; Sometimes, a 'nil' list item is present. Ignore those.
    (when oneLink
      (zd-graph-insert-title oneLink))))
#+END_SRC

*** Aesthetics
**** FIXME Highlighting zetteldeft links

Need to highlight zetteldeft links in markdown. What's below is for org-mode

Currently, the regexp to find links is hardcoded.

Highlighting not working in comments.

#+BEGIN_SRC emacs-lisp
(font-lock-add-keywords 'org-mode '(
  ("§[0-9]\\{2,\\}-[0-9-]+" . font-lock-warning-face)))
#+END_SRC

*** End of package

That's all folks!

#+BEGIN_SRC emacs-lisp
(provide 'zetteldeft)
;;; zetteldeft.el ends here
#+END_SRC




** DISABLED Zettelkasten Minor Mode
From [[https://github.com/cszang/dotemacs/blob/master/lisp/zettelkasten.el][cszang]]
#+BEGIN_SRC emacs-lisp
  (use-package zettelkasten
    :ensure nil
    :load-path "~/.emacs.d/.local/elisp/zettelkasten.el"
    :after deft)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (setq deft-strip-summary-regexp
   (concat "\\("
           "[\n\t]" ;; blank
           "\\|^#\\+[a-zA-Z_]+:.*$" ;;org-mode metadata
           "\\)"))

  (defun zd-get-thing-at-point ()
  "Return the thing at point, which can be a link, tag or word."
    (require 'thingatpt)
    (let* ((link-re "\\[\\[\\([^]]+\\)\\]\\]")
           (htag-re "\\([§#@][[:alnum:]_-]+\\)"))
     (cond
      ((thing-at-point-looking-at link-re)
        (match-string-no-properties 1))
       ((thing-at-point-looking-at htag-re)
        (match-string-no-properties 1))
       (t (thing-at-point 'word t)))
    ))

  (defun zd-search-at-point ()
  "Search deft with thing-at-point as filter.
  Thing can be a double-bracketed link, a hashtag, or a word."
    (interactive)
    (let ((string (zd-get-thing-at-point)))
     (if string
         (zd-search-global string t)
       (user-error "No search term at point")))
    )

  (defun zd-search-global (str &optional dntOpn)
  "Search deft with STR as filter.
  If there is only one result, open that file (unless DNTOPN is true)."
    ;; Sanitize the filter string
    (setq str (replace-regexp-in-string "[[:space:]\n]+" " " str))
    ;; Call deft search on the filter string
    (let ((deft-incremental-search t))
     (deft)
     (deft-filter str t))
    ;; If there is a single match, open the file
    (unless dntOpn
     (when (eq (length deft-current-files) 1)
       (deft-open-file (car deft-current-files)))))

  (defun zd-search-filename (str)
  "Search for deft files with string STR in filename.
  Open if there is only one result."
    ;; Sanitize the filter string
    (setq str (replace-regexp-in-string "[[:space:]\n]+" " " str))
    ;; Call deft search on the filter string
    (let ((deft-filter-only-filenames t))
     (deft)
     (deft-filter str t))
    ;; If there is a single match, open the file
    (when (eq (length deft-current-files) 1)
      (deft-open-file (car deft-current-files))))

  (defun zd-search-current-id ()
  "Search deft with the id of the current file as filter.
  Open if there is only one result."
   (interactive)
   (zd-search-global (zd-id-current-file) t)
  )

  (defcustom zd-id-format "%Y-%m-%d-%H%M"
    "Format used when generating zetteldeft IDs."
    :type 'string
    :group 'zetteldeft
  )

  (setq deft-new-file-format zd-id-format)

  (defun zd-generate-id ()
   "Generates an id in `zd-id-format'."
   (format-time-string zd-id-format)
  )

  (defun zd-id-insert ()
   (interactive)
   "Inserts an id in `zd-id-format'."
   (insert (zd-generate-id) " ")
  )

  (defun zd-id-sanitized (str)
  "Strip STRING from everything that is not a number or a dash."
   (replace-regexp-in-string "[^(0-9)-]+" "" str)
  )

  (defun zd-file-id-stripped (file)
  "Returns file id stripped from given filename FILE."
   (let ((file (substring file 0 16)))
     (zd-id-sanitized file)
  ))

  (defun zd-id-current-file ()
  "Return the id from the filename the buffer is currently visiting."
   (zd-file-id-stripped (file-name-base (buffer-file-name)))
  )

  (defun zd-copy-id-current-file ()
  "Add the id from the filename the buffer is currently visiting to the kill ring."
  (interactive)
   (kill-new (zd-id-current-file))
  )

  (defun zd-find-file (file)
  "Open deft file FILE."
   (interactive
    (list (completing-read "Deft find file: "
          (deft-find-all-files-no-prefix))))
   (deft-find-file file)
  )

  (defun zd-find-file-id-copy (file)
  "Find deft file FILE and add its id to the kill ring."
   (interactive (list
          (completing-read "File to copy id from: "
          (deft-find-all-files-no-prefix))))
    (kill-new (concat "§" (zd-file-id-stripped file)))
  )

  (defun zd-find-file-id-insert (file)
  "Find deft file FILE and insert its link id, prepended by §."
   (interactive (list
          (completing-read "File to insert id from: "
          (deft-find-all-files-no-prefix))))
    (insert (concat "§" (zd-file-id-stripped file)))
  )

  (defun zd-find-file-full-title-insert (file)
  "Find deft file FILE and insert its link id with title, prepended by §."
   (interactive (list
          (completing-read "File to insert full title from: "
          (deft-find-all-files-no-prefix))))
    (insert (concat "§" (file-name-base file)))
  )

  (defun zd-new-file (str &optional empty)
  "Create a new deft file. Filename is `zd-id-format' appended by STR. No extension needed.

  After creating, the title is inserted in org-mode format (unless EMPTY is true) and the full file name is added to the kill ring."
   (interactive (list (read-string "name: ")))
   (let* ((zdId (zd-generate-id))
          (zdName (concat zdId " " str)))
   (deft-new-file-named zdName)
   (kill-new zdName)
   (unless empty (zd-insert-org-title))
   (when (featurep 'evil) (evil-insert-state))
  ))

  (defun zd-new-file-and-link (str)
  "Inserts generated id with `zd-id-format' appended with STR.
  Creates new deft file with id and STR as name."
   (interactive (list (read-string "name: ")))
   (insert "§" (zd-generate-id) " " str)
   (zd-new-file str)
  )

  (defun zd-avy-tag-search ()
  "Call on avy to jump and search tags indicated with #."
   (interactive)
   (save-excursion
    (avy-goto-char ?#)
    (zd-search-at-point)
  ))

  (defun zd-avy-link-search ()
  "Call on avy to jump and search link ids indicated with §.
  Opens immediately if there is only one result."
   (interactive)
   (save-excursion
    (avy-goto-char ?§)
    (zd-search-global (zd-id-sanitized (zd-get-thing-at-point)))
  ))

  (defun zd-avy-file-search ()
  "Call on avy to jump to link ids indicated with § and use it to search for filenames."
   (interactive)
   (save-excursion
    (avy-goto-char ?§)
    (zd-search-filename (zd-id-sanitized (zd-get-thing-at-point)))
  ))

  (defun zd-deft-new-search ()
  "Launch deft, clear filter and enter insert state."
   (interactive)
   (deft)
   (deft-filter-clear)
   (any-deft "~/Dropbox/org-files/zettel/")
   (when (featurep 'evil) (evil-insert-state))
  )

  (defun zd-file-rename ()
  "Rename the current file via the deft function. Use this on files in the deft-directory."
   (interactive)
    (let ((old-filename (buffer-file-name))
          (deft-dir (file-name-as-directory deft-directory))
          new-filename old-name new-name)
      (when old-filename
        (setq old-name (deft-base-filename old-filename))
        (setq new-name (read-string
                        (concat "Rename " old-name " to (without extension): ")
                        old-name))
        (setq new-filename
              (concat deft-dir new-name "." deft-default-extension))
        (rename-file old-filename new-filename)
        (deft-update-visiting-buffers old-filename new-filename)
        (deft-refresh))))

  (defun zd-insert-org-title ()
   (interactive)
   (insert
     "#+title: "
     (zd-lift-file-title (file-name-base (buffer-file-name)))
     "\n"
     zd-string-below-title
     ))

  (defcustom zd-string-below-title ""
    "String inserted below title when `zd-insert-org-title' is called. Empty by default."
    :type 'string
    :group 'zetteldeft
  )

  (defun zd-get-file-list (srch)
  "Returns a list of files with the search item SRCH."
    (let ((deft-current-sort-method 'title))
     (deft-filter srch t)
     deft-current-files
  ))

  (defun zd-lift-file-title (zdFile)
   (let ((baseName (file-name-base zdFile)))
     (replace-regexp-in-string
      "[0-9]\\{2,\\}-[0-9-]+[[:space:]]"
      "" baseName)
  ))

  (defun zd-insert-list-links (zdSrch)
  "Inserts at point a list of links to all deft files with a search string ZDSRCH.
  When searching for a tag, include # manually in the prompt."
   (interactive (list (read-string "search string: ")))
   (dolist (zdFile (zd-get-file-list zdSrch))
    (zd-list-entry-file-link zdFile)
  ))

  (defun zd-list-entry-file-link (zdFile)
  "Insert ZDFILE as list entry."
   (insert " - " (concat "§" (file-name-base zdFile)) "\n")
  )

  (defun zd-org-include-search (zdSrch)
  "Inserts at point org-mode code to include all files with the selected tag. Include the # manually in the prompt."
   (interactive (list (read-string "tag (include the #): ")))
   (dolist (zdFile (zd-get-file-list zdSrch))
    (zd-org-include-file zdFile)
  ))

  (defun zd-org-include-file (zdFile)
  "Insert code to include org-file zdFile."
   (insert
     ;; Insert org-mode title
     "\n* " (zd-lift-file-title zdFile) "\n"
     ;; Insert #+INCLUDE: "file.org" :lines 2-
     "#+INCLUDE: \"" zdFile "\" :lines \"2-\"\n"
   ))

  ;; ; highlight zetteldeft links
  ;; (font-lock-add-keywords 'org-mode '(
  ;;   ("§[0-9]\\{2,\\}-[0-9-]+" . font-lock-warning-face)
  ;;   ))

  ;; (with-eval-after-load 'deft
  ;;   (define-key spacemacs-deft-mode-map-prefix
  ;;     "o" 'efls/deft-open)
  ;;   (define-key spacemacs-deft-mode-map-prefix
  ;;     [?\t] 'efls/deft-open-preview)
  ;;  )

  (defun efls/deft-open-other ()
   (interactive)
   (deft-open-file-other-window t)
  )

  (defun efls/deft-open-preview ()
   (interactive)
   (deft-open-file-other-window)
  )

  (with-eval-after-load 'deft
    (define-key deft-mode-map
      (kbd "<tab>") 'efls/deft-open-preview)
    (define-key deft-mode-map
      (kbd "<s-return>") 'efls/deft-open-other)
  )
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle no
(general-define-key
  :states '(normal motion visual insert emacs)
  :keymaps 'override
  :prefix "SPC"
  :non-normal-prefix "C-SPC"
 
  "z"  '(:ignore t :which-key "Zettelkasten")
  "zc" 'zd-search-current-id
  "zf" 'zd-avy-file-search
  "zi" 'zd-find-file-id-insert
  "zI" 'zd-find-file-full-title-insert
  "zl" 'zd-avy-link-search
  "zL" 'zd-insert-list-links
  "zn" 'zd-new-file
  "zN" 'zd-new-file-and-link
  "zo" 'zd-find-file
  "zO" 'zd-org-include-search
  "zr" 'deft-refresh
  "zs" 'zd-deft-new-search
  "zS" 'zd-search-at-point
  "zt" 'zd-avy-tag-search
  "zT" 'zd-insert-org-title
 ) 
#+END_SRC

** Org super agenda/agenda custom commands
 #+BEGIN_SRC emacs-lisp :tangle no

          ("W" "Week's agenda and all TODOs"
           ((tags "PRIORITY=\"A\""
                  ((org-agenda-skip-function '(org-agenda-skip-entry-if 'todo 'done))
                   (org-agenda-overriding-header "High-priority unfinished tasks:")))
            (agenda "" ((org-agenda-span 'week)))
            (alltodo ""
                     ((org-agenda-skip-function '(or (air-org-skip-subtree-if-habit)
                                                     (air-org-skip-subtree-if-priority ?A)
                                                     (org-agenda-skip-if nil '(scheduled deadline))))
                      (org-agenda-overriding-header "ALL normal priority tasks:"))))
           ((org-agenda-compact-blocks nil)))

          ("A" "Super Agenda"
           ((agenda "" ((org-agenda-span 'day)
                        (let ((org-super-agenda-groups
                         '((:name "Schedule"
                                  :time-grid t)
                           (:name "Today"
                                  :scheduled today)
                           (:name "Due Today"
                                  :deadline today
                                  :order 2)
                           (:name "Due Soon"
                                  :deadline future
                                  :order 8)
                           (:name "Overdue"
                                  :deadline past
                                  :order 7)))))
            (alltodo "" ((org-agenda-overriding-header "")
                         (let ((org-super-agenda-groups
                          '((:name "Next to do"
                                   :todo "NEXT"
                                   :order 1)
                            (:name "Important"
                                   :tag "Important"
                                   :priority "A"
                                   :order 6)
                            (:name "In progress"
                                   :todo "INPROGRESS"
                                   :order 15)
                            (:name "Waiting"
                                   :todo "WAITING"
                                   :order 20)
                            (:name "To read"
                                   :todo "TOREAD"
                                   :order 30)
                            (:name "Low priority"
                                   :priority<= "C"
                                   :todo ("SOMEDAY" )
                                   :order 90)
                            (:discard (:tag ("Chore" "Routine" "Daily")))

                            ))))))))))))

#+END_SRC

** Zotero Keybindings 
#+BEGIN_SRC emacs-lisp
(general-define-key
  :states '(normal)
  :keymaps 'override
  :prefix "SPC"
  :non-normal-prefix "C-SPC"

  "z" '(:ignore t :which-key "Zotero")
  "za" 'org-zotxt-open-attachment
  "zi" 'org-zotxt-insert-reference-link
  "zu" 'org-zotxt-update-reference-link-at-point
)
#+END_SRC

** DISABLED Org Fancy Priorities
CLOSED: [2018-08-04 Sat 12:30]
Display Org Mode priorities as [[https://github.com/harrybournis/org-fancy-priorities][custom strings]]
Unfortunately slows down org file opening
#+BEGIN_SRC emacs-lisp
  (use-package org-fancy-priorities
    :ensure t
    :hook
    (org-mode . org-fancy-priorities-mode)
    :config
    (setq org-fancy-priorities-list '("⚑⚑⚑" "⚑⚑" "⚑" "OPTIONAL")))
#+END_SRC

** Org Mode
The incomparable [[https://orgmode.org][org mode]]
#+BEGIN_SRC emacs-lisp
;; install org for bootstrapping config
(use-package org
  :commands (org-capture)
  :ensure org-plus-contrib)
#+END_SRC

*** Settings
**** New Org
Ensure ELPA org is prioritized above built-in org.
#+BEGIN_SRC emacs-lisp 
(setq load-path (remove-if (lambda (x) (string-match-p "org$" x)) load-path))
#+END_SRC
**** Org Directories 
     #+BEGIN_SRC emacs-lisp
     (setq org-directory "~/Dropbox/org-files")
     (setq org-default-notes-file (concat org-directory "/org-notes.org"))
     #+END_SRC
**** State Settings
     #+BEGIN_SRC emacs-lisp
     (setq org-todo-keywords
      '((sequence "TODO" "NEXT" "|" "DONE")
        (sequence "INPROGRESS" "WAITING(w@/!)" "|" "CANCELED" "INACTIVE")))
     #+END_SRC
**** Org Logging
     #+BEGIN_SRC emacs-lisp
    ; log timestamp when task is marked "DONE" or other finished keyword
    (setq org-log-done 'time)
     #+END_SRC
    
**** Org Babel Languages
#+BEGIN_SRC emacs-lisp
(with-eval-after-load 'org
(org-babel-do-load-languages
 'org-babel-load-languages
 '((latex . t)
   (lisp . t)
   (shell . t)))

(defun my-org-confirm-babel-evaluate (lang body)
  "Do not confirm evaluation for these languages."
  (not (or (string= lang "emacs-lisp"))))
        
(setq org-confirm-babel-evaluate 'my-org-confirm-babel-evaluate))
#+END_SRC
**** Org Babel Source Blocks
#+BEGIN_SRC emacs-lisp
  (setq org-src-fontify-natively t
        org-src-window-setup 'other-window
        org-src-tab-acts-natively nil
        org-src-strip-leading-and-trailing-blank-lines t)
#+END_SRC

**** Org Config Settings
#+BEGIN_SRC emacs-lisp
  (setq-default 
        org-footnote-section nil ;; place footnotes locally rather than in own section
        org-return-follows-link t ;; make RET follow links
        org-list-allow-alphabetical t ;; allow alphabetical list
        org-hide-emphasis-markers t  ;; hide markers
        org-pretty-entities t ;; make latex look good
        org-pretty-entities-include-sub-superscripts t
        org-hide-leading-stars t
        org-export-with-smart-quotes t ;; export smart quote marks
        org-refile-use-cache t  ;; use cache for org refile
        org-startup-folded t
        org-yank-adjusted-subtrees t  ;; adjust subtrees to depth when yanked
        org-yank-folded-subtrees t  ;; fold subtrees on yank
        org-M-RET-may-split-line '((default . nil))  ;; don't split line when creating a new headline, list item, or table field
        org-fontify-quote-and-verse-blocks t ;; make quotes stand out
        org-table-export-default-format "orgtbl-to-csv" ;; export for org-tables to csv
        ;; org-ellipsis "↷" ;; nicer elipses "↴" "▼"
        org-startup-indented t ;; start in indent mode
        org-imenu-depth 8
        imenu-auto-rescan t)
#+END_SRC
**** Org Modules
A list of org modules to load on startup
#+BEGIN_SRC emacs-lisp 
(setq org-modules (quote (org-info org-protocol org-mac-link)))
#+END_SRC
**** Org ID
#+BEGIN_SRC emacs-lisp
(setq org-id-locations-file (concat cpm-cache-dir ".org-id-locations"))
#+END_SRC
**** Org Regex (Emphasis)
Per this [[https://emacs.stackexchange.com/questions/13820/inline-verbatim-and-code-with-quotes-in-org-mode][stack exchange]] discussion.
#+BEGIN_SRC emacs-lisp

(with-eval-after-load 'org
; chars for prematch
(setcar org-emphasis-regexp-components            "     ('\"{“”\[\\\_\-") 
; chars for postmatch
(setcar (nthcdr 1 org-emphasis-regexp-components) "\] -   .,!?;:''“”\")}/\\“”\_\-") 
; forbidden chars
(setcar (nthcdr 2 org-emphasis-regexp-components) "    \t\r\n,\"")
; body
(setcar (nthcdr 3 org-emphasis-regexp-components) ".")
; max newlines 
(setcar (nthcdr 4 org-emphasis-regexp-components) 1)
(org-set-emph-re 'org-emphasis-regexp-components org-emphasis-regexp-components))

#+END_SRC
**** Org Tags
Set tags
#+BEGIN_SRC emacs-lisp
(setq org-tag-persistent-alist 
        '(("UNL" . ?u)
          ("CONTACTS" . ?C)
          ("INBOX" . ?i)
          ))
#+END_SRC
**** Hooks
#+BEGIN_SRC emacs-lisp
  (add-hook 'org-mode-hook
      (lambda () 
        (turn-on-auto-fill)
        ;; (turn-on-flyspell)
        (org-zotxt-mode)
        (global-git-gutter-mode 0)
        ))
#+END_SRC


*** Org Archive
Tell org where to archive completed tasks
#+BEGIN_SRC emacs-lisp
(setq org-archive-location (concat org-directory "/org-archive/archived.org::datetree/"))
#+END_SRC

Also tell org how to archive all the done tasks (DONE or CANCELED) in a file.
From [[https://changelog.complete.org/archives/9877-emacs-3-more-on-org-mode][here]] based on a stack overflow [[https://stackoverflow.com/a/27043756][answer]]
#+BEGIN_SRC emacs-lisp
(defun cpm/org-archive-done-tasks ()
  (interactive)
  (org-map-entries
   (lambda ()
     (org-archive-subtree)
     (setq org-map-continue-from (outline-previous-heading)))
   "/DONE" 'file)
  (org-map-entries
   (lambda ()
     (org-archive-subtree)
     (setq org-map-continue-from (outline-previous-heading)))
   "/CANCELED" 'file)
)

#+END_SRC
*** Org Refile
Set refile settings.  I got a lot of help on this from [[https://blog.aaronbieber.com/2017/03/19/organizing-notes-with-refile.html][Aaron Bieber's discussion]].

With this set, you can trigger Refile with C-c C-w in any Org file and
get a completing read of all headings up to three levels deep in all
files in =org-agenda-files=. You can also refile to the top header in a
document and create new parents.
#+BEGIN_SRC emacs-lisp
  (setq org-refile-targets '((org-agenda-files :maxlevel . 3)
                             ("/Users/roambot/.emacs.d/config.org" :maxlevel . 8)))
  (setq org-refile-use-outline-path 'file)
  (setq org-outline-path-complete-in-steps nil)
  (setq org-refile-allow-creating-parent-nodes 'confirm)
#+END_SRC
*** Open Docx Files In Default Application (Ie Msword)
Open exported docx files in Word/Open Office rather than emacs
#+BEGIN_SRC emacs-lisp
  (setq org-file-apps
        '(("\\.docx\\'" . default)
          ("\\.mm\\'" . default)
          ("\\.x?html?\\'" . default)
          ("\\.pdf\\'" . default)
          (auto-mode . emacs)))
#+END_SRC
*** Org-Agenda
Settings for the [[http://orgmode.org/manual/Agenda-Views.html][agenda]]. 
#+BEGIN_SRC emacs-lisp
  (setq org-agenda-files '("~/Dropbox/org-files/"))
  (general-define-key "C-c a" #'org-agenda)
  ; https://orgmode.org/manual/Storing-searches.html#Storing-searches
  (setq org-agenda-custom-commands
        '(("x" agenda)
          ("y" agenda*) ; or agenda entries planned this week/day with an hour specification like [h]h:mm
          ("z" todo "TODO")
          ("n" todo "NEXT")
          ("r" todo "REVISE")
          ("w" todo "WAITING")))

  ;; Display properties
  (setq org-cycle-separator-lines 0
        org-tags-column 80
        org-agenda-tags-column org-tags-column
        org-agenda-window-setup 'only-window
        org-agenda-restore-windows-after-quit t
        org-agenda-todo-ignore-scheduled 'all
        org-agenda-todo-ignore-deadlines 'all 
        ;; org-agenda-sticky t
        org-agenda-span 'day)

  (with-eval-after-load 'org-agenda
    (general-define-key :keymaps 'org-agenda-mode-map 
                        "j" 'org-agenda-next-item
                        "k" 'org-agenda-previous-item))

  ;; automatically refresh the agenda after adding a task
  (defun cpm/org-agenda-refresh ()
  (interactive)
  (when (get-buffer "*Org Agenda*")
      (with-current-buffer "*Org Agenda*"
          (org-agenda-redo t)
          (message "[org agenda] refreshed!"))))
  (add-hook 'org-capture-after-finalize-hook 'cpm/org-agenda-refresh)

  ;; show all todos
  (defun cpm/jump-to-org-agenda-all-todos ()
    "open agenda with all unscheduled/non-deadline todos"
    (interactive)
    (org-agenda nil "z"))
#+END_SRC

*** Org-Super-Agenda
[[https://github.com/alphapapa/org-super-agenda][Supercharge]] org-agenda. Settings courtesy of [[https://github.com/fuxialexander/doom-emacs-private-xfu][fuxialexander]]
#+BEGIN_SRC emacs-lisp
    (use-package org-super-agenda
      :commands (org-super-agenda-mode)
      :config
      (setq org-super-agenda-groups
            '((:name "Log\n"
                     :log t)  ; Automatically named "Log"
              (:name "Schedule\n"
                     :time-grid t)
              (:name "Today\n"
                     :scheduled today)
              ;; (:name "Habits\n"
              ;;        :habit t)
              (:name "Due today\n"
                     :deadline today)
              (:name "Overdue\n"
                     :deadline past)
              (:name "Due soon\n"
                     :deadline future)
              (:name "Waiting\n"
                     :todo "WAITING"
                     :order 98)
              (:name "Scheduled earlier\n"
                     :scheduled past))))

  ;; Hydra for org agenda (graciously taken from Spacemacs)
  (after! org-agenda
  (org-super-agenda-mode)
  (general-define-key :states '(normal emacs) :keymaps 'org-agenda-keymap
    "."  'cpm/hydra-org-agenda/body)
  (defhydra cpm/hydra-org-agenda (:color pink :hint none)
    "
  Org agenda (_q_uit)

  ^Clock^      ^Visit entry^              ^Date^             ^Other^
  ^-----^----  ^-----------^------------  ^----^-----------  ^-----^---------
  _ci_ in      _SPC_ in other window      _ds_ schedule      _gr_ reload
  _co_ out     _TAB_ & go to location     _dd_ set deadline  _._  go to today
  _cq_ cancel  _RET_ & del other windows  _dt_ timestamp     _gd_ go to date
  _cj_ jump    _o_   link                 _+_  do later      ^^
  ^^           ^^                         _-_  do earlier    ^^
  ^^           ^^                         ^^                 ^^
  ^View^          ^Filter^                 ^Headline^         ^Toggle mode^
  ^----^--------  ^------^---------------  ^--------^-------  ^-----------^----
  _vd_ day        _ft_ by tag              _ht_ set status    _tf_ follow
  _vw_ week       _fr_ refine by tag       _hk_ kill          _tl_ log
  _vt_ fortnight  _fc_ by category         _hr_ refile        _ta_ archive trees
  _vm_ month      _fh_ by top headline     _hA_ archive       _tA_ archive files
  _vy_ year       _fx_ by regexp           _h:_ set tags      _tr_ clock report
  _vn_ next span  _fd_ delete all filters  _hp_ set priority  _td_ diaries
  _vp_ prev span  ^^                       ^^                 ^^
  _vr_ reset      ^^                       ^^                 ^^
  ^^              ^^                       ^^                 ^^
  "
    ;; Entry
    ("hA" org-agenda-archive-default)
    ("hk" org-agenda-kill)
    ("hp" org-agenda-priority)
    ("hr" org-agenda-refile)
    ("h:" org-agenda-set-tags)
    ("ht" org-agenda-todo)
    ;; Visit entry
    ("o"   link-hint-open-link :exit t)
    ("<tab>" org-agenda-goto :exit t)
    ("TAB" org-agenda-goto :exit t)
    ("SPC" org-agenda-show-and-scroll-up)
    ("RET" org-agenda-switch-to :exit t)
    ;; Date
    ("dt" org-agenda-date-prompt)
    ("dd" org-agenda-deadline)
    ("+" org-agenda-do-date-later)
    ("-" org-agenda-do-date-earlier)
    ("ds" org-agenda-schedule)
    ;; View
    ("vd" org-agenda-day-view)
    ("vw" org-agenda-week-view)
    ("vt" org-agenda-fortnight-view)
    ("vm" org-agenda-month-view)
    ("vy" org-agenda-year-view)
    ("vn" org-agenda-later)
    ("vp" org-agenda-earlier)
    ("vr" org-agenda-reset-view)
    ;; Toggle mode
    ("ta" org-agenda-archives-mode)
    ("tA" (org-agenda-archives-mode 'files))
    ("tr" org-agenda-clockreport-mode)
    ("tf" org-agenda-follow-mode)
    ("tl" org-agenda-log-mode)
    ("td" org-agenda-toggle-diary)
    ;; Filter
    ("fc" org-agenda-filter-by-category)
    ("fx" org-agenda-filter-by-regexp)
    ("ft" org-agenda-filter-by-tag)
    ("fr" org-agenda-filter-by-tag-refine)
    ("fh" org-agenda-filter-by-top-headline)
    ("fd" org-agenda-filter-remove-all)
    ;; Clock
    ("cq" org-agenda-clock-cancel)
    ("cj" org-agenda-clock-goto :exit t)
    ("ci" org-agenda-clock-in :exit t)
    ("co" org-agenda-clock-out)
    ;; Other
    ("q" nil :exit t)
    ("gd" org-agenda-goto-date)
    ("." org-agenda-goto-today)
    ("gr" org-agenda-redo)))

    (defun cpm/jump-to-org-agenda ()
    (interactive)
    (org-agenda nil "a"))
#+END_SRC

*** Org Capture
**** Capture Settings
#+BEGIN_SRC emacs-lisp
  (general-define-key "C-c c" 'org-capture)
  (add-hook 'org-capture-mode-hook 'evil-insert-state)
  (setq org-capture-templates
        '(("p" "Projects" entry (file+headline "~/Dropbox/org-files/todo.org" "Projects")
           "** STARTED %? \n  %i")
          ("c" "Capture" entry (file+headline "~/Dropbox/org-files/todo.org" "Inbox")
           "* TODO %?\n %i")
          ("j" "Journal" entry (file+olp+datetree "~/Dropbox/org-files/journal.org")
           "**** %<%H:%M>\n%?")
          ("l" "A link, for reading later." entry (file+headline "~/Dropbox/org-files/org-notes.org" "Reading List")
            "* %:description\n%u\n\n%c\n\n%i"
            :empty-lines 1)
          ("m" "Mail-Task" entry (file+headline "~/Dropbox/org-files/todo.org" "Inbox")
           "** TODO %:description                         :email: \n[[message://%l][Email link]] \n%? ")
          ("n" "Notes" entry (file "~/Dropbox/org-files/org-notes.org")
          "* %?")
          ("w" "Review: Weekly Review" entry (file+datetree "~/Dropbox/org-files/reviews.org")
            (file "~/Dropbox/org-files/templates/weekly_review_template.org"))))

    ;; Add date to captured items
    (defun add-property-with-date-captured ()
      "Add DATE_CAPTURED property to the current item."
      (interactive)
      (org-set-property "DATE_CAPTURED" (format-time-string "%c")))

    (add-hook 'org-capture-before-finalize-hook 'add-property-with-date-captured)

#+END_SRC
**** Org Journal Capture
Tell emacs what you're doing a few times a day. Depends on a [[/Users/roambot/bin/scripts/emacs_journal.sh][shell script]] run
in the background. I got the idea from [[http://www.diegoberrocal.com/blog/2015/08/19/org-protocol/][Diego Berrocal]]. Hat tip to [[http://stackoverflow.com/questions/23517372/hook-or-advice-when-aborting-org-capture-before-template-selection][stack
overflow]] for help on hooks for the created frame.

#+BEGIN_SRC emacs-lisp
(defun cpm/org-journal ()
  (interactive) (org-capture nil "j"))

(defun cpm/what-are-you-doing-capture ()
  (interactive)
  (make-frame '((name . "What are you doing?") (left . (+ 550)) (top . (+ 400)) (width . 100) (height . 12)))
  (select-frame-by-name "What are you doing?")
  (cpm/org-journal)
  )

#+END_SRC
**** Alfred capture workflow
Help alfred and org-capture play nice. Courtesy of [[http://orgmode.org/worg/org-contrib/alfred-org-capture.html][worg]] with some slight modifications.
#+BEGIN_SRC emacs-lisp
(defun cpm/org-capture-frame ()
  (interactive)
  (org-capture nil "c"))
  
(defun cpm/make-orgcapture-frame ()
  "Create a new frame and run org-capture."
  (interactive)
  (make-frame '((name . "alfred-capture") (width . 90) (height . 20)
                (top . 400) (left . 300)
                ))
  (select-frame-by-name "alfred-capture")
  (cpm/org-capture-frame))

#+END_SRC
**** Capture advice
Make capture the only window and close after refiling.
 #+BEGIN_SRC emacs-lisp
   (defadvice org-capture
     (after make-full-window-frame activate)
     "Advise capture to be the only window when used as a popup"
     (cond ((equal "What are you doing?" (frame-parameter nil 'name)) (delete-other-windows))
           ((equal "alfred-capture" (frame-parameter nil 'name)) (delete-other-windows))
           ((equal "Email Capture" (frame-parameter nil 'name)) (delete-other-windows))

           ))

    (defadvice org-capture-finalize
      (after delete-capture-frame activate)
       "Advise capture-finalize to close the frame"
       (cond ((equal "What are you doing?" (frame-parameter nil 'name)) (delete-frame))
             ((equal "alfred-capture" (frame-parameter nil 'name)) (delete-frame))
             ((equal "Email Capture" (frame-parameter nil 'name)) (delete-frame))
             ))
#+END_SRC

*** Org Keybindings
**** Evil Org 
#+BEGIN_SRC emacs-lisp
(use-package evil-org
  :init
  (add-hook 'org-mode-hook 'evil-org-mode)  
  :config
  (add-hook 'evil-org-mode-hook  (lambda () (evil-org-set-key-theme '(textobjects insert navigation additional shift)))))
#+END_SRC
**** Org Local Leader Keybindings

#+BEGIN_SRC emacs-lisp
  (general-define-key
  :states '(normal visual)
  :keymaps 'org-mode-map
  :prefix "SPC m" 
  :non-normal-prefix "C-SPC m"

   ""    '(nil :which-key "Local Leader")
   "RET" #'cpm/org-archive-done-tasks
   "SPC" #'org-toggle-checkbox
   "."   #'org-cycle-agenda-files
   "/"   #'org-sparse-tree
   "="   #'org-align-all-tags
   "?"   #'org-tags-view
   ":"   #'org-set-tags
   "a"   #'super-jump-to-org-agenda
   "A"   #'org-archive-subtree
   "b"   #'org-tree-to-indirect-buffer
   "B"   #'org-babel-tangle
   "c"   #'org-capture
   "d"   #'org-time-stamp
   "D"   #'org-deadline
   "e"   #'org-edit-special
   "n"   #'cpm/narrow-or-widen-dwim
   "r"   #'org-refile
   "s"   #'org-schedule
   "t"   #'counsel-org-tag
   "T"   #'org-todo
   "v"   #'variable-pitch-mode
   "l"   #'org-insert-link
   "L"   #'org-store-link
   "+"   #'org-timestamp-up-day
   "-"   #'org-timestamp-down-day
   "<"   #'org-metaleft
   ">"   #'org-metaright

   "i"  '(:ignore t :which-key "Insert...")
         "il" #'org-insert-link
         "if" #'org-footnote-new

   "R"  '(:ignore t :which-key "RevealJS..." )
         "Rr" #'org-reveal-export-to-html-and-browse
         "Rs" #'cpm/narrowed-subtree-to-html
         "RS" #'org-reveal-export-current-subtree
         "Rp" #'cpm/reveal-to-pdf)

  (general-define-key
    :states '(normal motion emacs)
    :keymaps 'org-agenda-mode-map
    :prefix "SPC"
    :non-normal-prefix "C-SPC"
      "<escape>" #'org-agenda-Quit
      "m"   #'org-agenda-month-view
      "C-j" #'org-agenda-next-item
      "C-k" #'org-agenda-previous-item
      "C-n" #'org-agenda-next-item
      "C-p" #'org-agenda-previous-item)
#+END_SRC
**** Alternate Bindings
#+BEGIN_SRC emacs-lisp
  (general-define-key :states '(normal) :keymaps 'org-mode-map
        "RET" 'org-open-at-point     ;; Open with return in evil
        "p"   'org-yank ;; better pasting behavior
        "s-J" 'crux-top-join-line
        )
  ;;      "L" 'org-shiftright
  ;;      "H" 'org-shiftleft
  ;;      "$" 'org-end-of-line
  ;;      "^" 'org-beginning-of-line
  ;;      "<" 'org-metaleft
  ;;      ">" 'org-metaright
  ;;      "-" 'org-cycle-list-bullet)
  
  ;;   normal, insert, visual shortcuts
    (general-define-key :states '(normal insert visual) :keymaps 'org-mode-map
      "M-q" #'cpm/fill-or-unfill)
  ;;   ;; normal & insert state shortcuts.
    (general-define-key :states '(normal insert) :keymaps 'org-mode-map
       ;; easily emphasize text
       ;; see https://emacs.stackexchange.com/questions/27645/unable-to-bind-emphasize-key-in-org-mode
       "s-b" (lambda () (interactive) (org-emphasize ?\*))
       "s-i" (lambda () (interactive) (org-emphasize ?\/))
       "s-=" (lambda () (interactive) (org-emphasize ?\=))
        ;; better pasting behavior in org-mode
       "s-v" 'org-yank)
  ;;      "TAB" 'org-cycle
  ;;      "s-l" 'org-metaright
  ;;      "s-h" 'org-metaleft
  ;;      "s-k" 'org-metaup
  ;;      "s-j" 'org-metadown
  ;;      "s-L" 'org-shiftmetaright
  ;;      "s-H" 'org-shiftmetaleft
  ;;      "s-K" 'org-shiftmetaup
  ;;      "s-J" 'org-shiftmetadown
  ;;      "s-o" '(lambda () (interactive)
  ;;               (evil-org-eol-call
  ;;                '(lambda()
  ;;                   (org-insert-heading)
  ;;                   (org-metaright))))
  ;;      "s-t" '(lambda () (interactive)
  ;;               (evil-org-eol-call
  ;;                '(lambda()
  ;;                   (org-insert-todo-heading nil)
  ;;                   (org-metaright)))))
  ;;   ;; Use tab in insert mode
  ;;   (general-define-key :states '(insert) :keymaps 'org-mode-map "\t" nil
  ;;      "RET" #'org-return-indent
  ;;      "C-j" nil
  ;;      "C-k" nil
  ;;      "H-j"   #'org-next-visible-heading
  ;;      "H-k"   #'org-previous-visible-heading
  ;;      "H-S-j"     #'org-forward-heading-same-level
  ;;      "H-S-k"     #'org-backward-heading-same-level
  ;;      )
#+END_SRC


*** Org Template Expansions

#+BEGIN_SRC emacs-lisp
  (with-eval-after-load 'org
  (add-to-list 'org-structure-template-alist
    '("E" "#+BEGIN_SRC emacs-lisp\n?\n#+END_SRC"))
  (add-to-list 'org-structure-template-alist
    '("n" "#+BEGIN_NOTES\n?\n#+END_NOTES"))
  (add-to-list 'org-structure-template-alist
    '("t" "#+BEGIN_COMMENT TODO: ?  #+END_COMMENT"))
  (add-to-list 'org-structure-template-alist
    '("b" "#+REVEAL: split?"))
  (add-to-list 'org-structure-template-alist
    '("f" "#+ATTR_REVEAL: :frag (appear)?")))
#+END_SRC

*** Org Bullets
#+BEGIN_SRC emacs-lisp
  (use-package org-bullets
    :after org
    :demand t
    :hook (org-mode . (lambda () (org-bullets-mode 1)))
    :config 
    (setq org-bullets-bullet-list '("◉" "⚫"))) 

    ;; Other bullets
    ;; "●" "◉" "→"
    ;; ("◉" "◎" "⚫" "○" "►" "◇")
    ;;  "∙" "∶" "∵" "∷" "∺" )))
    ;; (setq org-bullets-bullet-list '("❂" "⁑" "⁂" "❖" "✮" "✱" "✵")))

  ;; Asterisks and dashes for bullet lists are fine, but actual circular bullets are better
  ;; via http://www.howardism.org/Technical/Emacs/orgmode-wordprocessor.html
  (font-lock-add-keywords 'org-mode
                        '(("^ +\\([-*]\\) "
                           (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "•"))))))
#+END_SRC

*** Org Prettify Source Blocks

Make source blocks look better. Courtesy of [[https://pank.eu/blog/pretty-babel-src-blocks.html][Rasmus Pank Roulund]].
Last updated: 2018-04-06
#+BEGIN_SRC emacs-lisp
  (with-eval-after-load 'org
    (defvar-local rasmus/org-at-src-begin -1
      "Variable that holds whether last position was a ")

    (defvar rasmus/ob-header-symbol ?☰
      "Symbol used for babel headers")

    (defun rasmus/org-prettify-src--update ()
      (let ((case-fold-search t)
            (re "^[ \t]*#\\+begin_src[ \t]+[^ \f\t\n\r\v]+[ \t]*")
            found)
        (save-excursion
          (goto-char (point-min))
          (while (re-search-forward re nil t)
            (goto-char (match-end 0))
            (let ((args (org-trim
                         (buffer-substring-no-properties (point)
                                                         (line-end-position)))))
              (when (org-string-nw-p args)
                (let ((new-cell (cons args rasmus/ob-header-symbol)))
                  (cl-pushnew new-cell prettify-symbols-alist :test #'equal)
                  (cl-pushnew new-cell found :test #'equal)))))
          (setq prettify-symbols-alist
                (cl-set-difference prettify-symbols-alist
                                   (cl-set-difference
                                    (cl-remove-if-not
                                     (lambda (elm)
                                       (eq (cdr elm) rasmus/ob-header-symbol))
                                     prettify-symbols-alist)
                                    found :test #'equal)))
          ;; Clean up old font-lock-keywords.
          (font-lock-remove-keywords nil prettify-symbols--keywords)
          (setq prettify-symbols--keywords (prettify-symbols--make-keywords))
          (font-lock-add-keywords nil prettify-symbols--keywords)
          (while (re-search-forward re nil t)
            (font-lock-flush (line-beginning-position) (line-end-position))))))

    (defun rasmus/org-prettify-src ()
      "Hide src options via `prettify-symbols-mode'.

    `prettify-symbols-mode' is used because it has uncollpasing. It's
    may not be efficient."
      (let* ((case-fold-search t)
             (at-src-block (save-excursion
                             (beginning-of-line)
                             (looking-at "^[ \t]*#\\+begin_src[ \t]+[^ \f\t\n\r\v]+[ \t]*"))))
        ;; Test if we moved out of a block.
        (when (or (and rasmus/org-at-src-begin
                       (not at-src-block))
                  ;; File was just opened.
                  (eq rasmus/org-at-src-begin -1))
          (rasmus/org-prettify-src--update))
        ;; Remove composition if at line; doesn't work properly.
        ;; (when at-src-block
        ;;   (with-silent-modifications
        ;;     (remove-text-properties (match-end 0)
        ;;                             (1+ (line-end-position))
        ;;                             '(composition))))
        (setq rasmus/org-at-src-begin at-src-block)))

    (defun rasmus/org-prettify-symbols ()
      (mapc (apply-partially 'add-to-list 'prettify-symbols-alist)
            (cl-reduce 'append
                       (mapcar (lambda (x) (list x (cons (upcase (car x)) (cdr x))))
                               `(("#+begin_src" . ?╦) ;; ➤ 🖝 ➟ ➤ ✎ ✎
                                 ("#+end_src"   . ?╩) ;; □
                                 ("#+header:" . ,rasmus/ob-header-symbol)
                                 ("#+begin_comment" . ?✎)
                                 ("#+end_comment" . ?✎)
                                 ("#+begin_notes" . ?➤)
                                 ("#+end_notes" . ?➤)
                                 ("#+begin_quote" . ?»)
                                 ("#+end_quote" . ?«)))))
      (turn-on-prettify-symbols-mode)
      (add-hook 'post-command-hook 'rasmus/org-prettify-src t t))
    (add-hook 'org-mode-hook #'rasmus/org-prettify-symbols))


#+END_SRC


*** Org-Goto
Make counsel display org headings nicely. 
#+BEGIN_SRC emacs-lisp
(with-eval-after-load 'org
  (setq counsel-org-goto-display-style 'path)
  (setq counsel-org-goto-separator " ➜ ")
  (setq counsel-org-goto-face-style 'org)
  (define-key org-mode-map (kbd "C-c C-j") 'counsel-org-goto)
  (define-key org-mode-map (kbd "C-u C-c C-j") 'counsel-org-goto-all))
#+END_SRC
*** Org-Reveal
#+BEGIN_SRC emacs-lisp
  (use-package ox-reveal
  :commands (org-reveal-export-current-subtree org-reveal-export-to-html-and-browse)
  :config
  (setq org-reveal-root (concat "file://" (getenv "HOME") "/bin/reveal.js")
        org-reveal-theme "moon"
        org-reveal-default-frag-style "roll-in"
        org-reveal-hlevel 2
        ))
       
(defun cpm/narrowed-subtree-to-html ()
  "export narrowed tree to html"
  (interactive)
  (org-reveal-export-current-subtree)
  (org-narrow-to-subtree))
#+END_SRC
*** Org Organization (GTD)
**** GTD Projects
#+begin_src emacs-lisp
(defun cpm/org-goto-todo ()
  (interactive)
  (find-file "~/Dropbox/org-files/todo.org")
  (widen)
  (beginning-of-buffer)
  (re-search-forward "* Inbox")
  (beginning-of-line))

(defun cpm/org-goto-inbox ()
  (interactive)
  (find-file "~/Dropbox/org-files/inbox.org")
  (widen)
  (beginning-of-buffer)
  (beginning-of-line))

(defun cpm/org-goto-projects ()
  (interactive)
  (find-file "~/Dropbox/org-files/todo.org")
  (widen)
  (beginning-of-buffer)
  (re-search-forward "* Projects")
  (beginning-of-line))

(defun cpm/project-overview ()
  (interactive)
  (cpm/org-goto-projects)
  (org-narrow-to-subtree)
  (org-columns))
#+end_src
**** Stuck Projects
#+begin_src emacs-lisp
(defun cpm/my-org-agenda-list-stuck-projects ()
  (interactive)
  (cpm/org-goto-projects)
  (org-agenda nil "#" 'subtree))
#+end_src
**** Areas
#+begin_src emacs-lisp
(defun cpm/go-to-areas ()
    (interactive)
    (find-file "~/Dropbox/org-files/todo.org")
    (widen)
    (beginning-of-buffer)
    (re-search-forward "* Areas")
    (beginning-of-line))

(defun cpm/areas-overview ()
    (interactive)
    (go-to-areas)
    (org-narrow-to-subtree)
    (org-columns))
#+end_src
**** Random Notes
#+begin_src emacs-lisp
(use-package org-randomnote
  :commands (org-randomnote org-randomnote--go-to-random-header org-randomnote--get-random-file org-randomnote--get-random-subtree)
  :init
  (setq org-randomnote-candidates '("~/Dropbox/org-files/todo.org")))
#+end_src
*** Org Export
#+BEGIN_SRC emacs-lisp
(setq org-export-backends '(ascii html icalendar latex odt pandoc hugo md))
#+END_SRC
**** Org & Pandoc (Ox-pandoc)

#+BEGIN_SRC emacs-lisp
  (use-package ox-pandoc
    :after ox
    :config
    ;; default options for all output formats
    (setq org-pandoc-command (expand-file-name "/usr/local/bin/pandoc"))
    (setq org-pandoc-options '((standalone . t)))
    ;; cancel above settings only for 'docx' format
    (setq org-pandoc-options-for-docx '((standalone . nil)))
    ;; special settings for beamer-pdf and latex-pdf exporters
    (setq org-pandoc-options-for-beamer-pdf '((pdf-engine . "xelatex")))
    (setq org-pandoc-options-for-latex-pdf '((pdf-engine . "xelatex")))
    (setq org-pandoc-format-extensions '(org+smart)))
#+END_SRC 

**** DISABLED Org Markdown Export
CLOSED: [2018-07-14 Sat 00:45]
Various exporters to use. Right now it is just markdown that I need.
#+BEGIN_SRC emacs-lisp :tangle no
(eval-after-load "org"
  '(require 'ox-md nil t))
#+END_SRC

**** Ox-Hugo
[[https://github.com/kaushalmodi/ox-hugo][Export]] to Hugo with Org
#+BEGIN_SRC emacs-lisp
(use-package ox-hugo)
#+END_SRC


**** Org Export Top-Level Trees
From a useful [[https://emacs.stackexchange.com/questions/27226/how-to-export-top-level-trees-in-an-org-file-to-corresponding-files][stack exchange]] post
#+BEGIN_SRC emacs-lisp
(defun cpm/org-map-entries (org-file in-tags func)
  (let ((tags (if (stringp in-tags)
                   (list in-tags)
                 in-tags)))

    (with-temp-buffer
      (org-mode)
      (insert-file-contents org-file-main)

      ;; Execute func at each heading that matches tags.
      (while (< (point) (point-max))

        ;; If find a heading...
        (and (search-forward-regexp "^\* " nil "end")

             ;; ...that matches the given tags...
             (seq-reduce
              (lambda(a b) (and a b))
              (mapcar
               (lambda (tag)
                 (beginning-of-line)
                 (search-forward-regexp
                  (concat ":" tag ":") (line-end-position) "end"))
               tags)
              t)

             ;; ... then execute given function with cursor at beginning of
             ;; heading.
             (progn
               (beginning-of-line)
               (save-excursion
                 (funcall func))
               (end-of-line)))))))
#+END_SRC





*** Org Functions
Some useful org-specific functions
**** Org-Fill Functions
 Functions to calculate apt offsets and call regular org fill stuff. There's a
 useful [[http://stackoverflow.com/questions/14351154/org-mode-outline-level-specific-fill-column-values][stack overflow thread]] on this. 
#+BEGIN_SRC emacs-lisp
  (defun calc-offset-on-org-level ()
    "Calculate offset (in chars) on current level in org mode file."
    (* (or (org-current-level) 0) org-indent-indentation-per-level))

  (defun my-org-fill-paragraph (&optional JUSTIFY)
    "Calculate apt fill-column value and fill paragraph."
    (let* ((fill-column (- fill-column (calc-offset-on-org-level))))
      (org-fill-paragraph JUSTIFY)))

  (defun my-org-auto-fill-function ()
    "Calculate apt fill-column value and do auto-fill"
    (let* ((fill-column (- fill-column (calc-offset-on-org-level))))
      (org-auto-fill-function)))
    
  (defun my-org-mode-hook ()
    (setq fill-paragraph-function   'my-org-fill-paragraph
          normal-auto-fill-function 'my-org-auto-fill-function))

  ;; (add-hook 'org-load-hook 'my-org-mode-hook)
  ;; (add-hook 'org-mode-hook 'my-org-mode-hook)
#+END_SRC
**** Narrow & Advance/Retreat
Functions to advance forwards or backwards through narrowed tree
#+BEGIN_SRC emacs-lisp
(defun cpm/org-advance ()
  (interactive)
  (when (buffer-narrowed-p)
    (beginning-of-buffer)
    (widen)
    (org-forward-heading-same-level 1))
  (org-narrow-to-subtree))

(defun cpm/org-retreat ()
  (interactive)
  (when (buffer-narrowed-p)
    (beginning-of-buffer)
    (widen)
    (org-backward-heading-same-level 1))
  (org-narrow-to-subtree))
#+END_SRC
**** Org files
#+BEGIN_SRC emacs-lisp
(defun cpm/goto-org-files ()
  "goto org-files directory"
  (interactive)
  (require 'ranger)
  (find-file "~/Dropbox/org-files"))
(defun cpm/goto-mail-inbox.org ()
  "goto org-mail-inbox"
  (interactive)
  (find-file "~/Dropbox/org-files/mail.org"))
(defun cpm/goto-todo.org ()
  "goto org-todo"
  (interactive)
  (find-file "~/Dropbox/org-files/todo.org"))
(defun cpm/goto-articles.org ()
  "goto org-articles"
  (interactive)
  (find-file "~/Dropbox/org-files/articles.org"))
(defun cpm/goto-classes.org ()
  "goto org-classes"
  (interactive)
  (find-file "~/Dropbox/org-files/classes.org"))
(defun cpm/goto-notes.org ()
  "goto org-notes"
  (interactive)
  (find-file "~/Dropbox/org-files/org-notes.org"))
(defun cpm/goto-someday.org ()
  "goto org-someday"
  (interactive)
  (find-file "~/Dropbox/org-files/someday.org"))
#+END_SRC
**** Export Headings as Separate PDF Files
Helpful advice from [[http://pragmaticemacs.com/emacs/export-org-mode-headlines-to-separate-files/][pragmatic emacs]]
#+BEGIN_SRC emacs-lisp
;; export headlines to separate files
;; http://emacs.stackexchange.com/questions/2259/how-to-export-top-level-headings-of-org-mode-buffer-to-separate-files
(defun cpm/org-export-headlines-to-pdf ()
  "Export all subtrees that are *not* tagged with :noexport: to
separate files.

Subtrees that do not have the :EXPORT_FILE_NAME: property set
are exported to a filename derived from the headline text."
  (interactive)
  (save-buffer)
  (let ((modifiedp (buffer-modified-p)))
    (save-excursion
      (goto-char (point-min))
      (goto-char (re-search-forward "^*"))
      (set-mark (line-beginning-position))
      (goto-char (point-max))
      (org-map-entries
       (lambda ()
         (let ((export-file (org-entry-get (point) "EXPORT_FILE_NAME")))
           (unless export-file
             (org-set-property
              "EXPORT_FILE_NAME"
              (replace-regexp-in-string " " "_" (nth 4 (org-heading-components)))))
           (deactivate-mark)
           (org-pandoc-export-to-latex-pdf nil t)
           (unless export-file (org-delete-property "EXPORT_FILE_NAME"))
           (set-buffer-modified-p modifiedp)))
       "-noexport" 'region-start-level))))
#+END_SRC
*** Org Rifle
Search [[https://github.com/alphapapa/helm-org-rifle][rapidly]] through org files using helm
#+BEGIN_SRC emacs-lisp
  (use-package helm-org-rifle
    :commands (helm-org-rifle helm-org-rifle-agenda-files helm-org-rifle-org-directory))
#+END_SRC
*** Org-Download
Drag and drop images to Emacs org-mode. Courtesy of [[https://github.com/abo-abo/org-download][abo-abo]]. 
#+BEGIN_SRC emacs-lisp
  (use-package org-download
    :commands (org-download-yank org-download-screenshot org-download-image)
    :config
     (setq org-download-method 'directory)
           org-download-image-dir "~/Dropbox/org-files/org-pictures"
           org-download-image-latex-width 500
   )
#+END_SRC
*** Org Pomodoro
Helps with time tracking
#+BEGIN_SRC emacs-lisp
  (use-package org-pomodoro
    :commands org-pomodoro
    :init
    (progn
      (setq org-pomodoro-audio-player "/usr/bin/afplay")))
#+END_SRC emacs-lisp
*** Org Indirect Buffer
Some advice to automatically switch to a new indirect buffer upon creation
#+BEGIN_SRC emacs-lisp
(defadvice org-tree-to-indirect-buffer (after org-tree-to-indirect-buffer-after activate) (other-window 1))
#+END_SRC


*** Org Numbers Overlay
[[https://github.com/larkery/emacs/blob/master/site-lisp/org-numbers-overlay.el][This]] is a useful minor-mode to number org-mode headings. It came up in
the course of [[https://www.reddit.com/r/emacs/comments/6crtzw/it_is_possible_to_display_numbers_at_the/][this reddit]] discussion. 
#+BEGIN_SRC emacs-lisp
(define-minor-mode org-numbers-overlay-mode
  "Add overlays to org headings which number them"
  nil " *1." nil

  (let ((hooks '(after-save-hook
                 org-insert-heading-hook))
        (funcs '(org-promote
                 org-cycle-level
                 org-promote-subtree
                 org-demote
                 org-demote-subtree
                 org-move-subtree-up
                 org-move-subtree-down
                 org-move-item-down
                 org-move-item-up
                 org-cut-subtree
                 org-insert-todo-heading
                 org-insert-todo-subheading
                 org-meta-return
                 org-set-property
                 org-move)))
    (if org-numbers-overlay-mode
        (progn
          (org-numbers-overlay-update)
          (dolist (fn funcs)
            (advice-add fn :after #'org-numbers-overlay-update))
          (dolist (hook hooks)
            (add-hook hook #'org-numbers-overlay-update)))

      (progn
        (dolist (fn funcs)
          (advice-add fn :after #'org-numbers-overlay-update))
        (dolist (hook hooks)
          (remove-hook hook #'org-numbers-overlay-update))

        (loop for o in (overlays-in (point-min) (point-max))
              if (eq (overlay-get o 'type) 'org-number)
              do (delete-overlay o))))))

(defun org-numbers-overlay-update (&rest args)
  (when org-numbers-overlay-mode
    (let ((levels (make-vector 10 0)))
      (save-excursion
        (widen)
        (goto-char (point-min))
        (while (outline-next-heading)
          (if (assoc "UNNUMBERED" (org-entry-properties))
              ;; if it's unnumbered delete any overlays we have on it
              (loop for o in (overlays-in (point)
                                          (save-excursion (end-of-line) (point)))
                    if (eq (overlay-get o 'type) 'org-number)
                    do (delete-overlay o))
            ;; if it's not unnumbered add a number or update it
            (let* ((detail (org-heading-components))
                   (level (- (car detail) 1))
                   (lcounter (1+ (aref levels level)))
                   (o (or (loop for o in (overlays-in (point)
                                                      (save-excursion (end-of-line) (point)))
                                if (eq (overlay-get o 'type) 'org-number)
                                return o)
                          (make-overlay (point) (+ (point) (car detail))))))
              (aset levels level lcounter)
              (loop for i from (1+ level) to 9
                    do (aset levels i 0))
              (overlay-put o 'type 'org-number)
              (overlay-put o 'evaporate t)
              (overlay-put o 'after-string
                           (let (s)
                             (loop for i across levels
                                   until (zerop i)
                                   do (setf s (if s (format "%s.%d" s i)
                                                (format " %d" i))
                                            ))
                             s)))))))))
(provide 'org-numbers-overlay)
#+END_SRC
*** Toc-org
Let's install and load the =toc-org= package after org mode is loaded. This is the
package that automatically generates an up to date table of contents for us.

#+BEGIN_SRC emacs-lisp
(use-package toc-org
  :after org
  :demand t
  :init (add-hook 'org-mode-hook #'toc-org-enable))
#+END_SRC

*** Org Miscellaneous Packages  
Other useful org packages

#+BEGIN_SRC emacs-lisp
  (use-package htmlize :commands (htmlize-buffer))
  (use-package org-inlinetask :ensure nil :commands org-inlinetask-insert-task)
  ;; ignore export of headlines marked with :ignore: tag
  (with-eval-after-load 'org
    (require 'ox-extra)
    (ox-extras-activate '(ignore-headlines)))
#+END_SRC 

#+RESULTS:






** Zettelkasten minor mode
A minor mode for using deft as a Zettelkasten. From [[https://github.com/cszang/dotemacs/blob/master/lisp/zettelkasten.el][cszang]]. 
#+BEGIN_SRC emacs-lisp 
  ;; ZETTELKASTEN
  ;; a minor mode for making working with deft the ultimate zettelkasten
  ;; experience

  (require 's)
  (require 'dash)
  (require 'thingatpt)

  ;; file to record Zettel statistics (currently only growth of the Zettelkasten)
  (setq deft-directory (concat org-directory "/zettel/"))

  (setq zk-stats-file (concat deft-directory "/000000000000 Zettel-Stats.txt"))

  (setq zk-position-list ())
  (setq zk-buffer-list ())
  (setq zk-jump-position 0)

  (defun zk-push-current-pos ()
    (interactive)
    (push (point) zk-position-list)
    (push (buffer-name) zk-buffer-list)
    )

  (defun zk-save-current-position ()
    (interactive)
    (zk-push-current-pos)
    (message "Saved current position.")
    )

  (defun zk-jump-back ()
    (interactive)
    (setq zk-jump-position (+ zk-jump-position 1))
    (switch-to-buffer (nth zk-jump-position zk-buffer-list))
    (goto-char (nth zk-jump-position zk-position-list))
    )

  (defun zk-jump-forward ()
    (interactive)
    (setq zk-jump-position (- zk-jump-position 1))
    (switch-to-buffer (nth zk-jump-position zk-buffer-list))
    (goto-char (nth zk-jump-position zk-position-list))
    )

  (defun zk-current-time ()
    (format-time-string "%Y-%m-%d-%H%M")
    )

  (defun zk-follow-internal-link ()
    (interactive)
    (zk-push-current-pos)
    (setq zk-search-string (word-at-point))
    (deft)
    (setq deft-filter-regexp (list zk-search-string))
    (deft-filter-update)
    (deft-refresh-browser)
    )

  (defun zk-insert-timestamp ()
    (interactive)
    (insert (format-time-string "%Y-%m-%d-%k%M"))
    )

  (defun zk-new-with-timestamp ()
    (interactive)
    (setq zk-time-string (zk-current-time))
    (deft)
    (setq deft-filter-regexp (list zk-time-string))
    (deft-filter-update)
    (deft-refresh-browser)
    )

  (defun zk-insert-timestamp-for-internal-link ()
    (interactive)
    (setq zk-all-dated-files (directory-files deft-directory nil "^[0-9]\\{12\\}\\.*"))
    (setq zk-link-file (ido-completing-read "Link? " zk-all-dated-files))
    (insert (concat "[[" (car (s-match "^[0-9]\\{12\\}" zk-link-file)) "]]"))
    )

  (defun zk-insert-org-link-to-zettel ()
    (interactive)
    (setq zk-all-dated-files (directory-files deft-directory nil "^[0-9]\\{12\\}\\.*"))
    (setq zk-link-file (ido-completing-read "Link? " zk-all-dated-files))
    (insert (org-make-link-string (concat "file:" deft-directory "/" zk-link-file)
                                  (concat "Zettel:" (car (s-match "^[0-9]\\{12\\}" zk-link-file)))))
    )

  (defun flatten (mylist)
    (cond
     ((null mylist) nil)
     ((atom mylist) (list mylist))
     (t
      (append (flatten (car mylist)) (flatten (cdr mylist))))))

  (defun zk-match-tag-in-buffer (f)
    "append all matches of tags in a buffer to a list"
    (save-excursion
      (setq zk-tagline-regex "^tags:.*$")
      (setq zk-tag-regex "#\\w+")
      (find-file f)
      (setq zk-tagline (car (s-match zk-tagline-regex (buffer-string))))
      (setq zk-tags-in-note (s-match-strings-all zk-tag-regex zk-tagline))
      (setq zk-tag-list (append zk-tag-list zk-tags-in-note))
      (kill-buffer (current-buffer))))

  (defun zk-get-tag-list ()
    "gets all tags from all notes"
    (interactive)
    (setq zk-start-buffer buffer-file-name)
    (setq zk-scan-files (-remove (lambda (f) (string= zk-start-buffer f))
                                   (directory-files deft-directory t ".txt$")))
    (setq zk-tag-list '(()))
    (mapc 'zk-match-tag-in-buffer zk-scan-files)
    (setq zk-tag-list (-distinct (flatten zk-tag-list)))
    )

  (defun zk-complete-tag ()
    "completes tags from all previously used tags"
    (interactive)
    (insert (concat (ido-completing-read "Schlagwort? " zk-tag-list) " " )))

  (defun zk-insert-tagline ()
    (interactive)
    (zk-get-tag-list)
    (backward-page)
    (open-line 2)
    (insert (concat "tags: " (ido-completing-read "Schlagwort? " zk-tag-list) " " )))

  (defun zk-find-similar ()
    (interactive)
    (setq zk-this-file (file-name-base))
    (setq zk-id-this-file (car (s-match "^[0-9]\\{12\\}" zk-this-file)))
    (setq zk-similar (shell-command-to-string (concat "~/.emacs.d/R/concordance " zk-id-this-file)))
    (other-window 1)
    (switch-to-buffer-other-window "*Ähnliche Notizen*")
    (insert "Ähnliche Notizen:\n" zk-similar)
    (zk-mode)
    )

  (defun zk-zettel-reference-at-point ()
    (interactive)
    (setq zk-all-dated-files (directory-files deft-directory nil "^[0-9]\\{12\\}\\.*"))
    (setq current-id (thing-at-point 'symbol))
    (message (seq-find (lambda (zettel)
                         (s-starts-with? current-id zettel))
                       zk-all-dated-files "No matching Zettel found."))
    )

  (defun zk-goto-zettel-at-point ()
    (interactive)
    (zk-push-current-pos)
    (setq zk-all-dated-files (directory-files deft-directory nil "^[0-9]\\{12\\}\\.*"))
    (setq current-id (thing-at-point 'symbol))
    (setq zettel-at-point (seq-find (lambda (zettel)
                                      (s-starts-with? current-id zettel))
                                    zk-all-dated-files ""))
    (if (s-equals? "" zettel-at-point)
        (message "No matching Zettel found.")
      (find-file (concat deft-directory "/" zettel-at-point))
      )
    )

  (defun zk-insert-reference-skeleton ()
    (interactive)
    (insert "---")
    (newline)
    (clipboard-yank)
    (insert "---")
    (newline)
    (insert "tags: #ref #todo")
    (newline)
    (insert "tldr:")
    (newline)
    )

  (defun zk-count-zettels ()
    (length (directory-files deft-directory "\\.txt\\'"))
    )

  (defun zk-write-stats ()
    (interactive)
    (append-to-file (concat (zk-current-time) " " (number-to-string (zk-count-zettels)) "\n") nil zk-stats-file)
    )

  (define-minor-mode zk-mode
    "Some functionality to provide a decent Zettelkasten-Workflow for Deft."
    :lighter " zk"
    :keymap (let ((map (make-sparse-keymap)))
              (define-key map (kbd "C-c o") 'zk-follow-internal-link)
              (define-key map (kbd "C-c d") 'zk-new-with-timestamp)
              (define-key map (kbd "C-c l") 'zk-insert-timestamp-for-internal-link)
              (define-key map (kbd "C-c t") 'zk-insert-tagline)
              (define-key map (kbd "C-c #") 'zk-complete-tag)
              (define-key map (kbd "C-c s") 'zk-find-similar)
              (define-key map (kbd "C-c i") 'zk-zettel-reference-at-point)
              (define-key map (kbd "M-.")   'zk-goto-zettel-at-point)
              (define-key map (kbd "C-c _") 'zk-jump-back)
              (define-key map (kbd "C-c *") 'zk-jump-forward)
              (define-key map (kbd "C-c .") 'zk-save-current-position)
              (define-key map (kbd "C-c §") 'zk-insert-reference-skeleton)
              map)
    (auto-fill-mode)
    (font-lock-add-keywords 'org-mode
                            '(("\\(\\[\\[\\)\\(.*\\)\\(\\]\\]\\)"
                               (1 font-lock-comment-face)
                               (2 font-lock-doc-face)
                               (3 font-lock-comment-face))
                              ("#[a-z0-9_]*" . font-lock-keyword-face)
                              ))
    )

  (defun zk-minor-mode-on ()
    "Turn on `zk' mode."
    (interactive)
    (zk-mode 1))

  ;; (add-hook 'markdown-mode-hook 'zk-minor-mode-on)

  (add-hook 'deft-mode-hook (lambda () (zk-get-tag-list)))
  (add-hook 'deft-mode-hook (lambda () (deft-refresh)))
  (add-hook 'deft-mode-hook (lambda () (zk-write-stats)))
#+END_SRC

#+TITLE: Archive
#+DATE: 2018-07-09



** Deft Notes
#+BEGIN_SRC emacs-lisp
  (use-package deft
    :commands (deft deft-find-file cpm/deft)
    :init
    (progn
      ;; start in insert mode
      (add-to-list 'evil-insert-state-modes 'deft-mode)
      (setq deft-extensions '("org" "md" "txt")
            deft-directory "~/Dropbox/org-files"
            deft-text-mode 'org-mode
            deft-use-filter-string-for-filename t ;; use filter string as filename
            deft-org-mode-title-prefix t ;; add #+TITLE prefix
            deft-recursive t  ;; search recursively in folders
            deft-use-filename-as-title t)
    :config
    ;; Make sure titles have no spaces: from [[http://pragmaticemacs.com/category/deft/][pragmaticemacs]]
    ;;advise deft-new-file-named to replace spaces in file names with -
    (defun bjm-deft-strip-spaces (args)
    "Replace spaces with - in the string contained in the first element of the list args. Used to advise deft's file naming function."
    (list (replace-regexp-in-string " " "-" (car args)))
    )
    (advice-add 'deft-new-file-named :filter-args #'bjm-deft-strip-spaces)

  ;;function to run deft in specified directory
  (defun any-deft (dir)
    "Run deft in directory DIR"
    (setq deft-directory dir)
    (switch-to-buffer "*Deft*")
    (kill-this-buffer)
    (require 'org)
    (deft)
    )
  (defun big-notes ()
    "Goto main notes with deft"
    (interactive)
    (any-deft "~/Dropbox/Notes")
    (kill-this-buffer)
    (any-deft "~/Dropbox/Notes")
  )
  (defun research-notes ()
    "Goto research notes"
    (interactive)
    (any-deft "~/Dropbox/org-files/Wiki"))))
#+END_SRC

** DISABLED Org Wiki
CLOSED: [2018-06-20 Wed 00:15]
#+begin_src emacs-lisp :tangle no
(use-package org-wiki
  :load-path "~/.emacs.d/.local/elisp"
  :commands (org-wiki-export-html-sync org-wiki-open org-wiki-helm org-wiki-dired org-wiki-index)
  :init
  (setq  org-wiki-location "~/Dropbox/org-files/Wiki")
)
#+end_src
** Org Clock Hydra
A useful [[https://gist.github.com/deerpig/3cebadb236fed15c54b45f73a4321336#file-hydra-org-el][Gist]]. From a useful [[https://www.reddit.com/r/emacs/comments/85z9k4/marcin_borkowskis_orgmode_hydra/][reddit]] discussion.
#+BEGIN_SRC emacs-lisp
;; hydra-org ----------------------------------------------------
;;
;; based on Marcin Borkowski's Org-mode Hydra: 
;; http://mbork.pl/2018-03-18_My_Org-mode_hydra

(defhydra cpm/hydra-org-clock (:color pink :timeout 12 :hint nil)
  "
                                                                      ╭──────────┐
                                                                      │ Org Mode │
 ╭────────────────────────────────────────────────────────────────────┴──────────╯
  Clock In  [_i_]  Cancel a clock [_q_]  Go to a clock [_j_] Clock in last task [_<f10>_]
  Clock Out [_o_]  Create TODO    [_m_]                                  Quit [_<SPC>_] 
"
  ("i" (lambda () (interactive) (org-clock-in '(4))))
  ("o" org-clock-out)
  ("q" org-clock-cancel )
  ("<f10>" org-clock-in-last )
  ("j" (lambda () (interactive) (org-clock-goto '(4))) ) 
  ("m" make-this-message-into-an-org-todo-item )
  ("<SPC>" nil nil))
#+END_SRC
** FIXME Tabs
Buffer tabs in modeline or Echo are. [[https://github.com/linktohack/buffer-line][Pictures]] help. Works well, especially
with a toggle but I need to figure out evil bindings to make it easy to
key a buffer up quickly. 
#+BEGIN_SRC emacs-lisp
(use-package buffer-line
  :load-path "~/.emacs.d/.local/elisp/buffer-line/"
  :commands buffer-line-mode
  :init
  (setq buffer-line-place 'echo-area)    ; Acceptable value: `nil' or `echo-area', `mode-line'
  (setq buffer-line-mode-line-limit 60)  ; In case of `mode-line'.
  )
#+END_SRC
** TESTING Academic Phrases
Use common [[https://github.com/nashamri/academic-phrases][academic phrases]] in papers
#+BEGIN_SRC emacs-lisp
(use-package academic-phrases
 :commands (academic-phrases academic-phrases-by-section))
#+END_SRC
** DISABLED Org Projectile
CLOSED: [2018-06-18 Mon 18:29]
:PROPERTIES:
:DATE_ADDED: March 3, 2018
:END:
[Not quite there yet - but should keep an eye on this project]
[[https://github.com/IvanMalison/org-projectile][Manage]] project TODOs with org mode and projectile. Seems like it will be
useful but we'll see.  

#+BEGIN_SRC emacs-lisp
(use-package org-projectile
  :commands (org-projectile-project-todo-entry org-projectile-project-todo-completing-read)
  :general 
  (:states '(normal visual emacs)
  :keymaps 'override
  :prefix "SPC"
  :non-normal-prefix "C-SPC"
  "p" '(:ignore t :which-key "Projects")
  "pt" 'org-projectile-project-todo-completing-read)
  :config
  (progn
    (setq org-projectile-projects-file "~/Dropbox/org-files/todo.org")
    (setq org-agenda-files (append org-agenda-files (org-projectile-todo-files)))
    (push (org-projectile-project-todo-entry) org-capture-templates))
  :ensure t)
#+END_SRC
** TESTING Eterm-256 Color
Add [[https://github.com/dieggsy/eterm-256color][customizable 256 color support]] to =term= and =ansiterm=
#+BEGIN_SRC emacs-lisp
  (use-package eterm-256color
    :ensure t
    :config
    (add-hook 'term-mode-hook #'eterm-256color-mode))
#+END_SRC
# "
** TESTING Github Stars
Browse your [[https://github.com/xuchunyang/github-stars.el/tree/894a2c3fd72ae233f7cce63f3af45afc32f18be3][Github stars]]
#+BEGIN_SRC emacs-lisp
  (use-package github-stars
    :ensure t
    :quelpa (github-stars :fetcher github :repo "xuchunyang/github-stars.el"))
#+END_SRC
** TESTING Mixed-Pitch
Mix fixed-pitch and variable-pitch fonts [[https://github.com/jabranham/mixed-pitch/tree/b6b1601c7a3eb9ab23e33192bc479bccc4dd5e7b][in Emacs]]
#+BEGIN_SRC emacs-lisp
(use-package mixed-pitch)
#+END_SRC
** TESTING Shell Path
#+BEGIN_SRC emacs-lisp
(use-package exec-path-from-shell
  :if (eq system-type 'darwin)
  :custom
  (exec-path-from-shell-check-startup-files nil)
  :config
  (exec-path-from-shell-initialize))
#+END_SRC
** TESTING Neotree
A [[https://github.com/jaypei/emacs-neotree][emacs tree plugin]] like NerdTree for Vim
#+BEGIN_SRC emacs-lisp
(use-package neotree
  :bind ("s-t" . neotree)
  :config
  (setq neo-dont-be-alone t
        neo-theme 'icons
        neo-smart-open t
        projectile-switch-project-action 'neotree-projectile-action)
  (evil-define-key 'normal neotree-mode-map (kbd "TAB") 'neotree-enter)
  (evil-define-key 'normal neotree-mode-map (kbd "SPC") 'neotree-quick-look)
  (evil-define-key 'normal neotree-mode-map (kbd "q") 'neotree-hide)
  (evil-define-key 'normal neotree-mode-map (kbd "RET") 'neotree-enter)
  (evil-define-key 'normal neotree-mode-map (kbd "u") 'neotree-select-up-node)
  (evil-define-key 'normal neotree-mode-map (kbd "i") 'neotree-enter)
  (evil-define-key 'normal neotree-mode-map (kbd "K") 'neotree-delete-node))
#+END_SRC
** DISABLED Ranger & Deer
CLOSED: [2018-07-04 Wed 14:14]
Better dired navigation using ranger-like settings. But I'm having lots of
performance issues and weird buffer problems. So disabling for now in favor of
dired with evil keybindings. 
#+BEGIN_SRC emacs-lisp
  (use-package ranger
    :commands (ranger deer deer-jump-other-window cpm/deer-split-window)
    :disabled t
    :init
    (setq ranger-override-dired t
          ranger-cleanup-eagerly t)
    ;; set up image-dired to allow picture resize
    (setq image-dired-dir (concat cpm-cache-dir "image-dir"))
    (unless (file-directory-p image-dired-dir)
      (make-directory image-dired-dir t))
    :config
    (setq  ranger-dont-show-binary t
           ranger-excluded-extensions '("mkv" "iso" "mp4" "png")
           ranger-max-preview-size 10
           ranger-preview-file t
           ranger-show-dotfiles t
           ranger-width-parents 0.25
           ranger-width-preview 0.55 
           ))

  (defun cpm/deer-split-window ()
   "Launch deer in vertical split"
   (interactive)
   (if (= (length (window-list)) 1)
     (progn
     (cpm/split-window-right-and-focus)
     (deer))
    (deer-jump-other-window)))

  ;; (defun deer-jump-other-window (&optional path)
  ;;   "Launch dired in a minimal ranger window in other window."
  ;;   (interactive)
  ;;   (switch-to-buffer-other-window (current-buffer))
  ;;   (deer path))

#+END_SRC

** DISABLED Another Doom Modeline
CLOSED: [2018-06-24 Sun 23:52]
[[https://github.com/torgeir/.emacs.d/blob/master/site-lisp/t-doom-modeline/t-doom-modeline.el][Torgeir's version]] of the [[https://github.com/hlissner/doom-emacs][doom mode line]]. 
#+BEGIN_SRC emacs-lisp :tangle no
  ;;; ui/doom-modeline/config.el -*- lexical-binding: t; -*-

  (defun t/project-root ()
    "Get project root without throwing"
    (let (projectile-require-project-root strict-p)
      (projectile-project-root)))

  ;; TODO torgeir added this
  (defun doom-project-root ()
    (require 'projectile)
    (t/project-root))


  (defmacro def-modeline-segment! (name &rest forms)
    "Defines a modeline segment and byte compiles it."
    (declare (indent defun) (doc-string 2))
    (let ((sym (intern (format "doom-modeline-segment--%s" name))))
      `(progn
         (defun ,sym () ,@forms)
         ,(unless (bound-and-true-p byte-compile-current-file)
            `(let (byte-compile-warnings)
               (byte-compile #',sym))))))

  (defsubst doom--prepare-modeline-segments (segments)
    (cl-loop for seg in segments
             if (stringp seg)
             collect seg
             else
             collect (list (intern (format "doom-modeline-segment--%s" (symbol-name seg))))))

  (defmacro def-modeline! (name lhs &optional rhs)
    "Defines a modeline format and byte-compiles it. NAME is a symbol to identify
  it (used by `doom-modeline' for retrieval). LHS and RHS are lists of symbols of
  modeline segments defined with `def-modeline-segment!'.
  Example:
    (def-modeline! minimal
      (bar matches \" \" buffer-info)
      (media-info major-mode))
    (doom-set-modeline 'minimal t)"
    (let ((sym (intern (format "doom-modeline-format--%s" name)))
          (lhs-forms (doom--prepare-modeline-segments lhs))
          (rhs-forms (doom--prepare-modeline-segments rhs)))
      `(progn
         (defun ,sym ()
           (let ((lhs (list ,@lhs-forms))
                 (rhs (list ,@rhs-forms)))
             (let ((rhs-str (format-mode-line rhs)))
               (list lhs
                     (propertize
                      " " 'display
                      `((space :align-to (- (+ right right-fringe right-margin)
                                            ,(+ 1 (string-width rhs-str))))))
                     rhs-str))))
         ,(unless (bound-and-true-p byte-compile-current-file)
            `(let (byte-compile-warnings)
               (byte-compile #',sym))))))

  (defun doom-modeline (key)
    "Returns a mode-line configuration associated with KEY (a symbol). Throws an
  error if it doesn't exist."
    (let ((fn (intern (format "doom-modeline-format--%s" key))))
      (when (functionp fn)
        `(:eval (,fn)))))

  (defun doom-set-modeline (key &optional default)
    "Set the modeline format. Does nothing if the modeline KEY doesn't exist. If
  DEFAULT is non-nil, set the default mode-line for all buffers."
    (let ((modeline (doom-modeline key)))
      (when modeline
        (setf (if default
                  (default-value 'mode-line-format)
                (buffer-local-value 'mode-line-format (current-buffer)))
              modeline))))

  ;; TODO /torgeir added this

  ;; Keep `+doom-modeline-current-window' up-to-date
  (defvar +doom-modeline-current-window (frame-selected-window))
  (defun +doom-modeline|set-selected-window (&rest _)
    "Sets `+doom-modeline-current-window' appropriately"
    (let ((win (frame-selected-window)))
      (unless (minibuffer-window-active-p win)
        (setq +doom-modeline-current-window win))))

  (add-hook 'window-configuration-change-hook #'+doom-modeline|set-selected-window)
  (add-hook 'focus-in-hook #'+doom-modeline|set-selected-window)
  (advice-add #'handle-switch-frame :after #'+doom-modeline|set-selected-window)
  (advice-add #'select-window :after #'+doom-modeline|set-selected-window)



  ;;
  ;; Variables
  ;;

  (defvar +doom-modeline-height 40
    "How tall the mode-line should be (only respected in GUI emacs).")

  (defvar +doom-modeline-bar-width 5
    "How wide the mode-line bar should be (only respected in GUI emacs).")

  (defvar +doom-modeline-vspc
    (propertize " " 'face 'variable-pitch)
    "TODO")

  ;; externs
  (defvar anzu--state nil)
  (defvar evil-mode nil)
  (defvar evil-state nil)
  (defvar evil-visual-selection nil)
  (defvar iedit-mode nil)
  (defvar all-the-icons-scale-factor)
  (defvar all-the-icons-default-adjust)


  ;;
  ;; Custom faces
  ;;

  (defgroup +doom-modeline nil
    ""
    :group 'doom)

  (defface doom-modeline-buffer-path
    '((t (:inherit mode-line-emphasis :bold t)))
    "Face used for the dirname part of the buffer path."
    :group '+doom-modeline)

  (defface doom-modeline-buffer-file
    '((t (:inherit mode-line-buffer-id)))
    "Face used for the filename part of the mode-line buffer path."
    :group '+doom-modeline)

  (defface doom-modeline-buffer-modified
    '((t (:inherit error :background nil :bold t)))
    "Face used for the 'unsaved' symbol in the mode-line."
    :group '+doom-modeline)

  (defface doom-modeline-buffer-major-mode
    '((t (:inherit mode-line-emphasis :bold t)))
    "Face used for the major-mode segment in the mode-line."
    :group '+doom-modeline)

  (defface doom-modeline-highlight
    '((t (:inherit mode-line-emphasis)))
    "Face for bright segments of the mode-line."
    :group '+doom-modeline)

  (defface doom-modeline-panel
    '((t (:inherit mode-line-highlight)))
    "Face for 'X out of Y' segments, such as `+doom-modeline--anzu', `+doom-modeline--evil-substitute' and
  `iedit'"
    :group '+doom-modeline)

  (defface doom-modeline-info
    `((t (:inherit success :bold t)))
    "Face for info-level messages in the modeline. Used by `*vc'."
    :group '+doom-modeline)

  (defface doom-modeline-warning
    `((t (:inherit warning :bold t)))
    "Face for warnings in the modeline. Used by `*flycheck'"
    :group '+doom-modeline)

  (defface doom-modeline-urgent
    `((t (:inherit error :bold t)))
    "Face for errors in the modeline. Used by `*flycheck'"
    :group '+doom-modeline)

  ;; Bar
  (defface doom-modeline-bar '((t (:inherit highlight :background "#268bd2")))
    "The face used for the left-most bar on the mode-line of an active window."
    :group '+doom-modeline)

  (defface doom-modeline-eldoc-bar '((t (:inherit shadow)))
    "The face used for the left-most bar on the mode-line when eldoc-eval is
  active."
    :group '+doom-modeline)

  (defface doom-modeline-inactive-bar '((t (:inherit warning :inverse-video t)))
    "The face used for the left-most bar on the mode-line of an inactive window."
    :group '+doom-modeline)


  ;;
  ;; Bootstrap
  ;;

  ;; Show version string for multi-version managers like rvm, rbenv, pyenv, etc.
  (defvar-local +doom-modeline-env-version nil)
  (defvar-local +doom-modeline-env-command nil)
  (add-hook! '(focus-in-hook find-file-hook) #'+doom-modeline|update-env)
  (defun +doom-modeline|update-env ()
    (when +doom-modeline-env-command
      (let* ((default-directory (doom-project-root))
             (s (shell-command-to-string +doom-modeline-env-command)))
        (setq +doom-modeline-env-version (if (string-match "[ \t\n\r]+\\'" s)
                                             (replace-match "" t t s)
                                           s)))))

  ;; Only support python and ruby for now

  ;; TODO torgeir
  (add-hook! 'python-mode-hook (setq +doom-modeline-env-command "python --version 2>&1 | cut -d' ' -f2"))
  (add-hook! 'ruby-mode-hook   (setq +doom-modeline-env-command "ruby   --version 2>&1 | cut -d' ' -f2"))


  ;;
  ;; Modeline helpers
  ;;

  (defsubst active ()
    (eq (selected-window) +doom-modeline-current-window))

  ;; Inspired from `powerline's `pl/make-xpm'.
  (def-memoized! +doom-modeline--make-xpm (color height width)
    "Create an XPM bitmap."
    (propertize
     " " 'display
     (let ((data (make-list height (make-list width 1)))
           (color (or color "None")))
       (create-image
        (concat
         (format "/* XPM */\nstatic char * percent[] = {\n\"%i %i 2 1\",\n\". c %s\",\n\"  c %s\","
                 (length (car data))
                 (length data)
                 color
                 color)
         (apply #'concat
                (cl-loop with idx = 0
                         with len = (length data)
                         for dl in data
                         do (cl-incf idx)
                         collect
                         (concat "\""
                                 (cl-loop for d in dl
                                          if (= d 0) collect (string-to-char " ")
                                          else collect (string-to-char "."))
                                 (if (eq idx len) "\"};" "\",\n")))))
        'xpm t :ascent 'center))))

  (defsubst +doom-modeline--buffer-file ()
    "Display the base of the current buffer's filename."
    (if buffer-file-name
        (file-name-nondirectory (or buffer-file-truename (file-truename buffer-file-name)))
      "%b"))

  (defsubst +doom-modeline--buffer-path ()
    "Displays the buffer's full path relative to the project root (includes the
  project root). Excludes the file basename. See `doom-buffer-name' for that."
    (when buffer-file-name
      (let ((buffer-path
             (file-relative-name (file-name-directory
                                  (or buffer-file-truename (file-truename buffer-file-name)))
                                 (doom-project-root))))
        (unless (equal buffer-path "./")
          (let ((max-length (truncate (* (window-body-width) 0.4))))
            (if (> (length buffer-path) max-length)
                (let ((path (nreverse (split-string buffer-path "/" t)))
                      (output ""))
                  (when (and path (equal "" (car path)))
                    (setq path (cdr path)))
                  (while (and path (<= (length output) (- max-length 4)))
                    (setq output (concat (car path) "/" output)
                          path (cdr path)))
                  (when path
                    (setq output (concat "../" output)))
                  (unless (string-suffix-p "/" output)
                    (setq output (concat output "/")))
                  output)
              buffer-path))))))


  ;;
  ;; Segments
  ;;

  (def-modeline-segment! buffer-project
    "Displays `doom-project-root'. This is for special buffers like the scratch
  buffer where knowing the current project directory is important."
    (let ((face (if (active) 'doom-modeline-buffer-path)))
      (concat (if (display-graphic-p) " ")
              (all-the-icons-octicon
               "file-directory"
               :face face
               :v-adjust -0.05
               :height 1.25)
              (propertize (concat " " (abbreviate-file-name (doom-project-root)))
                          'face face))))

  ;;
  (def-modeline-segment! buffer-info
    "Combined information about the current buffer, including the current working
  directory, the file name, and its state (modified, read-only or non-existent)."
    (let* ((all-the-icons-scale-factor 1.2)
           (modified-p (buffer-modified-p))
           (active (active))
           (faces (if modified-p 'doom-modeline-buffer-modified)))
      (concat (cond (buffer-read-only
                     (concat (all-the-icons-octicon
                              "lock"
                              :face 'doom-modeline-warning
                              :v-adjust -0.05)
                             " "))
                    (modified-p
                     (concat (all-the-icons-faicon
                              "floppy-o"
                              :face 'doom-modeline-buffer-modified
                              :v-adjust -0.0575)
                             " "))
                    ((and buffer-file-name
                          (not (file-exists-p buffer-file-name)))
                     (concat (all-the-icons-octicon
                              "circle-slash"
                              :face 'doom-modeline-urgent
                              :v-adjust -0.05)
                             " ")))
              (when-let (dir-path (+doom-modeline--buffer-path))
                (if-let (faces (or faces (if active 'doom-modeline-buffer-path)))
                    (propertize dir-path 'face `(:inherit ,faces))
                  dir-path))
              (when-let (file-path (+doom-modeline--buffer-file))
                (if-let (faces (or faces (if active 'doom-modeline-buffer-file)))
                    (propertize file-path 'face `(:inherit ,faces))
                  file-path)))))

  ;;
  (def-modeline-segment! buffer-info-simple
    "Return the current buffer name only, but with fontification."
    (propertize "%b" 'face (if (active) 'doom-modeline-buffer-file)))

  ;;
  (def-modeline-segment! buffer-encoding
    "Displays the encoding and eol style of the buffer the same way Atom does."
    (concat (let ((eol-type (coding-system-eol-type buffer-file-coding-system)))
              (cond ((eq eol-type 0) "LF  ")
                    ((eq eol-type 1) "CRLF  ")
                    ((eq eol-type 2) "CR  ")))
            (let* ((sys (coding-system-plist buffer-file-coding-system))
                   (sys-name (plist-get sys :name))
                   (sys-cat (plist-get sys :category)))
              (cond ((memq sys-cat '(coding-category-undecided coding-category-utf-8))
                     "UTF-8")
                    (t (upcase (symbol-name sys-name)))))
            "  "))

  ;;
  (def-modeline-segment! major-mode
    "The major mode, including process, environment and text-scale info."
    (propertize
     (concat (format-mode-line mode-name)
             (if (stringp mode-line-process) mode-line-process)
             (if +doom-modeline-env-version (concat " " +doom-modeline-env-version))
             (and (featurep 'face-remap)
                  (/= text-scale-mode-amount 0)
                  (format " (%+d)" text-scale-mode-amount)))
     'face (if (active) 'doom-modeline-buffer-major-mode)))

  ;;
  (def-modeline-segment! vcs
    "Displays the current branch, colored based on its state."
    (when vc-mode
      (let ((backend (when buffer-file-name (vc-backend buffer-file-name)))
            (state   (when buffer-file-name (vc-state buffer-file-name)))
            (face    'mode-line-inactive)
            (active  (active))
            (all-the-icons-scale-factor 1.0)
            (all-the-icons-default-adjust -0.1))
        (concat "  "
                (cond ((memq state '(edited added))
                       (if active (setq face 'doom-modeline-info))
                       (require 'all-the-icons)
                       (all-the-icons-octicon
                        "git-compare"
                        :face face
                        :height 1.2
                        :v-adjust -0.05))
                      ((eq state 'needs-merge)
                       (if active (setq face 'doom-modeline-info))
                       (all-the-icons-octicon "git-merge" :face face))
                      ((eq state 'needs-update)
                       (if active (setq face 'doom-modeline-warning))
                       (all-the-icons-octicon "arrow-down" :face face))
                      ((memq state '(removed conflict unregistered))
                       (if active (setq face 'doom-modeline-urgent))
                       (all-the-icons-octicon "alert" :face face))
                      (t
                       (if active (setq face 'font-lock-doc-face))
                       (all-the-icons-octicon
                        "git-compare"
                        :face face
                        :height 1.2
                        :v-adjust -0.05)))
                " "
                (propertize (substring vc-mode (+ (if (eq backend 'Hg) 2 3) 2))
                            'face (if active face))
                " "))))

  ;;
  (defun +doom-ml-icon (icon &optional text face voffset)
    "Displays an octicon ICON with FACE, followed by TEXT. Uses
  `all-the-icons-octicon' to fetch the icon."
    (concat
     (if vc-mode " " "  ")
     (when icon
       (concat
        (all-the-icons-material icon :face face :height 1.1 :v-adjust (or voffset -0.2))
        ;; (all-the-icons-octicon icon :face face :height 1.0 :v-adjust 0)
        (if text +doom-modeline-vspc)))
     (when text
       (propertize text 'face face))
     (if vc-mode "  " " ")))

  (def-modeline-segment! flycheck
    "Displays color-coded flycheck error status in the current buffer with pretty
  icons."
    (when (boundp 'flycheck-last-status-change)
      (pcase flycheck-last-status-change
        ('finished (if flycheck-current-errors
                       (let-alist (flycheck-count-errors flycheck-current-errors)
                         (let ((sum (+ (or .error 0) (or .warning 0))))
                           (+doom-ml-icon "do_not_disturb_alt"
                                          (number-to-string sum)
                                          (if .error 'doom-modeline-urgent 'doom-modeline-warning)
                                          -0.25)))
                     (+doom-ml-icon "check" nil 'doom-modeline-info)))
        ('running     (+doom-ml-icon "access_time" nil 'font-lock-doc-face -0.25))
        ('no-checker  (+doom-ml-icon "sim_card_alert" "-" 'font-lock-doc-face))
        ('errored     (+doom-ml-icon "sim_card_alert" "Error" 'doom-modeline-urgent))
        ('interrupted (+doom-ml-icon "pause" "Interrupted" 'font-lock-doc-face)))))
  ;; ('interrupted (+doom-ml-icon "x" "Interrupted" 'font-lock-doc-face)))))

  ;;
  (defsubst doom-column (pos)
    (save-excursion (goto-char pos)
                    (current-column)))

  (def-modeline-segment! selection-info
    "Information about the current selection, such as how many characters and
  lines are selected, or the NxM dimensions of a block selection."
    (when (and (active) (or mark-active (eq evil-state 'visual)))
      (let ((reg-beg (region-beginning))
            (reg-end (region-end)))
        (propertize
         (let ((lines (count-lines reg-beg (min (1+ reg-end) (point-max)))))
           (cond ((or (bound-and-true-p rectangle-mark-mode)
                      (eq 'block evil-visual-selection))
                  (let ((cols (abs (- (doom-column reg-end)
                                      (doom-column reg-beg)))))
                    (format "%dx%dB" lines cols)))
                 ((eq 'line evil-visual-selection)
                  (format "%dL" lines))
                 ((> lines 1)
                  (format "%dC %dL" (- (1+ reg-end) reg-beg) lines))
                 (t
                  (format "%dC" (- (1+ reg-end) reg-beg)))))
         'face 'doom-modeline-highlight))))


  ;;
  (defun +doom-modeline--macro-recording ()
    "Display current Emacs or evil macro being recorded."
    (when (and (active) (or defining-kbd-macro executing-kbd-macro))
      (let ((sep (propertize " " 'face 'doom-modeline-panel)))
        (concat sep
                (propertize (if (bound-and-true-p evil-this-macro)
                                (char-to-string evil-this-macro)
                              "Macro")
                            'face 'doom-modeline-panel)
                sep
                (all-the-icons-octicon "triangle-right"
                                       :face 'doom-modeline-panel
                                       :v-adjust -0.05)
                sep))))

  (defsubst +doom-modeline--anzu ()
    "Show the match index and total number thereof. Requires `anzu', also
  `evil-anzu' if using `evil-mode' for compatibility with `evil-search'."
    (when (and anzu--state (not iedit-mode))
      (propertize
       (let ((here anzu--current-position)
             (total anzu--total-matched))
         (cond ((eq anzu--state 'replace-query)
                (format " %d replace " total))
               ((eq anzu--state 'replace)
                (format " %d/%d " here total))
               (anzu--overflow-p
                (format " %s+ " total))
               (t
                (format " %s/%d " here total))))
       'face (if (active) 'doom-modeline-panel))))

  (defsubst +doom-modeline--evil-substitute ()
    "Show number of :s matches in real time."
    (when (and evil-mode
               (or (assq 'evil-ex-substitute evil-ex-active-highlights-alist)
                   (assq 'evil-ex-global-match evil-ex-active-highlights-alist)
                   (assq 'evil-ex-buffer-match evil-ex-active-highlights-alist)))
      (propertize
       (let ((range (if evil-ex-range
                        (cons (car evil-ex-range) (cadr evil-ex-range))
                      (cons (line-beginning-position) (line-end-position))))
             (pattern (car-safe (evil-delimited-arguments evil-ex-argument 2))))
         (if pattern
             (format " %s matches " (how-many pattern (car range) (cdr range)))
           " ... "))
       'face (if (active) 'doom-modeline-panel))))

  (defsubst +doom-modeline--iedit ()
    "Show the number of iedit regions matches + what match you're on."
    (when (and iedit-mode iedit-occurrences-overlays)
      (propertize
       (let ((this-oc (or (let ((inhibit-message t))
                            (iedit-find-current-occurrence-overlay))
                          (progn (iedit-prev-occurrence)
                                 (iedit-find-current-occurrence-overlay))))
             (length (length iedit-occurrences-overlays)))
         (format " %s/%d "
                 (if this-oc
                     (- length
                        (length (cdr
                                 (memq this-oc (sort (append iedit-occurrences-overlays (list))
                                                     (lambda (x y) (< (overlay-start x) (overlay-start y))))))))
                   "-")
                 length))
       'face (if (active) 'doom-modeline-panel))))

  (def-modeline-segment! matches
    "Displays: 1. the currently recording macro, 2. A current/total for the
  current search term (with anzu), 3. The number of substitutions being conducted
  with `evil-ex-substitute', and/or 4. The number of active `iedit' regions."
    (let ((meta (concat (+doom-modeline--macro-recording)
                        (+doom-modeline--anzu)
                        (+doom-modeline--evil-substitute)
                        (+doom-modeline--iedit))))
      (or (and (not (string= meta "")) meta)
          (if buffer-file-name " %I "))))

  ;; TODO Include other information
  (def-modeline-segment! media-info
    "Metadata regarding the current file, such as dimensions for images."
    (cond ((eq major-mode 'image-mode)
           (let ((size (image-size (image-get-display-property) :pixels)))
             (format "  %dx%d  " (car size) (cdr size))))))

  ;;
  (def-modeline-segment! eldoc
    "Display eldoc documentation in the mode-line while using the minibuffer (e.g.
  `eval-expression')."
    (bound-and-true-p str))

  ;; These bars regulate the height of the mode-line in GUI Emacs.
  (def-modeline-segment! bar
    (if (display-graphic-p)
        (+doom-modeline--make-xpm
         (face-background (if (active)
                              'doom-modeline-bar
                            'doom-modeline-inactive-bar)
                          nil t)
         +doom-modeline-height
         +doom-modeline-bar-width)
      ""))

  (def-modeline-segment! eldoc-bar
    "A differently colored bar, to signify an eldoc display."
    (if (display-graphic-p)
        (+doom-modeline--make-xpm
         (face-background 'doom-modeline-eldoc-bar nil t)
         +doom-modeline-height
         +doom-modeline-bar-width)
      ""))


  ;;
  ;; Mode lines
  ;;

  (def-modeline! main
    (bar matches " " buffer-info "  %l:%c %p  " selection-info)
    (buffer-encoding major-mode vcs flycheck))

  (def-modeline! eldoc
    (eldoc-bar " " eldoc)
    (media-info major-mode))

  (def-modeline! minimal
    (bar matches " " buffer-info)
    (media-info major-mode))

  (def-modeline! special
    (bar matches " " buffer-info-simple "  %l:%c %p  " selection-info)
    (buffer-encoding major-mode flycheck))

  (def-modeline! project
    (bar buffer-project)
    (major-mode))

  (def-modeline! media
    (bar " %b  ")
    (media-info major-mode))

  ;;
  (doom-set-modeline 'main t)

  ;; This scratch buffer is already created, and doesn't get a modeline. For the
  ;; love of Emacs, someone give the man a modeline!
  (with-current-buffer "*scratch*"
    (require 'all-the-icons)
    (doom-set-modeline 'main))


  ;;
  ;; Hooks
  ;;

  (defun +doom-modeline|set-special-modeline ()
    (doom-set-modeline 'special))

  (defun +doom-modeline|set-media-modeline ()
    (doom-set-modeline 'media))

  (add-hook 'org-src-mode-hook #'+doom-modeline|set-special-modeline)
  (add-hook 'image-mode-hook #'+doom-modeline|set-media-modeline)
  (add-hook 'circe-mode-hook #'+doom-modeline|set-special-modeline)

  (provide 't-doom-modeline)

#+END_SRC

** TESTING Org Date Hack
[[https://gist.github.com/fuxialexander/16e1ce6be518f6ba48e0acf92468627d][Hack]] to make scheduled/deadline faces look better 
#+BEGIN_SRC emacs-lisp
(setq org-ts-regexp-both-braket "\\([[<]\\)\\([0-9]\\{4\\}-[0-9]\\{2\\}-[0-9]\\{2\\} ?[^] 
\n>]*?\\)\\([]>]\\)")
  (defun *org-set-font-lock-defaults ()
    "Set font lock defaults for the current buffer."
    (let* ((em org-fontify-emphasized-text)
           (lk org-highlight-links)
           (org-font-lock-extra-keywords
            (list
             ;; Call the hook
             '(org-font-lock-hook)
             ;; Headlines
             `(,(if org-fontify-whole-heading-line
                    "^\\(\\**\\)\\(\\* \\)\\(.*\n?\\)"
                  "^\\(\\**\\)\\(\\* \\)\\(.*\\)")
               (1 (org-get-level-face 1))
               (2 (org-get-level-face 2))
               (3 (org-get-level-face 3)))
             ;; Table lines
             '("^[ \t]*\\(\\(|\\|\\+-[-+]\\).*\\S-\\)"
               (1 'org-table t))
             ;; Table internals
             '("^[ \t]*|\\(?:.*?|\\)? *\\(:?=[^|\n]*\\)" (1 'org-formula t))
             '("^[ \t]*| *\\([#*]\\) *|" (1 'org-formula t))
             '("^[ \t]*|\\( *\\([$!_^/]\\) *|.*\\)|" (1 'org-formula t))
             '("| *\\(<[lrc]?[0-9]*>\\)" (1 'org-formula t))
             ;; Drawers
             '(org-fontify-drawers)
             ;; Properties
             (list org-property-re
                   '(1 'org-special-keyword t)
                   '(3 'org-property-value t))
            ;; Special keywords
             (list (concat "\\<\\(DEADLINE: \\)" org-ts-regexp-both-braket)
                   '(1 'org-deadline-custom prepend)
                   '(2 'org-deadline-custom-braket prepend)
                   '(3 'org-deadline-custom prepend)
                   '(4 'org-deadline-custom-braket prepend))
             (list (concat "\\<\\(SCHEDULED: \\)" org-ts-regexp-both-braket)
                   '(1 'org-scheduled-custom prepend)
                   '(2 'org-scheduled-custom-braket prepend)
                   '(3 'org-scheduled-custom prepend)
                   '(4 'org-scheduled-custom-braket prepend))
             (list (concat "\\<\\(CLOSED: \\)" org-ts-regexp-both-braket)
                   '(1 'org-closed-custom prepend)
                   '(2 'org-closed-custom-braket prepend)
                   '(3 'org-closed-custom prepend)
                   '(4 'org-closed-custom-braket prepend))
             (list (concat "\\<" org-clock-string) '(0 'org-special-keyword prepend))
             ;; Link related fontification.
             '(org-activate-links)
             (when (memq 'tag lk) '(org-activate-tags (1 'org-tag prepend)))
             (when (memq 'radio lk) '(org-activate-target-links (1 'org-link t)))
             (when (memq 'date lk) '(org-activate-dates (0 'org-date t)))
             (when (memq 'footnote lk) '(org-activate-footnote-links))
             ;; Targets.
             (list org-any-target-regexp '(0 'org-target t))
             ;; Diary sexps.
             '("^&?%%(.*\\|<%%([^>\n]*?>" (0 'org-sexp-date t))
             ;; Macro
             '(org-fontify-macros)
             '(org-hide-wide-columns (0 nil append))
             ;; TODO keyword
             (list (format org-heading-keyword-regexp-format
                           org-todo-regexp)
                   '(2 (org-get-todo-face 2) t))
             ;; DONE
             (if org-fontify-done-headline
                 (list (format org-heading-keyword-regexp-format
                               (concat
                                "\\(?:"
                                (mapconcat 'regexp-quote org-done-keywords "\\|")
                                "\\)"))
                       '(2 'org-headline-done t))
               nil)
             ;; Priorities
             '(org-font-lock-add-priority-faces)
             ;; Tags
             '(org-font-lock-add-tag-faces)
             ;; Tags groups
             (when (and org-group-tags org-tag-groups-alist)
               (list (concat org-outline-regexp-bol ".+\\(:"
                             (regexp-opt (mapcar 'car org-tag-groups-alist))
                             ":\\).*$")
                     '(1 'org-tag-group prepend)))

             ;; Emphasis
             (when em '(org-do-emphasis-faces))
             ;; Checkboxes
             '("^[ \t]*\\(?:[-+*]\\|[0-9]+[.)]\\)[ \t]+\\(?:\\[@\\(?:start:\\)?[0-9]+\\][ \t]*\\)?\\(\\[[- X]\\]\\)"
               1 'org-checkbox prepend)
             (when (cdr (assq 'checkbox org-list-automatic-rules))
               '("\\[\\([0-9]*%\\)\\]\\|\\[\\([0-9]*\\)/\\([0-9]*\\)\\]"
                 (0 (org-get-checkbox-statistics-face) t)))
             ;; Description list items
             '("^[ \t]*[-+*][ \t]+\\(.*?[ \t]+::\\)\\([ \t]+\\|$\\)"
               1 'org-list-dt prepend)
             ;; ARCHIVEd headings
             (list (concat
                    org-outline-regexp-bol
                    "\\(.*:" org-archive-tag ":.*\\)")
                   '(1 'org-archived prepend))
             ;; Specials
             '(org-do-latex-and-related)
             '(org-fontify-entities)
             '(org-raise-scripts)
             ;; Code
             '(org-activate-code (1 'org-code t))
             ;; COMMENT
             (list (format
                    "^\\*+\\(?: +%s\\)?\\(?: +\\[#[A-Z0-9]\\]\\)? +\\(?9:%s\\)\\(?: \\|$\\)"
                    org-todo-regexp
                    org-comment-string)
                   '(9 'org-special-keyword t))
             ;; Blocks and meta lines
             '(org-fontify-meta-lines-and-blocks))))
      (setq org-font-lock-extra-keywords (delq nil org-font-lock-extra-keywords))
      (run-hooks 'org-font-lock-set-keywords-hook)
      ;; Now set the full font-lock-keywords
      (setq-local org-font-lock-keywords org-font-lock-extra-keywords)
      (setq-local font-lock-defaults
                  '(org-font-lock-keywords t nil nil backward-paragraph))
      (kill-local-variable 'font-lock-keywords)
      nil))
  (advice-add 'org-set-font-lock-defaults :override #'*org-set-font-lock-defaults)
  (defface org-deadline-custom '((t (:inherit 'default))) "org-deadline" :group 'org)
  (defface org-scheduled-custom '((t (:inherit 'default))) "org-schedule" :group 'org)
  (defface org-closed-custom '((t (:inherit 'default))) "org-close" :group 'org)
  (defface org-deadline-custom-braket '((t (:inherit 'default))) "org-deadline" :group 'org)
  (defface org-scheduled-custom-braket '((t (:inherit 'default))) "org-schedule" :group 'org)
  (defface org-closed-custom-braket '((t (:inherit 'default))) "org-close" :group 'org)


  (defun *org-eldoc-get-timestamp (str)
    "Return timestamp if on a headline or nil."
    (if str
        (concat
         (let ((deadline (org-entry-get (point) "DEADLINE" t))
               (scheduled (org-entry-get (point) "SCHEDULED" t))
               (closed (org-entry-get (point) "CLOSED" t))
               timestamp)
           (if deadline (setq timestamp (concat timestamp (propertize (substring deadline 1 -1) 'face 'org-deadline-custom) " ")))
           (if scheduled (setq timestamp (concat timestamp (propertize (substring scheduled 1 -1) 'face 'org-scheduled-custom) " ")))
           (if closed (setq timestamp (concat timestamp (propertize (substring closed 1 -1) 'face 'org-closed-custom) " ")))
           timestamp)
         str)
      nil))

  (advice-add 'org-eldoc-get-breadcrumb :filter-return #'*org-eldoc-get-timestamp)

  (defun *org-format-outline-path-normalize (str)
    (add-face-text-property
     0 (length str)
     '(:height 1) nil str)
    str)
  (advice-add 'org-format-outline-path :filter-return #'*org-format-outline-path-normalize)
#+END_SRC

** DISABLED Persistent Scratch
This has been giving me intermittent trouble. I'm disabling it for now in
favor of [[info:remember][remember]].
CLOSED: [2018-04-03 Tue 20:57]
Make the content of the scratch buffer [[https://github.com/Fanael/persistent-scratch][persist]] between settings
#+BEGIN_SRC emacs-lisp
  (use-package persistent-scratch
    :demand t
    :init
    (setq persistent-scratch-backup-directory (concat cpm-cache-dir "scratch-backups"))
    (setq persistent-scratch-save-file (concat cpm-cache-dir "persistent-scratch"))
    (setq persistent-scratch-autosave-mode 1)
    (setq persistent-scratch-autosave-interval 60)
    :config
    (ignore-errors (persistent-scratch-setup-default)))
#+END_SRC

** TESTING Framegroups
Yet another [[https://github.com/noctuid/framegroups.el][workspace management]] package
#+BEGIN_SRC emacs-lisp
  (use-package framegroups
    :ensure nil
    :commands (fg-switch-to-frame fg-create-frame fg-switch)
    :load-path "~/.emacs.d/.local/elisp/framegroups.el/"
    :config
    ;; enable `desktop-save-mode' for persistence
  ;; NOTE: It seems Emacs occasionally hangs when restoring a lot of frames with
  ;; desktop.el
    ;; (fg-desktop-setup)
    ;; (desktop-save-mode)

  ;; binding keys to switch to specific framegroups
  (general-define-key "C-c e" '(fg-switch "emacs"))
  (general-define-key "C-c p" '(fg-switch "prog"))
  ;; ...

  ;; default layouts for framegroups
  (defun cpm/my-framegroup-setup (name &rest _)
    "Set up default framegroup layouts."
    (interactive)
    (pcase name
      ;; emacs configuration
      ("emacs"
       (find-file "~/.emacs.d/config.org"))
      ;; programming projects
      ("prog"
       (find-file "~/bin"))
      ;; dotfiles
      ("dotfiles"
       (find-file "~/dotfiles/dotfiles.org"))
      ("PHIL232"
       (find-file "~/Dropbox/Work/projects/phil232/phil232_lecture_outline.org")
       (split-window-right)
       (find-file "~/Dropbox/Work/projects/phil232/content/notes/phil232_in-class_notes.org"))
      ("PHIL105"
       (find-file "~/Dropbox/Work/projects/phil105/content/slides/phil105_lecture_outline.org")
       (split-window-right)
       (find-file "~/Dropbox/Work/projects/phil105/content/slides/"))))

  (add-hook 'fg-create-hook #'cpm/my-framegroup-setup)

  ;; binding keys for the current framegroup
  (defmacro cpm/my-ff (file)
    "Wrapper for creating `find-file' commands."
    `(lambda () (interactive) (find-file ,file)))

  (defun cpm/my-framegroup-keybindings (name &rest _)
    (pcase name
      ("emacs"
       (global-set-key "C-c , i" (cpm/my-ff "~/.emacs.d/init.el")))
      ("PHIL 232"
       (global-set-key "C-c , s" (cpm/my-ff "schedule.org"))
       (global-set-key "C-c , f" #'projectile-find-file))
      ))

  (add-hook 'fg-after-switch-hook #'my-framegroup-keybindings))

  (defun cpm/load-phil105 ()
    (interactive)
    (new-frame)
    (fg-create-frame "PHIL105"))
#+END_SRC

** DISABLED Doc View Mode
CLOSED: [2018-02-03 Sat 10:44]
Disabled for now
#+begin_src emacs-lisp
  (use-package doc-view
    :config
      (fset 'doc-prev "\C-xo\C-x[\C-xo")
      (fset 'doc-next "\C-xo\C-x]\C-xo")
      (global-set-key (kbd "M-[") 'doc-prev)
      (global-set-key (kbd "M-]") 'doc-next)
      (evil-set-initial-state 'doc-view-mode 'normal)
      (evil-define-key 'normal doc-view-mode-map
        "/"  'spacemacs/doc-view-search-new-query
        "?"  'spacemacs/doc-view-search-new-query-backward
        "gg" 'doc-view-first-page
        "f"  'doc-view-autofit-mode
        "G"  'doc-view-last-page
        "gt" 'doc-view-goto-page
        "h"  'doc-view-previous-page
        "j"  'doc-view-next-line-or-next-page
        "k"  'doc-view-previous-line-or-previous-page
        "K"  'doc-view-kill-proc-and-buffer
        "l"  'doc-view-next-page
        "n"  'doc-view-search
        "N"  'doc-view-search-backward
        "-"  'doc-view-shrink
        "+"  'doc-view-enlarge
        (kbd "C-d") 'doc-view-scroll-up-or-next-page
        (kbd "C-k") 'doc-view-kill-proc
        (kbd "C-u") 'doc-view-scroll-down-or-previous-page)
      (progn
        (defun spacemacs/doc-view-search-new-query ()
          "Initiate a new query."
          (interactive)
          (doc-view-search 'newquery))

        (defun spacemacs/doc-view-search-new-query-backward ()
          "Initiate a new query."
          (interactive)
          (doc-view-search 'newquery t))

  (defcustom doc-view-autofit-timer-start 1.0
  "Initial value (seconds) for the timer that delays the fitting when
  `doc-view-autofit-fit' is called (Which is when a window
  configuration change occurs and a document needs to be fitted)."
  :type 'number
  :group 'doc-view)

  (defcustom doc-view-autofit-timer-inc 0.02
  "Value to increase (seconds) the timer (see `doc-view-autofit-timer-start')
  by, if there is another window configuration change occuring, before
  it runs out."
  :type 'number
  :group 'doc-view)

  (defcustom doc-view-autofit-default-fit 'width
  "The fitting type initially used when mode is enabled.
  Valid values are: width, height, page."
  :type 'symbol
  :group 'doc-view)

  (defvar doc-view-autofit-mode-map
  (let ((map (make-sparse-keymap)))
      (define-key map (kbd "C-c W") 'doc-view-autofit-width)
      (define-key map (kbd "C-c H") 'doc-view-autofit-height)
      (define-key map (kbd "C-c P") 'doc-view-autofit-page)
      map)
  "Keymap used by `doc-view-autofit-mode'.")

  (defun doc-view-autofit-set (type)
  "Set autofitting to TYPE for current buffer."
  (when doc-view-autofit-mode
      (setq doc-view-autofit-type type)
      (doc-view-autofit-fit)))

  (defun doc-view-autofit-width ()
  "Set autofitting to width for current buffer."
  (interactive) (doc-view-autofit-set 'width))

  (defun doc-view-autofit-height ()
  "Set autofitting to height for current buffer."
  (interactive) (doc-view-autofit-set 'height))

  (defun doc-view-autofit-page ()
  "Set autofitting to page for current buffer."
  (interactive) (doc-view-autofit-set 'page))

  (defun doc-view-autofit-fit ()
  "Fits the document in the selected window's buffer
  delayed with a timer, so multiple calls in succession
  don't cause as much overhead."
  (lexical-let
      ((window (selected-window)))
      (if (equal doc-view-autofit-timer nil)
          (setq doc-view-autofit-timer
              (run-with-timer
              doc-view-autofit-timer-start nil
              (lambda ()
                  (if (window-live-p window)
                      (save-selected-window
                      (select-window window)
                      (cancel-timer doc-view-autofit-timer)
                      (setq doc-view-autofit-timer nil)
                      (cond
                          ((equal 'width doc-view-autofit-type)
                          (doc-view-fit-width-to-window))
                          ((equal 'height doc-view-autofit-type)
                          (doc-view-fit-height-to-window))
                          ((equal 'page doc-view-autofit-type)
                          (doc-view-fit-page-to-window))))))))
      (timer-inc-time doc-view-autofit-timer doc-view-autofit-timer-inc))))

  (define-minor-mode doc-view-autofit-mode
  "Minor mode for automatic (timer based) fitting in DocView."
  :lighter " AFit" :keymap doc-view-autofit-mode-map :group 'doc-view
  (when doc-view-autofit-mode
      (set (make-local-variable 'doc-view-autofit-type)
          doc-view-autofit-default-fit)
      (set (make-local-variable 'doc-view-autofit-timer) nil)
      (add-hook 'window-configuration-change-hook
              'doc-view-autofit-fit nil t)
      (doc-view-autofit-fit))
  (when (not doc-view-autofit-mode)
      (remove-hook 'window-configuration-change-hook
                  'doc-view-autofit-fit t)
      (when doc-view-autofit-timer
      (cancel-timer doc-view-autofit-timer)
      (setq doc-view-autofit-timer nil))
      (setq doc-view-autofit-type nil)))

  (add-hook 'doc-view-mode-hook 'doc-view-autofit-mode)
  ;; reload when file changes
  (add-hook 'doc-view-mode-hook 'auto-revert-mode)
  ;; continuous scroll mode
  (setq doc-view-continuous t)
  ))
#+end_src

** Org Super agenda settings
#+BEGIN_SRC emacs-lisp :tangle no
(use-package org-super-agenda
  :commands super-jump-to-org-agenda
  :preface
  (defun super-jump-to-org-agenda ()
    (interactive)
    (let ((org-super-agenda-groups
           '((:name "ACTION"
                    :time-grid t
                    :todo "NEXT"
                    :order 1)
             (:name "To Read"
                    :todo "TO-READ"
                    :order 2)
             (:name "In Progress"
                    :todo "INPROGRESS"
                    :order 7)
             (:todo "WAITING" :order 8)
             (:todo ("FIXME" "REVISE")
                    :order 3)
             (:priority<= "B" :order 1))))
      (org-agenda nil "a")))
  :config
  (org-super-agenda-mode))
#+END_SRC

** DISABLED Doom Modeline
CLOSED: [2018-03-15 Thu 15:09]
The Doom modeline
#+BEGIN_SRC emacs-lisp
(require 'evil)
(require 'projectile)

(use-package powerline) 

;; fix error on byte-compile
(eval-when-compile
(defvar mode-line-height 30
  "How tall the mode-line should be. This is only respected in GUI emacs."))

;; Load powerline only when uncompiled, in order to generate the xpm bitmaps for
;; the mode-line. This is the tall blue bar on the left of the mode-line.
;; NOTE Compile this file for a faster startup!
(eval-when-compile (require 'powerline))
;; FIXME Don't hardcode colors in

(defvar mode-line-bar          (eval-when-compile (pl/percent-xpm mode-line-height 100 0 100 0 3 "#268bd2" nil)))
(defvar mode-line-eldoc-bar    (eval-when-compile (pl/percent-xpm mode-line-height 100 0 100 0 3 "#B3EF00" nil)))
(defvar mode-line-inactive-bar (eval-when-compile (pl/percent-xpm mode-line-height 100 0 100 0 3 nil nil)))

;; Custom faces
(defface mode-line-is-modified nil
  "Face for mode-line modified symbol")

(defface mode-line-2 nil
  "The alternate color for mode-line text.")

(defface mode-line-highlight nil
  "Face for bright segments of the mode-line.")

(defface mode-line-count-face nil
  "Face for anzu/evil-substitute/evil-search number-of-matches display.")

;; Git/VCS segment faces
(defface mode-line-vcs-info '((t (:inherit warning)))
  "")
(defface mode-line-vcs-warning '((t (:inherit warning)))
  "")

;; Flycheck segment faces
(defface doom-flycheck-error '((t (:inherit error)))
  "Face for flycheck error feedback in the modeline.")
(defface doom-flycheck-warning '((t (:inherit warning)))
  "Face for flycheck warning feedback in the modeline.")


;;
;; Functions
;;

(defun doom-ml-fix-unicode (font &rest chars)
  "Display certain unicode characters in a specific font.

e.g. (doom-fix-unicode \"DejaVu Sans\" ?⚠ ?★ ?λ)"
  (declare (indent 1))
  (mapc (lambda (x) (set-fontset-font
                t (cons x x)
                (cond ((fontp font)
                       font)
                      ((listp font)
                       (font-spec :family (car font) :size (nth 1 font)))
                      ((stringp font)
                       (font-spec :family font))
                      (t (error "FONT is an invalid type: %s" font)))))
        chars))

(defun doom-ml-project-root (&optional strict-p)
  "Get the path to the root of your project."
  (let (projectile-require-project-root strict-p)
    (projectile-project-root)))

(defun doom-ml-flycheck-count (state)
  "Return flycheck information for the given error type STATE."
  (when (flycheck-has-current-errors-p state)
    (if (eq 'running flycheck-last-status-change)
        "?"
      (cdr-safe (assq state (flycheck-count-errors flycheck-current-errors))))))

;; pyenv/rbenv version segment
(defvar doom-ml-env-version-hook '()
  "Hook that runs whenever the environment version changes (e.g. rbenv/pyenv)")

(defun doom-ml|env-update ()
  (when doom-ml--env-command
    (let ((default-directory (doom-ml-project-root)))
      (let ((s (shell-command-to-string doom-ml--env-command)))
        (setq doom-ml--env-version (if (string-match "[ \t\n\r]+\\'" s)
                                    (replace-match "" t t s)
                                  s))
        (run-hook-with-args 'doom-ml-env-version-hook doom-ml--env-version)))))

(defmacro def-version-cmd! (modes command)
  "Define a COMMAND for MODE that will set `doom-ml--env-command' when that mode is
activated, which should return the version number of the current environment. It is used
by `doom-ml|env-update' to display a version number in the modeline. For instance:

  (def-version-cmd! ruby-mode \"ruby --version | cut -d' ' -f2\")

This will display the ruby version in the modeline in ruby-mode buffers. It is cached the
first time."
  (add-hook! (focus-in find-file) 'doom-ml|env-update)
  `(add-hook! ,modes (setq doom-ml--env-command ,command)))

(def-version-cmd! python-mode "python --version 2>&1 | cut -d' ' -f2")
(def-version-cmd! ruby-mode "ruby --version | cut -d' ' -f2")


;;
;; Initialization
;;

;; Where (py|rb)env version strings will be stored
(defvar-local doom-ml--env-version nil)
(defvar-local doom-ml--env-command nil)

;; Make certain unicode glyphs bigger for the mode-line.
;; FIXME Replace with all-the-icons?
(doom-ml-fix-unicode '("DejaVuSansMono Nerd Font" 15) ?✱) ;; modified symbol
(let ((font "DejaVu Sans Mono for Powerline"))
  (doom-ml-fix-unicode (list font 12) ?)  ;; git symbol
  (doom-ml-fix-unicode (list font 16) ?∄)  ;; non-existent-file symbol
  (doom-ml-fix-unicode (list font 15) ?)) ;; read-only symbol

;; So the mode-line can keep track of "the current window"
(defvar mode-line-selected-window nil)
(defun doom|set-selected-window (&rest _)
  (let ((window (frame-selected-window)))
    (unless (minibuffer-window-active-p window)
      (setq mode-line-selected-window window))))
(add-hook 'window-configuration-change-hook #'doom|set-selected-window)
(add-hook 'focus-in-hook #'doom|set-selected-window)
(advice-add 'select-window :after 'doom|set-selected-window)
(advice-add 'select-frame  :after 'doom|set-selected-window)


;;
;; Mode-line segments
;;

(defun *buffer-path ()
  "Displays the buffer's full path relative to the project root (includes the
project root). Excludes the file basename. See `*buffer-name' for that."
  (when buffer-file-name
    (propertize
     (f-dirname
      (let ((buffer-path (file-relative-name buffer-file-name (doom-ml-project-root)))
            (max-length (truncate (/ (window-body-width) 1.75))))
        (concat (projectile-project-name) "/"
                (if (> (length buffer-path) max-length)
                    (let ((path (reverse (split-string buffer-path "/" t)))
                          (output ""))
                      (when (and path (equal "" (car path)))
                        (setq path (cdr path)))
                      (while (and path (<= (length output) (- max-length 4)))
                        (setq output (concat (car path) "/" output))
                        (setq path (cdr path)))
                      (when path
                        (setq output (concat "../" output)))
                      (when (string-suffix-p "/" output)
                        (setq output (substring output 0 -1)))
                      output)
                  buffer-path))))
     'face (if active 'mode-line-2))))

(defun *buffer-name ()
  "The buffer's base name or id."
  ;; FIXME Don't show uniquify tags
  (s-trim-left (format-mode-line "%b")))

(defun *buffer-pwd ()
  "Displays `default-directory', for special buffers like the scratch buffer."
  (propertize
   (concat "[" (abbreviate-file-name default-directory) "]")
   'face 'mode-line-2))

(defun *buffer-state ()
  "Displays symbols representing the buffer's state
(non-existent/modified/read-only)"
  (when buffer-file-name
    (propertize
     (concat (if (not (file-exists-p buffer-file-name))
                 "∄"
               (if (buffer-modified-p) "✱"))
             (if buffer-read-only ""))
     'face 'mode-line-is-modified)))

(defun *buffer-encoding-abbrev ()
  "The line ending convention used in the buffer."
  (if (memq buffer-file-coding-system '(utf-8 utf-8-unix))
      ""
    (symbol-name buffer-file-coding-system)))

(defun *major-mode ()
  "The major mode, including process, environment and text-scale info."
  (concat (format-mode-line mode-name)
          (if (stringp mode-line-process) mode-line-process)
          (if doom-ml--env-version (concat " " doom-ml--env-version))
          (and (featurep 'face-remap)
               (/= text-scale-mode-amount 0)
               (format " (%+d)" text-scale-mode-amount))))

(defun *vc ()
  "Displays the current branch, colored based on its state."
  (when vc-mode
    (let ((backend (concat "  " (substring vc-mode (+ 2 (length (symbol-name (vc-backend buffer-file-name)))))))
          (face (let ((state (vc-state buffer-file-name)))
                  (cond ((memq state '(edited added))
                         'mode-line-vcs-info)
                        ((memq state '(removed needs-merge needs-update conflict removed unregistered))
                         'mode-line-vcs-warning)))))
      (if active
          (propertize backend 'face face)
        backend))))

(defvar-local doom--flycheck-err-cache nil "")
(defvar-local doom--flycheck-cache nil "")
(defun *flycheck ()
  "Persistent and cached flycheck indicators in the mode-line."
  (when (and (featurep 'flycheck)
             flycheck-mode
             (or flycheck-current-errors
                 (eq 'running flycheck-last-status-change)))
    (or (and (or (eq doom--flycheck-err-cache doom--flycheck-cache)
                 (memq flycheck-last-status-change '(running not-checked)))
             doom--flycheck-cache)
        (and (setq doom--flycheck-err-cache flycheck-current-errors)
             (setq doom--flycheck-cache
                   (let ((fe (doom-ml-flycheck-count 'error))
                         (fw (doom-ml-flycheck-count 'warning)))
                     (concat
                      (if fe (propertize (format " •%d " fe)
                                         'face (if active
                                                   'doom-flycheck-error
                                                 'mode-line)))
                      (if fw (propertize (format " •%d " fw)
                                         'face (if active
                                                   'doom-flycheck-warning
                                                 'mode-line))))))))))

(defun *selection-info ()
  "Information about the current selection, such as how many characters and
lines are selected, or the NxM dimensions of a block selection."
  (when (and active (evil-visual-state-p))
    (propertize
     (let ((reg-beg (region-beginning))
           (reg-end (region-end))
           (evil (eq 'visual evil-state)))
       (let ((lines (count-lines reg-beg (min (1+ reg-end) (point-max))))
             (chars (- (1+ reg-end) reg-beg))
             (cols (1+ (abs (- (evil-column reg-end)
                               (evil-column reg-beg))))))
         (cond
          ;; rectangle selection
          ((or (bound-and-true-p rectangle-mark-mode)
               (and evil (eq 'block evil-visual-selection)))
           (format " %dx%dB " lines (if evil cols (1- cols))))
          ;; line selection
          ((or (> lines 1) (eq 'line evil-visual-selection))
           (if (and (eq evil-state 'visual) (eq evil-this-type 'line))
               (format " %dL " lines)
             (format " %dC %dL " chars lines)))
          (t (format " %dC " (if evil chars (1- chars)))))))
     'face 'mode-line-highlight)))

(defun *macro-recording ()
  "Display current macro being recorded."
  (when (and active defining-kbd-macro)
    (propertize
     (format " %s ▶ " (char-to-string evil-this-macro))
     'face 'mode-line-highlight)))

(make-variable-buffer-local 'anzu--state)
(defun *anzu ()
  "Show the current match number and the total number of matches. Requires anzu
to be enabled."
  (when (and (featurep 'evil) (featurep 'evil-anzu) (evil-ex-hl-active-p 'evil-ex-search))
    (propertize
     (format " %s/%d%s "
             anzu--current-position anzu--total-matched
             (if anzu--overflow-p "+" ""))
     'face (if active 'mode-line-count-face))))

(defun *evil-substitute ()
  "Show number of :s matches in real time."
  (when (and (featurep 'evil) (evil-ex-p) (evil-ex-hl-active-p 'evil-ex-substitute))
    (propertize
     (let ((range (if evil-ex-range
                      (cons (car evil-ex-range) (cadr evil-ex-range))
                    (cons (line-beginning-position) (line-end-position))))
           (pattern (car-safe (evil-delimited-arguments evil-ex-argument 2))))
       (if pattern
           (format " %s matches "
                   (count-matches pattern (car range) (cdr range))
                   evil-ex-argument)
         " ... "))
     'face (if active 'mode-line-count-face))))

(defun *iedit ()
  "Show the number of iedit regions matches + what match you're on."
  (when (bound-and-true-p iedit-mode)
    (propertize
     (let ((this-oc (let (message-log-max) (iedit-find-current-occurrence-overlay)))
           (length (or (ignore-errors (length iedit-occurrences-overlays)) 0)))
       (format
        " %s/%s "
        (save-excursion
          (unless this-oc
            (iedit-prev-occurrence)
            (setq this-oc (iedit-find-current-occurrence-overlay)))
          (if this-oc
              ;; NOTE: Not terribly reliable
              (- length (-elem-index this-oc iedit-occurrences-overlays))
            "-"))
        length))
     'face (if active 'mode-line-count-face))))

(defun *buffer-position ()
  "A more vim-like buffer position."
  (let ((start (window-start))
        (end (window-end))
        (pend (point-max)))
    (if (and (= start 1)
             (= end pend))
        ":All"
      (cond ((= start 1) ":Top")
            ((= end pend) ":Bot")
            (t (format ":%d%%%%" (/ end 0.01 pend)))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun doom-mode-line (&optional id)
  `(:eval
    (let* ((active (eq (selected-window) mode-line-selected-window))
           (lhs (list (propertize " " 'display (if active mode-line-bar mode-line-inactive-bar))
                      (*flycheck)
                      (*macro-recording)
                      (*selection-info)
                      (*anzu)
                      (*evil-substitute)
                      (*iedit)
                      " "
                      (*buffer-path)
                      (*buffer-name)
                      " "
                      (*buffer-state)
                      ,(if (eq id 'scratch) '(*buffer-pwd))))
           (rhs (list (*buffer-encoding-abbrev)
                      (*vc)
                      "  " (*major-mode) "  "
                      (propertize
                       (concat "(%l,%c) " (*buffer-position))
                       'face (if active 'mode-line-2))))
           (middle (propertize
                    " " 'display `((space :align-to (- (+ right right-fringe right-margin)
                                                       ,(1+ (string-width (format-mode-line rhs)))))))))
      (with-demoted-errors "Mode-line error: %s" (list lhs middle rhs)))))

(setq-default mode-line-format (doom-mode-line))

#+END_SRC

** DISABLED Doom Modeline
CLOSED: [2018-03-15 Thu 15:09]
The Doom modeline
#+BEGIN_SRC emacs-lisp
(require 'evil)
(require 'projectile)

(use-package powerline) 

;; fix error on byte-compile
(eval-when-compile
(defvar mode-line-height 30
  "How tall the mode-line should be. This is only respected in GUI emacs."))

;; Load powerline only when uncompiled, in order to generate the xpm bitmaps for
;; the mode-line. This is the tall blue bar on the left of the mode-line.
;; NOTE Compile this file for a faster startup!
(eval-when-compile (require 'powerline))
;; FIXME Don't hardcode colors in

(defvar mode-line-bar          (eval-when-compile (pl/percent-xpm mode-line-height 100 0 100 0 3 "#268bd2" nil)))
(defvar mode-line-eldoc-bar    (eval-when-compile (pl/percent-xpm mode-line-height 100 0 100 0 3 "#B3EF00" nil)))
(defvar mode-line-inactive-bar (eval-when-compile (pl/percent-xpm mode-line-height 100 0 100 0 3 nil nil)))

;; Custom faces
(defface mode-line-is-modified nil
  "Face for mode-line modified symbol")

(defface mode-line-2 nil
  "The alternate color for mode-line text.")

(defface mode-line-highlight nil
  "Face for bright segments of the mode-line.")

(defface mode-line-count-face nil
  "Face for anzu/evil-substitute/evil-search number-of-matches display.")

;; Git/VCS segment faces
(defface mode-line-vcs-info '((t (:inherit warning)))
  "")
(defface mode-line-vcs-warning '((t (:inherit warning)))
  "")

;; Flycheck segment faces
(defface doom-flycheck-error '((t (:inherit error)))
  "Face for flycheck error feedback in the modeline.")
(defface doom-flycheck-warning '((t (:inherit warning)))
  "Face for flycheck warning feedback in the modeline.")


;;
;; Functions
;;

(defun doom-ml-fix-unicode (font &rest chars)
  "Display certain unicode characters in a specific font.

e.g. (doom-fix-unicode \"DejaVu Sans\" ?⚠ ?★ ?λ)"
  (declare (indent 1))
  (mapc (lambda (x) (set-fontset-font
                t (cons x x)
                (cond ((fontp font)
                       font)
                      ((listp font)
                       (font-spec :family (car font) :size (nth 1 font)))
                      ((stringp font)
                       (font-spec :family font))
                      (t (error "FONT is an invalid type: %s" font)))))
        chars))

(defun doom-ml-project-root (&optional strict-p)
  "Get the path to the root of your project."
  (let (projectile-require-project-root strict-p)
    (projectile-project-root)))

(defun doom-ml-flycheck-count (state)
  "Return flycheck information for the given error type STATE."
  (when (flycheck-has-current-errors-p state)
    (if (eq 'running flycheck-last-status-change)
        "?"
      (cdr-safe (assq state (flycheck-count-errors flycheck-current-errors))))))

;; pyenv/rbenv version segment
(defvar doom-ml-env-version-hook '()
  "Hook that runs whenever the environment version changes (e.g. rbenv/pyenv)")

(defun doom-ml|env-update ()
  (when doom-ml--env-command
    (let ((default-directory (doom-ml-project-root)))
      (let ((s (shell-command-to-string doom-ml--env-command)))
        (setq doom-ml--env-version (if (string-match "[ \t\n\r]+\\'" s)
                                    (replace-match "" t t s)
                                  s))
        (run-hook-with-args 'doom-ml-env-version-hook doom-ml--env-version)))))

(defmacro def-version-cmd! (modes command)
  "Define a COMMAND for MODE that will set `doom-ml--env-command' when that mode is
activated, which should return the version number of the current environment. It is used
by `doom-ml|env-update' to display a version number in the modeline. For instance:

  (def-version-cmd! ruby-mode \"ruby --version | cut -d' ' -f2\")

This will display the ruby version in the modeline in ruby-mode buffers. It is cached the
first time."
  (add-hook! (focus-in find-file) 'doom-ml|env-update)
  `(add-hook! ,modes (setq doom-ml--env-command ,command)))

(def-version-cmd! python-mode "python --version 2>&1 | cut -d' ' -f2")
(def-version-cmd! ruby-mode "ruby --version | cut -d' ' -f2")


;;
;; Initialization
;;

;; Where (py|rb)env version strings will be stored
(defvar-local doom-ml--env-version nil)
(defvar-local doom-ml--env-command nil)

;; Make certain unicode glyphs bigger for the mode-line.
;; FIXME Replace with all-the-icons?
(doom-ml-fix-unicode '("DejaVuSansMono Nerd Font" 15) ?✱) ;; modified symbol
(let ((font "DejaVu Sans Mono for Powerline"))
  (doom-ml-fix-unicode (list font 12) ?)  ;; git symbol
  (doom-ml-fix-unicode (list font 16) ?∄)  ;; non-existent-file symbol
  (doom-ml-fix-unicode (list font 15) ?)) ;; read-only symbol

;; So the mode-line can keep track of "the current window"
(defvar mode-line-selected-window nil)
(defun doom|set-selected-window (&rest _)
  (let ((window (frame-selected-window)))
    (unless (minibuffer-window-active-p window)
      (setq mode-line-selected-window window))))
(add-hook 'window-configuration-change-hook #'doom|set-selected-window)
(add-hook 'focus-in-hook #'doom|set-selected-window)
(advice-add 'select-window :after 'doom|set-selected-window)
(advice-add 'select-frame  :after 'doom|set-selected-window)


;;
;; Mode-line segments
;;

(defun *buffer-path ()
  "Displays the buffer's full path relative to the project root (includes the
project root). Excludes the file basename. See `*buffer-name' for that."
  (when buffer-file-name
    (propertize
     (f-dirname
      (let ((buffer-path (file-relative-name buffer-file-name (doom-ml-project-root)))
            (max-length (truncate (/ (window-body-width) 1.75))))
        (concat (projectile-project-name) "/"
                (if (> (length buffer-path) max-length)
                    (let ((path (reverse (split-string buffer-path "/" t)))
                          (output ""))
                      (when (and path (equal "" (car path)))
                        (setq path (cdr path)))
                      (while (and path (<= (length output) (- max-length 4)))
                        (setq output (concat (car path) "/" output))
                        (setq path (cdr path)))
                      (when path
                        (setq output (concat "../" output)))
                      (when (string-suffix-p "/" output)
                        (setq output (substring output 0 -1)))
                      output)
                  buffer-path))))
     'face (if active 'mode-line-2))))

(defun *buffer-name ()
  "The buffer's base name or id."
  ;; FIXME Don't show uniquify tags
  (s-trim-left (format-mode-line "%b")))

(defun *buffer-pwd ()
  "Displays `default-directory', for special buffers like the scratch buffer."
  (propertize
   (concat "[" (abbreviate-file-name default-directory) "]")
   'face 'mode-line-2))

(defun *buffer-state ()
  "Displays symbols representing the buffer's state
(non-existent/modified/read-only)"
  (when buffer-file-name
    (propertize
     (concat (if (not (file-exists-p buffer-file-name))
                 "∄"
               (if (buffer-modified-p) "✱"))
             (if buffer-read-only ""))
     'face 'mode-line-is-modified)))

(defun *buffer-encoding-abbrev ()
  "The line ending convention used in the buffer."
  (if (memq buffer-file-coding-system '(utf-8 utf-8-unix))
      ""
    (symbol-name buffer-file-coding-system)))

(defun *major-mode ()
  "The major mode, including process, environment and text-scale info."
  (concat (format-mode-line mode-name)
          (if (stringp mode-line-process) mode-line-process)
          (if doom-ml--env-version (concat " " doom-ml--env-version))
          (and (featurep 'face-remap)
               (/= text-scale-mode-amount 0)
               (format " (%+d)" text-scale-mode-amount))))

(defun *vc ()
  "Displays the current branch, colored based on its state."
  (when vc-mode
    (let ((backend (concat "  " (substring vc-mode (+ 2 (length (symbol-name (vc-backend buffer-file-name)))))))
          (face (let ((state (vc-state buffer-file-name)))
                  (cond ((memq state '(edited added))
                         'mode-line-vcs-info)
                        ((memq state '(removed needs-merge needs-update conflict removed unregistered))
                         'mode-line-vcs-warning)))))
      (if active
          (propertize backend 'face face)
        backend))))

(defvar-local doom--flycheck-err-cache nil "")
(defvar-local doom--flycheck-cache nil "")
(defun *flycheck ()
  "Persistent and cached flycheck indicators in the mode-line."
  (when (and (featurep 'flycheck)
             flycheck-mode
             (or flycheck-current-errors
                 (eq 'running flycheck-last-status-change)))
    (or (and (or (eq doom--flycheck-err-cache doom--flycheck-cache)
                 (memq flycheck-last-status-change '(running not-checked)))
             doom--flycheck-cache)
        (and (setq doom--flycheck-err-cache flycheck-current-errors)
             (setq doom--flycheck-cache
                   (let ((fe (doom-ml-flycheck-count 'error))
                         (fw (doom-ml-flycheck-count 'warning)))
                     (concat
                      (if fe (propertize (format " •%d " fe)
                                         'face (if active
                                                   'doom-flycheck-error
                                                 'mode-line)))
                      (if fw (propertize (format " •%d " fw)
                                         'face (if active
                                                   'doom-flycheck-warning
                                                 'mode-line))))))))))

(defun *selection-info ()
  "Information about the current selection, such as how many characters and
lines are selected, or the NxM dimensions of a block selection."
  (when (and active (evil-visual-state-p))
    (propertize
     (let ((reg-beg (region-beginning))
           (reg-end (region-end))
           (evil (eq 'visual evil-state)))
       (let ((lines (count-lines reg-beg (min (1+ reg-end) (point-max))))
             (chars (- (1+ reg-end) reg-beg))
             (cols (1+ (abs (- (evil-column reg-end)
                               (evil-column reg-beg))))))
         (cond
          ;; rectangle selection
          ((or (bound-and-true-p rectangle-mark-mode)
               (and evil (eq 'block evil-visual-selection)))
           (format " %dx%dB " lines (if evil cols (1- cols))))
          ;; line selection
          ((or (> lines 1) (eq 'line evil-visual-selection))
           (if (and (eq evil-state 'visual) (eq evil-this-type 'line))
               (format " %dL " lines)
             (format " %dC %dL " chars lines)))
          (t (format " %dC " (if evil chars (1- chars)))))))
     'face 'mode-line-highlight)))

(defun *macro-recording ()
  "Display current macro being recorded."
  (when (and active defining-kbd-macro)
    (propertize
     (format " %s ▶ " (char-to-string evil-this-macro))
     'face 'mode-line-highlight)))

(make-variable-buffer-local 'anzu--state)
(defun *anzu ()
  "Show the current match number and the total number of matches. Requires anzu
to be enabled."
  (when (and (featurep 'evil) (featurep 'evil-anzu) (evil-ex-hl-active-p 'evil-ex-search))
    (propertize
     (format " %s/%d%s "
             anzu--current-position anzu--total-matched
             (if anzu--overflow-p "+" ""))
     'face (if active 'mode-line-count-face))))

(defun *evil-substitute ()
  "Show number of :s matches in real time."
  (when (and (featurep 'evil) (evil-ex-p) (evil-ex-hl-active-p 'evil-ex-substitute))
    (propertize
     (let ((range (if evil-ex-range
                      (cons (car evil-ex-range) (cadr evil-ex-range))
                    (cons (line-beginning-position) (line-end-position))))
           (pattern (car-safe (evil-delimited-arguments evil-ex-argument 2))))
       (if pattern
           (format " %s matches "
                   (count-matches pattern (car range) (cdr range))
                   evil-ex-argument)
         " ... "))
     'face (if active 'mode-line-count-face))))

(defun *iedit ()
  "Show the number of iedit regions matches + what match you're on."
  (when (bound-and-true-p iedit-mode)
    (propertize
     (let ((this-oc (let (message-log-max) (iedit-find-current-occurrence-overlay)))
           (length (or (ignore-errors (length iedit-occurrences-overlays)) 0)))
       (format
        " %s/%s "
        (save-excursion
          (unless this-oc
            (iedit-prev-occurrence)
            (setq this-oc (iedit-find-current-occurrence-overlay)))
          (if this-oc
              ;; NOTE: Not terribly reliable
              (- length (-elem-index this-oc iedit-occurrences-overlays))
            "-"))
        length))
     'face (if active 'mode-line-count-face))))

(defun *buffer-position ()
  "A more vim-like buffer position."
  (let ((start (window-start))
        (end (window-end))
        (pend (point-max)))
    (if (and (= start 1)
             (= end pend))
        ":All"
      (cond ((= start 1) ":Top")
            ((= end pend) ":Bot")
            (t (format ":%d%%%%" (/ end 0.01 pend)))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun doom-mode-line (&optional id)
  `(:eval
    (let* ((active (eq (selected-window) mode-line-selected-window))
           (lhs (list (propertize " " 'display (if active mode-line-bar mode-line-inactive-bar))
                      (*flycheck)
                      (*macro-recording)
                      (*selection-info)
                      (*anzu)
                      (*evil-substitute)
                      (*iedit)
                      " "
                      (*buffer-path)
                      (*buffer-name)
                      " "
                      (*buffer-state)
                      ,(if (eq id 'scratch) '(*buffer-pwd))))
           (rhs (list (*buffer-encoding-abbrev)
                      (*vc)
                      "  " (*major-mode) "  "
                      (propertize
                       (concat "(%l,%c) " (*buffer-position))
                       'face (if active 'mode-line-2))))
           (middle (propertize
                    " " 'display `((space :align-to (- (+ right right-fringe right-margin)
                                                       ,(1+ (string-width (format-mode-line rhs)))))))))
      (with-demoted-errors "Mode-line error: %s" (list lhs middle rhs)))))

(setq-default mode-line-format (doom-mode-line))

#+END_SRC

** EmacsMirror Epkg
A [[https://github.com/emacscollective/epkg][helpful package]] to search [[https://emacsmirror.net][emacsmirror]] for packages
#+BEGIN_SRC emacs-lisp
(use-package epkg
  :commands (epkg-list-packages epkg-list-matching-packages
  epkg-list-keyworded-packages)
  :config
  (evil-set-initial-state 'epkg-list-mode 'motion)
  (setq epkg-repository (concat cpm-cache-dir "epkg-repository")))
#+END_SRC

** DISABLED Circadian Theme-changer (based on time of day)
CLOSED: [2018-02-19 Mon 16:31]
[[https://github.com/guidoschmidt/circadian.el][Change your theme]] depending on location and time of day
#+BEGIN_SRC emacs-lisp 
  (use-package circadian
    :if (display-graphic-p)
    :disabled t
    :defer .25
    :init
    (add-hook 'circadian-after-load-theme-hook
          #'(lambda (theme)
               (if (eq active-theme 'solarized-light) 
                     (cpm/osx-menubar-theme-light)
                     (cpm/osx-menubar-theme-dark))))
    :config
    (ignore-errors
    (setq circadian-themes '(("13:00"  . solarized-light)
                              (:sunset  . solarized-dark))))
    (circadian-setup))
#+END_SRC





** DISABLED Line Numbers (Nlinum mode for emacs 25)
CLOSED: [2018-03-03 Sat 21:24]
 #+BEGIN_SRC emacs-lisp :tangle no
     (use-package nlinum
     :commands nlinum-mode
     :config
      (setq-default nlinum-format "%2d ")
      (setq nlinum-highlight-current-line t)
        (custom-set-faces
         '(nlinum-current-line ((t (:inherit default :foreground "goldenrod1")))))
         '(nlinum-current-line ((t (:inherit default :foreground "goldenrod1" :height 1)))))

   (defun cpm/enable-line-numbers (&optional arg)
     "Enables the display of line numbers, using `display-line-numbers' (in Emacs
   26+) or `nlinum-mode'."
     (if (boundp 'display-line-numbers)
         (setq display-line-numbers t)
       (nlinum-mode +1)))

   (defun cpm/disable-line-numbers ()
     "Disable the display of line numbers."
     (if (boundp 'display-line-numbers)
         (setq display-line-numbers nil)
       (nlinum-mode -1)))

   ;; (add-hook 'prog-mode-hook #'cpm/enable-line-numbers)
   ;; (add-hook 'text-mode-hook #'cpm/enable-line-numbers)
   ;; (add-hook 'conf-mode-hook #'cpm/enable-line-numbers)

 #+END_SRC

** DISABLED Spelling Autocorrect
CLOSED: [2018-06-18 Mon 19:16]
[I think this is otiose given flyspell-abbrev-p]
Use abbrev-mode as my autocorrect. Via [[http://endlessparentheses.com/ispell-and-abbrev-the-perfect-auto-correct.html][Endless Parentheses]]. 

#+BEGIN_SRC emacs-lisp :tangle no
(define-key ctl-x-map "\C-i"
  #'endless/ispell-word-then-abbrev)

(defun endless/simple-get-word ()
  (car-safe (save-excursion (ispell-get-word nil))))

(defun endless/ispell-word-then-abbrev (p)
  "Call `ispell-word', then create an abbrev for it.
With prefix P, create local abbrev. Otherwise it will
be global.
If there's nothing wrong with the word at point, keep
looking for a typo until the beginning of buffer. You can
skip typos you don't want to fix with `SPC', and you can
abort completely with `C-g'."
  (interactive "P")
  (let (bef aft)
    (save-excursion
      (while (if (setq bef (endless/simple-get-word))
                 ;; Word was corrected or used quit.
                 (if (ispell-word nil 'quiet)
                     nil ; End the loop.
                   ;; Also end if we reach `bob'.
                   (not (bobp)))
               ;; If there's no word at point, keep looking
               ;; until `bob'.
               (not (bobp)))
        (backward-word)
        (backward-char))
      (setq aft (endless/simple-get-word)))
    (if (and aft bef (not (equal aft bef)))
        (let ((aft (downcase aft))
              (bef (downcase bef)))
          (define-abbrev
            (if p local-abbrev-table global-abbrev-table)
            bef aft)
          (message "\"%s\" now expands to \"%s\" %sally"
                   bef aft (if p "loc" "glob")))
      (user-error "No typo at or before point"))))

(setq save-abbrevs 'silently)

(use-package abbrev
  :ensure nil
  :commands (abbrev-mode))

#+END_SRC



** TESTING Org Email Capture Workflow
#+BEGIN_SRC emacs-lisp
  (defun cpm/org-mailmate ()
    (interactive) (org-capture nil "m"))


  (defun cpm/email-mailmate-capture ()
    (interactive)
    (make-frame '((name . "Email Capture") (left . 300) (top . 400) (width . 90) (height . 15)))
    (select-frame-by-name "Email Capture")
    (cpm/org-mailmate)
    )

#+END_SRC
